{"path":".obsidian/plugins/text-extractor/cache/a8060e301209b718240dacd81b26f876.json","text":"CPSC 320 2023W1: Tutorial 4 1 Knapsack with Structured Weights: Part 1 The Knapsack Problem is a classic optimization problem in computer science. The most common version is as follows: consider a set of n items, numbered 1, ..., n. Each item i has a positive weight wi > 0 and a positive value vi > 0. Furthermore, we’re given an overall weight capacity C. The problem is to select a subset S ⊆ {1, ..., n} that maximizes the total value of S, but keeps the total weight below C. Formally, we want to maximize ∑ i∈S vi subject to ∑ i∈S wi ≤ C. The knapsack problem is known to be hard: there are no algorithms known that ﬁnd the optimal solution to all instances in better than worst-case exponential time (we’ll study this concept more at the end of the course, when we consider NP-completeness). However, for this tutorial question, we’ll consider a variation of the problem. In particular, we’ll set the capacity as C = 1, and restrict that all weights are either 1/2, 1/4, 1/8, or 1/16. An intuitive greedy approach you might think of to try ﬁrst is by sorting the items in decreasing order of vi/wi, which is the “value density” of each item. Then, go down the list in decreasing order, selecting as many items as ﬁt. 1. Give a small instance of the problem where this greedy algorithm achieves an optimal solution. 2. Give a small instance of the problem where this “value density” greedy algorithm does not give an optimal solution. What goes wrong with this greedy approach? Again, the original Knapsack Problem is a “hard” problem and an eﬃcient algorithm may not exist. However, thanks to the weight restrictions, there is an eﬃcient greedy algorithm that gives an optimal solution to this version of the problem! We’ll derive this algorithm and prove that it works. To avoid special cases in our proofs, assume that we always have an unlimited supply of extra items whose value is 0 in every weight class. 3. Prove that there is always an optimal solution that uses an even number of 1/16-weight items. 4. Prove that if an optimal solution uses c items of weight 1/16, it uses c of the highest value 1/16-weight objects. The preceding two parts suggest how a greedy algorithm might work. Suppose that we sort the 1/16- weight items in decreasing order of value, and then pair up the items in sequence (i.e. the 1st and 2nd items form a pair, then the 3rd and 4th items, then the 5th and 6th, etc.). The previous two parts imply that there is an optimal solution that uses the c highest-valued pairs, for some c. We’ll continue this next time, but meanwhile think about how you might leverage this to get a greedy algorithm. 2 Knapsack with Structured Weights: Part 2 To be continued next time... 1","libVersion":"0.2.1","langs":""}