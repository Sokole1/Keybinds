{"path":".obsidian/plugins/text-extractor/cache/f4c83bed9ac0ff512c5e6d3d57938058.json","text":"6 Computing Averages Let p[l..n] be a 1D array of real-valued numbers. We want to create a 2D n x n array P, where P[i][j] = 0if j < i and otherwise P[i][j] = p(i,j), where pu(i, j) is the average of the numbers in the sub-array pli..j]. That is, if i < j, then pu(i,7) = (p[é] + pli + 1] +... +p[j])/(G —i + 1). 1. (3 points) Here is one algorithm that creates P and computes all entries in the 2D array P[1..n][1..n]. Explain why the runtime is ©(n?). 1: function COMPUTE-AVERAGES(p[1..n]) 2: create the 2D (uninitialized) array P[1..n][1..n] 3: for i from 1 to n do 4 for j from 1 to n do 5: if j <ithen 6: P[i][j] <0 T else s Pllj] « (plil + pli +1)...plj1)/G — i+ 1) 2. (2 points) Modify the above algorithm to obtain an algorithm that runs in time ©(n?) time. You do not need to provide a justification of your runtime or the correctness of your algorithm. 1: function COMPUTE-AVERAGES(p[1..n]) 2: for i from 1 to n do 3 for j from 1 to n do 4 if j <ithen 5: P[i][j] <0 6: else if i == j then 7 Plilj] pli 8: else >i<j 9: P[i][j] + PUT NEW PSEUDOCODE HERE","libVersion":"0.2.1","langs":"eng"}