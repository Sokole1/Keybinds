{"path":".obsidian/plugins/text-extractor/cache/26f7a31f9576ca10a3e88f3b7d815f88.json","text":"2 Knapsack with Structured Weights: Part 2 Let’s continue with the Knapsack problem we saw in Tutorial 5. A problem instance is a set of n items, numbered 1,...,n. Each item 7 has a positive weight w; > 0 and a positive value v; > 0. Furthermore, we're given an overall weight capacity C. The problem is to select a subset S C {1,...,n} that maximizes the total value of S, but keeps the total weight below C. Formally, we want to maximize V(S) =3 v, €S subject to _,cgw; < C. We're considering the special case of the problem where the capacity as C is 1, and restrict the weights to be either 1/2, 1/4, 1/8, or 1/16. We showed last time that if we sort the 1/16-weight items in decreasing order of value, and then pair up the items in sequence (i.e. the 1st and 2nd items form a pair, then the 3rd and 4th items, then the 5th and 6th, etc.). then there is an optimal solution that uses that uses the ¢ highest-valued pairs, for some c. Now here’s the key idea of our greedy algorithm. Given an instance I of the problem, create a new instance I’ as follows. Initially I’ = I. Sort the 1/16-weight items in decreasing order of value, and pair them up. Now, for each pair of items (i, ;) delete the items from I’ and replace them with a new item whose weight is w; + w; and whose value is v; + v;. Instance I’ has no 1/16-weight items. There’s a natural correspondence between solutions for I and I’, where each ”paired” item in a solution S’ for I is replaced by the two individual items in the corresponding solution S for I, and vice versa. Note also that corresponding solutions S and S’ have the same total value, i.e., V(S) = V(S’) Use this to show that: 1. The value of an optimal solution for instance I is less than or equal to the value of an optimal solution for instance I’. 2. The value of an optimal solution for instance I’ is less than or equal to the value of an optimal solution for instance I. Given an original problem instance, we’ve seen how to eliminate the 1/16-weight items to create an equivalent problem without 1/16-weight instances. 3. How do we now solve the resulting problem instance that has no 1/16-weight items?","libVersion":"0.2.1","langs":"eng"}