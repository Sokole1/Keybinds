{"path":".obsidian/plugins/text-extractor/cache/7a50fe69809520aaa099dee37c63c692.json","text":"CPSC 320 Midterm Examination October 20th, 2020, 19:00 to 20:30 \u0015 You have 75 minutes to write the 4 questions on this examination. A total of 40 marks are available. \u0015 Justify all of your answers. \u0015 You are allowed to access the course web site, Canvas, your notes, the textbook and (only to ask a question if you believe you have found an error on the exam) private posts on Piazza, but not other web sites. You are not allowed to contact people other than the course sta˙. \u0015 Keep your answers short. If you run out of space for a question, you have written too much. \u0015 The number in square brackets to the left of the question number indicates the number of marks allocated for that question. Use these to help you determine how much time you should spend on each question. \u0015 Use the back of the pages for your rough work. \u0015 Good luck! UNIVERSITY REGULATIONS: \u0015 Each candidate should be prepared to produce, upon request, his/her UBC card. \u0015 CAUTION: candidates guilty of any of the following, or similar, dishonest practices shall be immediately dismissed from the examination and shall be liable to disciplinary action. 1. Having at the place of writing, or making use of, any books, papers or memoranda, electronic equipment, or other memory aid or communication devices, other than those authorised by the examiners. 2. Speaking or communicating with other candidates. page 2 out of ?? 1 An hopefully easy beginning a. [4 marks] Express the best-case and worst case running time of the following algorithm as a function of n, where n is the length of a 0-indexed array A. Justify your answers brie˛y. function mystery2(A, n) step ← n/2 // integer division while step > 0 do for i ← 0 to step - 1 do if i + step < n then if A[i] < A[i + step] then swap A[i] and A[i+step] // End of the for loop. step = step / 2 // integer division return A[0] b. [6 marks] Show that in any execution of the Gale-Shapley algorithm, with employers making the job o˙ers, at most one employer may be matched with the applicant it ranked last. Hints: ‹ Look at the ˝rst time in the execution of the algorithm that an employer makes an o˙er to its last ranked applicant. ‹ What do we know about an applicant that has received an o˙er? ‹ The proof is three or four sentences long. page 3 out of ?? 2 A Greedy continuation For this problem, imagine that you are writing the software for a robot that is supposed to ˝ght ˝res in hazardous environments, like a nuclear reactor or chemical plant. We consider the environment to be laid out in a rectangular grid that is w squares wide and h squares high. Your software should make the robot move from square to square until it reaches the square with the ˝re, whereupon the robot releases its ˝re extinguisher. For example (and this is only an example \u0016 your code should work in an arbitrary layout), consider this layout: R F This grid is 7 squares wide and 5 squares high. The very light dotted lines mark the boundaries of the squares. The dark solid black lines are walls, which the robot cannot move through. (The walls also block smoke and chemicals from the ˝re. More on this in a moment.) The orange dashed line shows a path that the robot could take to get to the ˝re: this path entails moving up for 3 squares, then right for 1 square, then down for 3 squares, then right for 4 squares, then up for 2 squares, then left for 1 square, for a total of length of 14 squares ( 14 = 3 + 1 + 3 + 4 + 2 + 1). A better path for the robot would be the dash-dotted green path, which has a total length of only 10 squares, and for this example, that's the shortest path from the robot to the ˝re. To control the robot, the software relies on an API with only these 4 functions: sense() This function makes the robot use its chemical sensors to measure the presence of combustion products coming from the ˝re. It returns a positive real number that gets larger the closer the robot is to the ˝re. Note that \u0010closer\u0011 is de˝ned by the length of the shortest path to the ˝re, without going through walls (since the walls block the combustion products). Other than that, we don't know anything about the numbers returned by the function. For example, for the layout above, this diagrams shows numbers that might be returned by sense() if called in each square: 8.68.3 8.3 8.2 8.0 7.5 7.5 7.4 7.4 7.4 7.0 7.0 7.0 6.5 6.5 6.5 6.0 6.0 6.0 5.0 5.0 5.0 4.0 4.0 4.04.0 3.0 3.0 3.03.0 2.0 2.0 2.0 1.0 0.3 move(direction) This causes the robot to move 1 square in the indicated direction. The legal directions are \u0010up\u0011, \u0010down\u0011, \u0010left\u0011, and \u0010right\u0011. The robot is ˝reproof and can move through the square with the ˝re without harm. However, if the robot tries to move through a wall, it crashes and fails. page 4 out of ?? scan() This function helps you avoid crashing into walls. The function makes the robot use its laser range˝nder to determine which directions the robot can move (for one square) without hitting a wall. It returns a set of legal directions to move. For example, in the ˝gure above, if the robot called sense() in the position marked R, the call would return the set {up , down }. extinguish() This function causes the robot to spray all of its ˝re extinguishing chemicals into the square where it currently is, and then the robot stops executing any further commands. a. [8 marks] Devise an algorithm to direct the robot to the ˝re and then extinguish it, using worst-case O(p) API calls, where p is the length of the shortest path from the robot's initial position to the ˝re. (E.g., in the example above, p = 10. But remember that you are solving this problem in general , not just for the example above!) Write your algorithm in pseudocode that uses the above API; your pseudocode must be detailed enough to use the API directly, e.g., making individual sense() and move() calls, and not having statements like \u0010Call sense() in all adjacent squares\u0011 or \u0010Move right until reaching a wall\u0011. You may assume that there is always a path from any square to the square with the ˝re. Note that excessively complex solutions will be penalized. Write your pseudocode here: (Hint: This problems's title is \u0010Greedy Algorithms\u0011, so you'll want to make a greedy algorithm. But you have to be careful not to be too greedy. How can the robot ˝gure out a good direction to travel without taking too much time?) b. [4 marks] Brie˛y justify why your algorithm correctly ˝nds the ˝re and extinguishes it, and why it makes worst-case O(p) API calls. Your answer doesn't have to be a fully formal proof, but it must be clear and logically correct. page 5 out of ?? 3 Runtime and Measures of Progress The following code is a small function written in Python: def rewrite( str ): while \"10\" in str: str = str.replace(\"10\",\"01\",1) print str return The loop condition checks whether the substring \u001010\u0011 occurs in the string str , and the assignment statement replaces the ˝rst occurence of the substring \u001010\u0011 with the substring \u001001\u0011. For example, if the function is called on: rewrite(\"0101\") it will print the following output: 0011 a. [2 marks] On the time-limited \u0010test\u0011 you wrote a couple weeks ago, there was a very similar-looking problem, where the while loop replaced instances of \u0010Alan\u0011 with \u0010Patrice\u0011. For that problem, a simple progress measure was the number of copies of \u0010Alan\u0011 in the string. For this problem, it might therefore be tempting to try to use the number of copies of \u001010\u0011 in the string as a progress measure. Give an example string for which this attempted progress measure doesn't work correctly, and brie˛y explain why this is not a good progress measure for this while loop. b. [3 marks] De˝ne a progress measure for the while loop that does work, and use it to prove that the loop always terminates. If you wish, you may assume the string str consists of only 0s and 1s (mixed up in any order). (Hint: You might think about progress measures that work for sorting.) page 6 out of ?? c. [3 marks] Let n be the original length of the string str that is passed to the function. Give a tight big- Θ bound on the worst-case number of times that the loop body executes, in terms of n. Brie˛y justify your answer. 4 And a reduction to ˝nish things o˙ In this question, we will revisit reductions to the ISGM problem you encountered in assignment 2. Recall that this problem is de˝ned by: Given an undirected graph G = (V, E) with vertices V and edges E, an integer (positive, zero, or negative) weight hv for each v ∈ V , and an integer (positive, zero, or negative) weight Ju,v for each edge {u, v} ∈ E, ˝nd an assignment of +1 or −1 to the variables xv for each v ∈ V that minimizes the objective function: (∑ v∈V hvxv ) +   ∑ (u,v)∈E Ju,vxuxv   We will consider a reduction from the Vertex Cover problem, de˝ned as follows: Given an undirected graph G = (V, E) with vertices V and edges E, and an integer k, ˝nd a vertex cover of G: a subset V ′ of V with k elements such that every edge in E has at least one endpoint in V ′. Given the graph G, we construct an instance I of ISGM as follows: ‹ Every vertex u of G will be a vertex uI of I with weight 1. ‹ For each edge {u, v} of G, we add the following subgraph to I: h1 = −4 h2 = 2 h3 = 2huI = 1 hvI = 1 h4 = −3 J1,4 = −2 J 1 , 2 = − 4 J 1 , 3 = − 4 J2,3 = 2JuI ,2 = −2 J3,vI = −2 This is essentially the graph used for an OR gate in the assignment, except that we have doubled all of the weights and added an \u0010output\u0011 node (the one on the right on the top row). Recall that the values assigned to the vertices of the triangle will contribute a value of −6 if that triangle behaves like a proper OR gate, and of at least +2 if it does not (this is twice the corresponding values from assignment 2 since we doubled all of the edge weights). page 7 out of ?? a. [5 marks] Based on the ISGM solution, how/when can you conclude that there is a vertex cover of V with at most k vertices? Brie˛y justify your answer. (Once again, your answers should be fairly short). b. [5 marks] If the ISGM solution does indicate that there is a vertex cover of G with at most k vertices, explain how to extract that vertex cover of G from the ISGM solution. Brie˛y justify your answer, speci˝cally why this will be a vertex cover of G with at most k vertices.","libVersion":"0.2.1","langs":""}