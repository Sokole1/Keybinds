{"path":".obsidian/plugins/text-extractor/cache/3db25236e14bb2a25dd785b4e69ab0d1.json","text":"CPSC 320 2018W1, Midterm 2 Sample Solution 1 Greed is good 1. [1.5 marks] Which one(s) of the following algorithms, listed here in alphabetical order, is/are greedy? Circle all that apply. Dijkstra's shortest paths algorithm Gale Shapley's stable matching algorithm Kruskal's minimum spanning tree algorithm The Power algorithm from quiz 4 The Unweighted Interval Scheduling algorithm The Weighted Interval Scheduling algorithm 2. [2 marks] A server has n customers waiting to be served. The service time required by each customer is known in advance: it is ti minutes for customer i. So if, for instance, the customers are served in order of increasing i, then customer number i has to wait ∑i j=1 tj minutes. We wish to minimize the total waiting time T = n∑ i=1(time spent waiting by customer i). Describe succintly an e˚cient algorithm for computing the optimal order in which to process the customers. Solution : Order customers from fastest service time to slowest. 3. [2.5 marks] The following is the outline of a proof of correctness for the correct solution to question 1.2. Please ˝ll in the holes we left in the proof outline with the appropriate information. First, we prove that there is an optimal solution that has the customer with fastest serving time ˝rst Then we use induction and the previous fact to prove that our greedy solution is at at least as good as any optimal solution. 2 Yet another spanning algorithm Let G = (V, E) denote a connected, undirected graph with n ≥ 2 nodes and m weighted edges. Throughout this problem, assume that all edges of E have distinct weights . Let wt( e) denote the weight of edge e of G. The following algorithm appeared on a recent quiz: 1. Algorithm Spanning( G = (V, E), wt()) 2. 3. Let G′ = (V, E′) where E′ = ∅ 4. While G′ is not connected 5. E-new = ∅ 6. For each connected component C of G′ = (V, E′) 7. Find an edge e = (u, v) ∈ E of minimum weight wt( e) that 8. connects a node u in C to a node v that is not in C 9. E-new = E-new ∪{e} 10. E′ = E′ ∪ E-new 11. Return G′ 1. [2 marks] As covered in the quiz, in the worst case, Θ(log n) iterations of the While loop will be executed. Describe an input graph with n nodes on which this worst case behaviour can happen, where furthermore the most costly edge of E is added to E′ in the ˝rst iteration of the While loop. Solution : Worst case behavior happens on a graph that forms a path. To have most costly edge of E added in ˝rst iteration: suppose the highest weight edge is from one of the end nodes of the path to the next node. Since it's the only edge from that component, the algorithm will choose it. 2. [4 marks] Explain why the algorithm always returns a tree on all inputs G = (V, E), given our assumption that all edges of E have di˙erent weights. Solution : Since the algorithm continues until G′ is connected, G′ contains a tree. Suppose to the contrary G′ is not a tree; then it must contain a cycle. Let i be the ˝rst iteration in which a cycle is introduced. Let the components connected by this cycle be C1, C2, . . . , Ck, where we choose this ordering so that Ci chooses an edge to Ci+1 and Ck chooses an edge to C1. Then the edge e1 must have weight greater than the edge e2, since C2 did not choose edge e1. Generalizing, we have that: wt(e1) > wt(e2) > . . . > wt(ek) < wt(e1), a contradiction since wt(e1) cannot be greater than itself. 3 Recursive multiplication recurrence [5 marks] The following algorithm, due to Karatsuba, multiplies two n-bit unsigned integers x = xnxn−1 . . . x1 and y = ynyn−1 . . . y1. For n > 1 the algorithm is based on the following observation. Let xH = xnxn−1 . . . x⌊n/2⌋+1 and xL = x⌊n/2⌋ . . . x1. For example, if x = 11101 then xH = 111 and xL = 01. De˝ne yH and yL similarly, by breaking y in two. Then the product of x and y can be written as xy = xH yH 2n + (xH yL + xLyH )2 n/2 + xLyL (1) = z22 n + z12n/2 + z0, (2) where z0 = xLyL, z1 = xH yL + xLyH , and z2 = xH yH . Furthermore, in equation (2), the multiplications by 2n and 2n/2 can be done using bit-shift operations in Θ(n) time, and also the additions can be done in Θ(n) time. Algorithm Multiply( x = x1x2 . . . xn, y = y1y2 . . . yn) // x and y are unsigned n-bit numbers, where n ≥ 1 If n == 1 then // Base case If (x1 == 1) and (y1 == 1) then Return 1 Else Return 0 Else xH = xnxn−1 . . . x⌊n/2⌋+1 xL = x⌊n/2⌋ . . . x1 yH = ynyn−1 . . . y⌊n/2⌋+1 yL = y⌊n/2⌋ . . . y1 z0 = Multiply (xL, yL) z2 = Multiply (xH , yH ) z1 = Multiply (xL + xH , yL + yH ) − z0 − z2 // This quantity is xH yL + xLyH Return z22n + z12n/2 + z0 // This step can be done in Θ(n) time Let M (n) be the running time of this algorithm on two n-bit integers. Give a recurrence that provides a good upper bound for M (n). You can ignore ˛oors and ceilings. M (n) ≤  ||||||| ||||||| c if n = 1 3M (n/2) + cn if n ≥ 2 4 Recursive running times [8 marks] While trying to come up with questions to ask on a midterm, Anne and Patrice discovered an amazingly novel algorithm to predict whether or not it will snow on the day of the ˝nal exam, based on n days worth of weather data. The time complexity of their algorithm is given by the recurrence relation T (n) = { 2T (n/3) + T (2n/3) + cn2 if n ≥ 2 c if n = 1. Using a method of your choice, prove upper and lower bounds on the function T (n). Your grade will depend partly on the quality of the bound you provide (so, proving that T (n) ∈ Ω(1) and T (n) ∈ O(100n), while true, will not give you many marks). Solution : One approach to obtain a tight upper bound is to draw a recursion tree. The following pictures shows the ˝rst three levels of the tree: the expressions in each node represent the number of items the recursive call receives, the amount of work done at each node is in blue next to the node, and the amount of work done on each row is in red. We see that the amount of work done on row i is c(2/3)in2, and so if we let the number of levels of the recursion go to in˝nity and use the formula for the sum of an in˝nite geometric series, we see that T (n) = ∞∑ i=1 c(2/3) in2 = 3cn 2 is an upper bound on the amount of work done. Alternately, we can use mathematical induction to prove that T (n) ≤ 3cn2. The base case is when n = 1. Then T (1) = c ≤ 3c12, so the claim holds. For the inductive step, suppose that the claim is true for all i, 1 ≤ i ≤ n − 1. We show it is also true for n: T (n) = 2T (n/3) + T (2n/3) + cn2 ≤ 2 ∗ 3c(n/3)2 + 3c(2n/3)2 + cn2 = 6cn2/9 + 12cn2/9 + 9cn2/9 = 27cn2/9 = 3cn2. This completes the upper bound, and so we have that T (n) ∈ O(n2). For the lower bound, we observe from the recurrence that T (n) ≥ cn2 for all n. Therefore we also have that T (n) ∈ Ω(n2), which means that T (n) ∈ Θ(n2). 5 Pell numbers Recall the Pell numbers, de˝ned by the following recurrence relation, and the algorithm Pell( n) which requires exponential time to compute the nth Pell number: Pn =    0, if n = 0, 1, if n = 1, 2Pn−1 + Pn−2, otherwise . Algorithm Pell( n) // Returns the nth Pell number If n = 0 then Return 0 ElseIf n = 1 then Return 1 Else Return 2 * Pell( n − 1) + Pell( n − 2) 1. [3 marks] Use memoization to obtain a more e˚cient recursive algorithm for calculating Pell numbers. Memo-Pell(n): // n is nonnegative Create a new array Soln[0,1,... n] of length n+1 Initialize Soln[0] to: 0 If n >= 1 : Initialize Soln[1] to: 1 If n >= 2 : Initialize each element Soln[i] for 2 <= i <= n to -1 // Here, -1 is a flag indicating that Soln[i] is not yet computed Return PellHelper(n, Soln) PellHelper(n, Soln): If (Soln[n] == -1): // Soln[n] is not yet computed // Recursively compute and store the answer Soln[n] = 2*PellHelper(n-1,Soln) + PellHelper(n-2,Soln) // By this point, Soln[n] is computed Return Soln[n] 2. [1 mark] What is the running time of your Algorithm Memo-Pell from part 1? Check one. Θ(n) Θ(n log n) Θ(n2) Θ(2n) Θ(3n) 3. [3 marks] Rewrite your Memo-Pell algorithm without using recursion. Solution : Memo-Pell(n): // n is nonnegative If n = 0 : Return 0 Else If n = 1 : Return 1 Else Create a new array Soln[0,1,... n] of length n+1 Initialize Soln[0] to 0 Initialize Soln[1] to 1 For i from 2 to n : Soln[i] = 2* Soln[i-1] + Soln[i-2] Return Soln[n] 4. [1 mark] What is the running time of your algorithm from part 3? Check one. Θ(n) Θ(n log n) Θ(n2) Θ(2n) Θ(3n) 5. [2 marks] The previous algorithms use array Soln, which has n + 1 entries and thus uses Θ(n) memory. Brie˛y describe how to obtain an algorithm with the same running time that uses O(1) memory. Solution : To compute Soln[i], only Soln[i-1] and Soln[i-2] are needed, and so entries Soln[j] for j < i need not be stored. Instead, we only need two variables: currentValue and prevValue that will contain the values of Soln[i-1] and Soln[i-2] respectively. Memo-Pell(n): // n is nonnegative If n = 0 : Return 0 Else If n = 1 : Return 1 Else Create a new array Soln[0,1,... n] of length n+1 Initialize prevValue to 0 Initialize currentValue to 1 For i from 2 to n : nextValue = 2* currentValue + prevValue prevValue = currentValue currentValue = nextValue Return currentValue","libVersion":"0.2.1","langs":""}