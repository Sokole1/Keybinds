{"path":".obsidian/plugins/text-extractor/cache/73d47c86ecd715d9f163f2ace9894382.json","text":"CPSC 320: Graph Play Here you’ll gain experience with design and analysis of graph algorithms, starting with graph search algorithms and then moving on to ﬁnding the diameter of a graph. 1 Graph Search Algorithms We use G = (V, E) to denote a graph, where V is a ﬁnite set of nodes and E is a set of edges. Often we use n to denote the number of nodes, and assume that V = {1, 2, . . . , n}. Edges are pairs (u, v) of adjacent nodes. In this worksheet, edges are undirected: there is no implied ordering (“arrow”) from u to v. Usually we assume that u ̸= v, in which case the graph is simple. G may or may not be connected. For this worksheet, all edges are unweighted. A handy data structure for describing the edges of a graph is adjacency lists: there is one list per node, and the list for node u includes exactly those nodes v that are “neighbours” of u, that is, such that (u, v) ∈ E. 1. Illustrate the notation deﬁned above, for a graph with node set V = {1, 2, 3, 4}. Draw a graph using your favourite representation. Write the set of edges E using set notation. Draw an adjacency list representation of the edges. 2. More generally, for any subset A ⊆ V , let N (A) = { neighbours of A} = {v ̸∈ A | v is adjacent to some u ∈ A}. Write down N ({2, 3}) for your graph above. 3. Here’s a graph, derived from the London Underground, where nodes represent stations, edges are be- tween stations that are adjacent stops of a train (trains go in both directions so edges are undirected). The node marked s represents the Picadilly Circus station. Mark the set N (N ({s})). 1 Mystery Deﬁnition 1. Here’s a mystery inductive deﬁnition, pertaining to a connected graph G = (V, E) and a node s of V . L0 ← {s} d ← 1 while L<d ̸= V do ▷ L<d is deﬁned as ∪0≤i<dLi Ld ← N (Ld−1) − L<d d ← d + 1 Trace through the deﬁnition by annotating the following graphs. Mark the nodes in set L1. Mark the nodes in set L<2 using one colour, and those in L2 using another. Mark the nodes in set L<3 using one colour, Mark the nodes in sets L4, L5, and so on, and those in L3 using another. using diﬀerent colours. 4. Can you describe the set Ld in a diﬀerent way, using plain English? 2 5. Prove that your English deﬁnition is equivalent to the inductive deﬁnition above. 3 6. Here is a pseudocode implementation of the mystery deﬁnition, that constructs the sets Ld. procedure Construct-Level-Sets(s) for each v ∈ [1..n] do explored[v] ← false ▷ v is not yet in a level set L0 ← {s}; explored[s] ← true; d ← 1 while L<d ̸= V do Ld ← ∅ for each u ∈ Ld−1 do for each v adjacent to u do if explored[v] == false then add v to Ld; explored[v] ← true d ← d + 1 To establish that this is a correct implementation, each of the following statements attempt to relate the implementation code to the sets Sd. Recall that Sd is the set of nodes of distance d from s. If the statement is not true modify it slightly so that it is true. • At the start of iteration d ≥ 1 of the while loop, for any node v, explored[v] is true if and only if v ∈ Sd. • Within iteration d of the while loop, for any v, the body of the if statement is executed if and only if v ∈ N (Sd−1). • When the algorithm completes, all nodes in V are explored. 4 7. We’ll make one small change to the Construct-Level-Sets algorithm, to record the parent u of each node v once explored[v] becomes true: procedure Construct-Level-Sets′(s) for each v ∈ [1..n] do explored[v] ← false ▷ v is not yet in a level set L0 ← {s}; explored[s] ← true; d ← 1 while L<d ̸= V do Ld ← ∅ for each u ∈ Ld−1 do for each v adjacent to u do if explored[v] == false then add v to Ld; explored[v] ← true p[v] ← u ▷ this is the new line of code! d ← d + 1 8. Let P be the set containing the undirected edges (v, p[v]), for all v ∈ V . • Explain brieﬂy why the graph (V, P ) is connected. • How many edges are in the graph (V, P )? • A beautiful theorem, stated in Tardos and Kleinberg (page 78, (3.2)) is that if G is an undirected graph on n nodes, then any two of the following statements implies the third. (i) G is connected. (ii) G is acyclic, i.e., is a tree. (iii) G has n − 1 edges. Use this theorem, plus the previous two facts to show that (Vs, P ) is a tree. This is the breadth ﬁrst search tree! 5 9. We’ll make one ﬁnal change to our algorithm, so that we compute the shortest path distance ds[v] of each node v from s. A nice side-eﬀect is that we can use this distance array instead of the “explored” array to keep track of explored nodes. Fill in the missing condition of the if statement. procedure BFS(s) for each v ∈ [1..n] do ds[v] ← ∞ L0 ← {s}; ds[s] ← 0; d ← 1 while L<d ̸= V do Ld ← ∅ for each u ∈ Ld−1 do for each v adjacent to u do if then ▷ ﬁll in the missing condition! add v to Ld; ds[v] ← d p[v] ← u d ← d + 1 10. Suppose you want to ﬁnd the route with the fewest stops from Picadilly Circus Station to every other station of the London Underground. How could you do it? 11. Draw the tree BFS(a) for each of the following graphs. Then, for each edge (u, v) that is not in the tree, connect u and v with a dashed edge. 6 12. Here is an algorithm to construct a depth-ﬁrst search tree of G = (V, E), starting from node s. procedure DFS(s) for each i ∈ [1..n] do explored[v] ← false Helper-DFS(s) procedure Helper-DFS(u) explored[u] ← true for each v adjacent to u do if explored[v] is false then p[v] ← u Helper-DFS(v) Draw sample trees that could be produced by DFS(a) for each of the graphs of part 11. Again, for each edge (u, v) that is not in the tree, connect u and v with a dashed edge. 13. More generally (i.e., not just for the examples above), consider the level of a node in the trees bfs(s) or dfs(s) as the distance of the node from s. • Could a bfs tree rooted at s have a dashed edge from node s to a node at level 3? • Could a dfs tree have dashed edges between nodes at the same level of the dfs tree? 7","libVersion":"0.2.1","langs":""}