{"path":".obsidian/plugins/text-extractor/cache/259d4f23132c79ff09c54747a0c73149.json","text":"CPSC 320 2023W1: Assignment 3 This assignment is due on Monday, Oct 30 at 10pm on Gradescope. Please follow the guidelines provided in Assignment 1. Some of the background needed has not been covered quite yet, but will be covered well before the due date. Assignments submitted until noon on Tuesday will be accepted, but a penalty of 15% will be applied. Since the midterm is shortly after the due date for this assignment, we will need to release the solutions on Tuesday, and so there cannot be ˛exibility with these deadlines. 1 List of names of group members (as listed on Canvas) Provide the list here. This is worth 1 mark. Include student numbers as a secondary failsafe if you wish. 2 Statement on collaboration and use of resources To develop good practices in doing homeworks, citing resources and acknowledging input from others, please complete the following. This question is worth 2 marks. 1. All group members have read and followed the guidelines for groupwork on assignments given on the website (see https://www.students.cs.ubc.ca/~cs-320/2021S2/coursework.html , under Assignments). Yes No 2. We used the following resources (list books, online sources, etc. that you consulted): 3. One or more of us consulted with course sta˙ during o˚ce hours. Yes No 4. One or more of us collaborated with other CPSC 320 students; none of us took written notes during our consultations and we took at least a half-hour break afterwards. Yes No If yes, please list their name(s) here: 5. One or more of us collaborated with or consulted others outside of CPSC 320; none of us took written notes during our consultations and we took at least a half-hour break afterwards. Yes No If yes, please list their name(s) here: 1 3 A Spanning Algorithm, Continued Here again is the spanning algorithm from Tutorial 5. Recall that G = (V, E) is a connected, undirected graph with n ≥ 2 nodes and m weighted edges, and w( e) is the weight of edge e of G. procedure Spanning ( G = (V, E), w()) let G′ = (V, E′) where E′ = ∅ ▷ initially there are no edges in the output produced while G′ is not connected do E-new ← ∅ for each connected component C of G′ = (V, E′) do choose any edge e = (u, v) ∈ E of minimum weight w(e) that connects a node u in C to a node v that is not in C E-new ← E-new ∪{e} E′ = E′ ∪ E-new ▷ edges in E-new are added to the output return G′ = (V, E′) 1. (3 marks) Give a big- O bound on the number of iterations of the while loop in the best case. Justify your answer by describing an input graph with n nodes on which this best case behaviour can happen, and explain brie˛y what edge choices would lead to the best case behaviour. 2. (4 marks) Suppose that all edges of E have distinct weights. Explain why the algorithm returns a tree. 3. (3 marks) Suppose again that all edges of E have distinct weights. Explain why the tree returned by the algorithm is a minimum spanning tree. 2 4 Greedy Priorities The UBC Bike Kitchen has a backlog of repair requests. Each of the n requests for bicycle repairs, numbered from 1 to n, has an assigned priority p[i], 1 ≤ i ≤ n, which has positive value. (Details of the priority assignments don't matter, but imagine that volunteers at the Kitchen get higher priority than other students, who get higher priority than non-students, and more.) One hour is allotted to repair each bike, with repairs happening around the clock, one per hour. Given the priorities p[1..n], the sta˙ want to schedule the order in which bikes are repaired until the backlog is cleared, so as to minimize the total \u0010priority-weighted cost\u0011, in terms of hours that the bikes can't be used. If the chosen repair schedule is S = i1, ..., in then this total cost is Cost (S) = n∑ j=1 p[ij] × j. The jth term accounts for the fact that the ijth bicycle, with priority p[ij], remains unrepaired for j hours. If n = 0 then the cost is zero. Example: Suppose that the priorities of three requests are given by p[1] = 3, p[2] = 10, and p[3] = 8, respectively. If the schedule of requests is S = 1, 2, 3 then use of bicycle 1 is delayed for one hour, contributing 3 to the cost; bicycle 2 remains unrepaired for 2 hours, contributing 20 to the cost, and bicycle 3 is not repaired for 3 hours, contributing 24 to the cost. So the total cost is 47 for this schedule. The following Greedy algorithm takes as input an unsorted array p[1..n], of priorities assigned to the repair requests. If n = 0 then no repairs are needed and the algorithm outputs an empty schedule. Otherwise, sort the requests in decreasing order of priority, and output this order as the schedule. (In our example above, the schedule would be 2,3,1, for a total cost of 35.) Here you will work though the steps of an exchange argument to show optimality of the Greedy algorithm\u0016that is, the greedy schedule minimizes the total priority hours wasted. 1. (3 marks) Fix an input p[1..n]. Let S be a solution produced by the Greedy algorithm on this input, and let S∗ be an optimal schedule. Let in and i∗ n be the indexes of the last requests in the schedules S and S∗ respectively. Let j be such that in is the jth request in schedule S∗, that is, in = i∗ j . Finally, let S′ be the schedule obtained by swapping the positions of in and i∗ n in schedule S∗. Explain why Cost (S′) − Cost (S∗) = p[in] × (n − j) − p[i ∗ n] × (n − j). 2. (2 marks) Show that Cost (S′) ≤ Cost (S∗). 3. (4 marks) Show that the Greedy algorithm is correct. You could use induction, building on the previous parts of this problem. 3 5 Max-Min Categorization Suppose that we change the goal of the photo categorization problem in the clustering worksheet to maximize the minimum intra-cluster edge similarity . We call this a Max-Min categorization. (In contrast, the goal in the worksheet was to minimize the maximum inter-category edge similarity.) For the 4-node example from the worksheet, shown below, the minimum intra-cluster edge similarity of cluster {1, 3, 4} is .3, and the minimum intra-cluster edge similarity of cluster {1, 4} is .6. Also, we'll de˝ne the intra-cluster edge similarity of any set of size 1 to be 1. 1. (1 mark) For the above example, with c = 2, list one optimal Max-Min categorization. 2. (1 mark) Here is a greedy algorithm that produces a categorization: function New-Clustering-Algorithm ( n, E, c) ▷ n ≥ 1 is the number of photos ▷ E is a set of edges of the form (p, p′, s), where s is the similarity of p and p′ ▷ c is the number of categories, 1 ≤ c ≤ n create a list of the edges of E, in increasing order by similarity let C be the categorization with all photos in one category Num- C ← 1 ▷ initial number of categories while Num- C < c do remove the lowest-similarity edge (p, p′, s) from the list if p and p′ are in the same category, say S, of C then ▷ split S into two new categories T and T ′ as follows: put p in T put p′ in T ′ for each remaining p′′ in S do let s(p, p′′) be the similarity of p and p′′ let s(p′, p′′) be the similarity of p′ and p′′ put p′′ in T if p′′ is more similar to p than p′, i.e., if s(p, p′′) > s(p′, p′) put p′′ in T ′ otherwise ▷ now S is replaced by T and T ′ in C Num- C ← Num- C + 1 return C What categorization does New-Clustering-Algorithm produce on the 4-node example given at the start of this question? (No justi˝cation needed.) 3. (2 marks) Let (n, E, c) be an input where all edges have distinct similarities, and c ≥ 2. Suppose that (p, p′, s) is the edge removed in the ˝rst iteration of the while loop of New-Clustering- Algorithm . Explain why in an optimal Max-Min categorization, p and p′ must be in distinct categories. 4. (2 marks) Let E′ be the set of all edges removed from the list, over all iterations of the while loop of New-Clustering-Algorithm , and let CG be the categorization returned by the algorithm. Must all edges of E′ must be inter-category edges of CG? Justify your answer. 4 5. (2 marks) Modify the 4-node example by choosing one edge from the list below, and then choosing a new similarity from the second list below for that edge, so that New-Clustering- Algorithm is incorrect on the resulting modi˝ed instance. That is, on the modi˝ed instance, New-Clustering-Algorithm produces a solution that does not maximize the minimum intra- cluster edge similarity. Choose one edge: (1, 2) (2, 3) (3, 4) Choose the new edge similarity: .5 .8 5 6 Sort-of Quicker Sort Recurrence When sorting data in real life, there's often a bound on the range of values to be sorted. For example, UBC student ID numbers are integers between 0 and 99999999. We can use this fact to design sorting algorithms that sometimes work faster than the usual ones we have studied. The input is an array A[1..n] of integer numbers, plus two integers low and high such that all numbers in A are in the range [low...high] where low ≤ high. Here is a recursive sorting algorithm: ‹ In the base cases, A has size at most 1 or low = high, and the algorithm returns A. ‹ Otherwise the algorithm works as follows: Calculate the integer at the middle of the possible value range (rounding up if needed, e.g., 50000000 for UBC Student IDs). Call this value the pivot. Then, partition the array, putting all the values lower than the pivot into one array, called Lesser, with range [low..pivot-1], and all the values at least as large as the pivot into another array, called Greater, with range [pivot..high]. Recursively sort the arrays Lesser and Greater, and then concatenate them together. In what follows, we'll let m = high − low +1 be the size of the range [low, high], and assume throughout that n ≥ 0 and that m ≥ 1. 1. (2 marks) This part of the question considers a worst-case scenario. Let T (n, m) be the runtime of the algorithm as a function of n and m, when the items in A always get put entirely in Lesser, with no items going into Greater. (This could happen, e.g., if all the numbers being sorted are 0, in which case the size of the range keeps halving until the base case \"low = high\" is reached.) Write a recurrence relation for T (n, m). You can ignore ˛oors and ceilings and do not need to solve the recurrence. 2. (4 marks) Let T ′(n, m) be the runtime of the algorithm when the sizes of the two lists resulting from the partition always happen to be n/3 and 2n/3. Here is the recurrence relation for T ′(n, m) (ignoring ˛oors and ceilings): T ′(n, m) = { c, if n ≤ 1 or m = 1, T ′(n/3, m/2) + T ′(2n/3, m/2) + cn, if n > 1 and m > 1. Solve this recurrence relation to show that T ′(n, m) = Θ(n min(log m, log n)). 3. (2 marks) If we consider m to be a constant (e.g., for UBC Student IDs, m = 1000000000), then what would be the big- Θ bound for the quantity T ′(n, m) of part 2? 6","libVersion":"0.2.1","langs":""}