{"path":".obsidian/plugins/text-extractor/cache/3d35e7557c2115d918afb2b94e1802ac.json","text":"CPSC 320: Memoization and Dynamic Programming I ∗ You want to make change in the world, but to get started, you’re just . . . making change. You have an unlimited supply of quarters (25 cents), dimes (10 cents), nickels (5 cents), and pennies (1 cent, once upon a time). You want to make change for n ≥ 0 cents using the minimum number of coins. 1 Build intuition through examples. 1. Here is an optimal greedy algorithm to make change. Try it on at least one instance. function Greedy-Change(n) while n > 0 do if n ≥ 25 then give a quarter and reduce n by 25 else if n ≥ 10 then give a dime and reduce n by 10 else if n ≥ 5 then give a nickel and reduce n by 5 else give a penny and reduce n by 1 2. A few years back, the Canadian government eliminated the penny. Imagine the Canadian government accidentally eliminated the nickel rather than the penny. That is, assume you have an unlimited supply of quarters, dimes, and pennies, but no nickels. Adapt algorithm Greedy-Change for the case where the nickel is eliminated, by changing the code above. Then see if you can ﬁnd a counterexample to its correctness. ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1 2 Write down a formal problem speciﬁcation. We’ll assume that a currency which includes the penny is ﬁxed, with coins of value 1, v1, . . . vk for some k ≥ 1. We’ll work with the currency 1, 10, 25 in what follows, but want an algorithm that can easily be adapted to work more generally. What is an instance of the making change problem? This is an example of a minimization problem; what quantity are we trying to minimize? 3 Evaluate brute force. As is often the case, this approach will lead us to even better approaches later on. It will be helpful to write our brute force algorithm recursively. We’ll build up to that in several steps. 1. To make the change, you must start by handing the customer some coin. What are your options? 2. Imagine that in order to make n = 81 cents of change using the minimum number of coins, you can start by handing the customer a quarter. Clearly describe the subproblem you are left with (but don’t solve it). You can use the notation above in the formal problem speciﬁcation. 3. Even if we’re not sure that a quarter is an optimal move, we can still get an upper bound on the number of coins by considering the subproblem we are left with when we start with a quarter. What upper bound do we get on C(81)? 4. What other upper bounds on C(81) do we get if we consider each of the other \"ﬁrst coin\" options (besides a quarter), and the corresponding subproblem? 5. There are three choices of coin to give ﬁrst. Can you express C(81) as the minimum of three options? 2 6. Now, consider the more general problem of making change when there are k + 1 diﬀerent coins available, with one being a penny, and the remaining k coins having values v1, v2, . . . , vk, all of which are greater than 1. Let C′(n) be the minimum number of coins needed in this case. For suﬃciently large n, how can you express C′(n) in terms of C′() evaluated on amounts smaller than n? 7. Complete the following recursive brute force algorithm for making change: function Brute-Force-Change(n) if n < 0 then return if n = 0 then return if n > 0 then return the minimum of: , , and 8. Complete the following recurrence for the runtime of algorithm Brute-Force-Change: T (n) = for n < 0 T (n) = otherwise. 3 9. Give a disappointing Ω-bound on the runtime of Brute-Force-Change by following these steps: (a) T (n) is hard to deal with because the three recursive terms in part (??) above are diﬀerent. To lower bound T (n), we make them all equal to the smallest term. Complete the lower bound that we get for the recursive case when we do this: For the recursive case, T (n) ≥ . (b) Now, draw a recurrence tree for the recurrence of part ?? and ﬁgure out its number of levels, work per level, and total work. 4 10. Why is the performance so bad? Does this algorithm waste time trying to solve the same subproblem more than once? For n = 81, draw the ﬁrst three levels (the root at level 0 plus two more levels) of the recursion tree for Brute-Force-Change to assess this. Label each node by the size of its subproblem. Does any subproblem appear more than once? 5","libVersion":"0.2.1","langs":""}