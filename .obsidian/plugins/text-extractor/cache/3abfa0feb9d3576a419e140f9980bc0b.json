{"path":".obsidian/plugins/text-extractor/cache/3abfa0feb9d3576a419e140f9980bc0b.json","text":"7 The Problem, InAWord [15 marks]| Given a string of letters, you want to determine whether thereâ€™s a way to insert spaces so that the string becomes a sequence of valid English words. For example, the string mysunflower works because putting a space after letter 2 produces my sunflower, or putting spaces after letters 2 and 5 produces my sun flower. The string abcdef does not work. Assume you have a helper function isWord(str) that runs in constant time and returns True if str is an English word, and False otherwise. 1. A friend proposes this greedy approach: Starting at the beginning of the string, add one new character at a time, and check if the characters form a word. As soon as you find a word, put a space there, and recursively call the same algorithm on the rest of the string. Here is pseudocode: function canSplit(str): for i = 1 to length(str)-1 if isWord(str[1 .. i]) // are the first i letters a word? return canSplit(str[i+l .. length(str)]) // At end of loop: no prefix is a word; so, we return // True if and only if the entire string is a word. return isWord(str) (a) Assume that isWord returns True for the strings a, at, ate, tea, cup, and teacup, and False for all other strings. In that case, the greedy algorithm returns True for the input string ateacup. How does it split ateacup as it runs? Circle the best answer. [1 mark] i. a teacup ii. a tea cup iii. ate a cup iv. The function finds a different splitting. (b) Complete the following to supply a counterexample that proves this greedy approach is not correct. Note: this counterexample uses made-up words rather than English ones. [2 marks| List of ALL strings that should be considered words: a, aa, bb, bbb. Counterexample instance: Correct solution to this instance (including an actual split, if the answer is True): Greedy solution to this instance (including an actual split, if the answer is True):","libVersion":"0.2.1","langs":"eng"}