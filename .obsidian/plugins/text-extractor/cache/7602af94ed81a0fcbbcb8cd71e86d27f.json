{"path":".obsidian/plugins/text-extractor/cache/7602af94ed81a0fcbbcb8cd71e86d27f.json","text":"Test ing CP S C 310 Nick B radley & K athar ine K er r F or per s onal us e only , pleas e do not dis tr ibute on non-UB C domains . CP S C 310: Introduction to S oftware E ngineer ing C1, Q 0, & Lab s ● C1 is in full s wing. ○ A ll for med groups s hould hav e <project_team###> repos itor ies . ○ If y ou do not hav e one, talk to y our TA r ight away ! ● Q0 is r unning ne x t week in the CB TF. ○ If y ou hav en’t s igned up for a s lot y et, pleas e do s o. ● Labs : ○ P leas e remember that lab attendance is mandator y. CP S C 310: Introduction to S oftware E ngineer ing Q uiz over view • Content will be ev er y thing up to the end of the pr ior week. • Quiz z es are cumulativ e. • No notes / electronics . • Y ou are e x pected to tak e all quiz z es . • Quiz z es mus t be tak en dur ing the quiz per iod (no late quiz z es ). CP S C 310: Introduction to S oftware E ngineer ing Q uiz mechanics • 50 minute s lot, des igned to tak e < 30 minutes . • Quiz z es ~90-100% Tr ue/F als e. Final 100% Tr ue/F als e • 1 Mar k for ev er y cor rect ans wer. • 0 Mar ks for ev er y blank ans wer. • -0.5 Mar ks for ev er y wrong ans wer (gues s penalty ). • Grades will be pos ted on Clas s y once the quiz per iod is ov er. CP S C 310: Introduction to S oftware E ngineer ing Q uiz p ract ice / view ing • There will be a s hor t practice quiz av ailable on P rair ieL ear n. • This is _NO T_ meant to be comprehens iv e. • Mainly there s o y ou can get a feel for ques tion for mat. • Quiz v iewing s es s ion in the CB TF the following week. • S ame as tes t protocol: no notes , no dev ices . • V iewings after ev er y quiz (and at leas t one before ﬁ nal e x am). CP S C 310: Introduction to S oftware E ngineer ing A fter q uiz st ar t s: No P iaz z a • Once the quiz begins (W ednes day Mor ning) - P leas e no quiz ques tions on P iaz z a. → S tudy ear ly ! • Ins tead, go to oﬃce hour s . CP S C 310: Introduction to S oftware E ngineer ing Q uiz samp le q uest ion CP S C 310: Introduction to S oftware E ngineer ing Q uiz samp le q uest ion CP S C 310: Introduction to S oftware E ngineer ing Q uiz samp le q uest ion CP S C 310: Introduction to S oftware E ngineer ing Q uiz samp le q uest ion CP S C 310: Introduction to S oftware E ngineer ing L ect ure L earning O ut comes B y the end of this lecture, y ou will be able to ans wer : ● What are tes t as s er tions and how can we us e them eﬀ ectiv ely ? ● What are the pr inciples of tes tability ? What des ign choices can we mak e to uphold each pr inciple? ● What are ethics in s oftware engineer ing? ● How does ethics apply to tes ting? L ect ure L earning O ut comes T estin g A s s er tions CP S C 310: Introduction to S oftware E ngineer ing F rom e x ecut ion to valid ated b ehavior ● Jus t becaus e y ou can e x ecute a CUT, does not mean y ou can ev aluate the cor rectnes s of its behav ior. ○ The only e x ception is cras hing bugs . ● A s s er tions br idge this gap. ○ W e as s er t on the behav ior of the e x ecution. ○ W ant to cons ider both v alid and inv alid behav ior s . ■ as s er t(V alid): good thing happened. ■ as s er t(!Inv alid): bad thing did not happen. ● Two common s trategies for s tr uctur ing tes ts : ○ F our phas e tes t (e.g., JUnit). ○ Giv en-when-then (e.g., ChaiJS ). CP S C 310: Introduction to S oftware E ngineer ing F our p hase test ( from 210) 1. S et up the tes t env ironment. 2. E x ecute code under tes t. 3. E v aluate the behav ior of the CUT. 4. Tear down and clean up the tes t env ironment. CP S C 310: Introduction to S oftware E ngineer ing G iven-w hen-t hen ● Motiv ation: tes ting code is hard to read/reas on about. ● Goal: “E x ecutable s peciﬁ cations ” (B ehav iour Dr iv en Dev elopment). ○ Tes ts s hould embed human readable s peciﬁ cations . ○ S y s tem’s giv en s tate at s tar t of tes t s hould be clear. ○ Us e plain language to s tr ucture tes ting procedure. ● B eneﬁ ts : ○ E x pres s iv e tes t name helps when tes t fails . ○ S imple s entences k eeps tes t methods focus ed. CP S C 310: Introduction to S oftware E ngineer ing G iven-w hen-t hen ● Motiv ation: tes ting code is hard to read/reas on about. ● Goal: “E x ecutable s peciﬁ cations ” (B DD). ● Chai e x ample: describe('Math constants', function() { describe('PI', function() { it('should be close enough to the correct value',()=>{ expect(Math.PI).to.be.closeTo(3.14, 0.025); }); }); }); equalityequality ty pe s et member s hip k ey e x is tence (+ any , + all) abov e, below , near contains throws S t r engt h of asser t ion expect(actual).to.be.defined; expect(actual).to.equal(expected); expect(actual).to.be.an(‘object’); const query = {} const expected = {} const actual = performQuery(query); S t r engt h of asser t ion expect(actual).to.be.defined; expect(actual).to.equal(expected); const query = {} const expected = {} const actual = performQuery(query); expect(actual).to.be.an(‘array’); expect(actual).to.be.defined; W eaker = mo re b ro ad expect(actual).to.equal(expected); S tro n g er = mo re n arro w expect(actual).to.be.an(‘array’); const query = {} const expected = {} const actual = performQuery(query); S t r engt h of asser t ion expect(actual).to.be.defined; W eaker = mo re b ro ad expect(actual).to.equal(expected); S tro n g er = mo re n arro w A utomated b lack b o x test s ( e.g., fuz z ing) , t yp ically have w eak er asser t ions expect(actual).to.be.an(‘array’); const query = {} const expected = {} const actual = performQuery(query); S t r engt h of asser t ion expect(actual).to.be.defined; W eaker expect(actual).to.equal(expected); S tronger expect(actual).to.be.an(‘array’); • A s s er tions that are s tronger, us ually clos ely follow the s pec. • W eak er as s er tions are s till us eful to help with debugging. • E .g., actual not equal to e x pected… but why ? Not an ar ray ! S t r engt h of asser t ion Tes tability CP S C 310: Introduction to S oftware E ngineer ing ● O b ser vab ility ○ The e x tent to which the res pons e of the CUT to a tes t can be v er iﬁ ed. ● Co n tr o llab ility ○ The e x tent to which the CUT can be made to per for m s peciﬁ c actions of interes t. ● Au t o m atab ility ○ The ability to e x ecute the tes t programmatically. ● I so lat eab ility ○ The degree to which the element under tes t can be v alidated on its own. P rincip les of test ab ilit y Tests Code under test T estab ility fo cu s B lack/glass box strategies CP S C 310: Introduction to S oftware E ngineer ing O b ser vab ilit y What do we hav e to do to id en tify pas s /fail? How e xp en sive is it to do this ? C an we e xtr act the res ult from the S UT (s y s tem under tes t)? Do we kn o w en o u g h t o id en tify pas s /fail? …s oftwar e is eas ier to tes t if the inputs produce dis tinct, pr edictable outputs . F ur ther, it can be helpful to be able to e x amine the s oftwar e' s inter nal s tate, es pecially wher e ther e may be no pr edictable outputs , and es pecially when an er ror has been dis cov er ed. [https ://w w w .cs .uct.ac.z a/mit_notes /s oftware/htmls /ch09s 04.html (Univ er s ity of C ape Town)] E xp osing b ehaviour/st ate for insp ect ion export class Animal { private hungry: boolean = true; private eaten: number = 0; //REQUIRES: Animal to be hungry //EFFECTS: At the end of the method: // The animal has eaten more food than it had eaten, // and the animal is not hungry. public eat(): number { this.hungry = false; this.eaten++; return this.eaten; } } describe(\"Animal\", () => { it(\"should not be hungry and have eaten more food after eating\",() =>{ //Given //When //Then }); }); I t ’ s easier to t hink of it as a b lack b o x ﬁrst ! //EFFECTS: For a hungry animal only: // At the end of the method: // The animal has eaten more food, // and the animal is not hungry. const a = new Animal(); expect(a.isHungry()).to.be.true; expect(a.amountEaten()).to.equal(0); a.eat(); expect(a.isHungry()).to.be.false; expect(a.amountEaten()).to.be.greaterThan(0); Need to add an is Hungr y and amount t E aten to t he public inter face of t he clas s CP S C 310: Introduction to S oftware E ngineer ing Cont rollab ilit y C an we control the S UT dur ing a tes t? How e x pens iv e is it? Does the s y s tem mak e r unning a tes t imp ract ical? Giv en a tes t goal, do we hav e enough informat ion to create an adequate s uite? How much tooling can we aﬀ ord? “The mor e eas ily we can prov ide inputs to the s oftwar e, the mor e eas ily we can tes t the s oftwar e. This implies that s oftwar e is mor e tes table when the tes ter has the ability to eas ily control the s oftwar e in order to prov ide the tes t inputs . ” [ https://www .cs.uct.ac.za/mit_notes/software/htmls/ch09s04.html] export class CrazyEights { init() { const deck = [\"A-H\", \"2-H\", \"3-H\", ...]; for (let i = 0; i < deck.length ;i++) { const newPosition = i + (Math.random() % (52 - i)); const temp = deck[i]; deck[i] = deck[newPosition]; deck[newPosition] = deck[i]; } const player1 = deck.slice(0,13); const player2 = deck.slice(13,26); const player3 = deck.slice(26,39); const player4 = deck.slice(39,52); const table = []; table.push(player1[0]); … } } Do y ou hav e the r ight entr y points (methods that are public enough, eas y enough to inv ok e with v alid inputs ) to be able to control the s y s tem to tes t it? export class CrazyEights { init() { const deck = [\"A-H\", \"2-H\", \"3-H\", ...]; for (let i = 0; i < deck.length ;i++) { const newPosition = i + (Math.random() % (52 - i)); const temp = deck[i]; deck[i] = deck[newPosition]; deck[newPosition] = deck[i]; } const player1 = deck.slice(0,13); const player2 = deck.slice(13,26); const player3 = deck.slice(26,39); const player4 = deck.slice(39,52); const table = []; table.push(player1[0]); … } } Creates a C ard Deck S huﬄes the Deck Deals the C ards P lay C ards export class CrazyEights { init() { const deck = [\"A-H\", \"2-H\", \"3-H\", ...]; for (let i = 0; i < deck.length ;i++) { const newPosition = i + (Math.random() % (52 - i)); const temp = deck[i]; deck[i] = deck[newPosition]; deck[newPosition] = deck[i]; } const player1 = deck.slice(0,13); const player2 = deck.slice(13,26); const player3 = deck.slice(26,39); const player4 = deck.slice(39,52); const table = []; table.push(player1[0]); … } } Creates a C ard Deck S huﬄes the Deck Deals the C ards P lay C ards How do we tes t that the deck has been s huﬄed? export class CrazyEights { init() { const deck = [\"A-H\", \"2-H\", \"3-H\", ...]; for (let i = 0; i < deck.length ;i++) { const newPosition = i + (Math.random() % (52 - i)); const temp = deck[i]; deck[i] = deck[newPosition]; deck[newPosition] = deck[i]; } const player1 = deck.slice(0,13); const player2 = deck.slice(13,26); const player3 = deck.slice(26,39); const player4 = deck.slice(39,52); const table = []; table.push(player1[0]); … } } init() { const deck = this.getDeck(); this.shuffle(deck); const players = this.deal(deck); this.play(players); } R efactor ing! (later in cour s e) CP S C 310: Introduction to S oftware E ngineer ing A utomat ab ilit y C an tes ts be e x ecuted without human inter v ention? What is the cos t of automated infras tr ucture? What is the beneﬁ t of us ing a tes t infras tr ucture? ○ E x ecutions can be batched. ○ R un on s ame conﬁ guration / hardware. ○ Global v is ibility of res ults . ○ E nables regres s ion tes ting and integration tes ting! Huge economic adv antages : ○ S etting up automation: 5 hour s . R unning manual tes t: 30 minutes . ○ A utomation pay s for its elf after jus t 10 iterations . CP S C 310: Introduction to S oftware E ngineer ing Test ing challenges ( related to automat ab ilit y) ● Tes ts are code too. ○ A ls o s ubject to their own faults . ● Not all tes t failures uncov er faults : ○ Defect in tes t its elf. ○ Flaky tes t (due to s ome for m of non-deter minis m). ○ R equirements s hor tcoming (undeﬁ ned behav iour ). ■ Implicit as s umptions often s ur faced by tes ts . ● How to retros pectiv ely recogniz e a ‘tr ue’ failure? ○ Dev eloper changed the s ource (not tes t), tes t pas s ed on the ne x t iteration (bug inducing changes ). CP S C 310: Introduction to S oftware E ngineer ing Trend y A rchitect ural choices for automat ab ilit y This is s omething y ou would hav e encounter ed in 210! UI Layer -- thin -- very little logic held here E verything else (regardless of architectural choices) A ll logic resides here UI mak es calls down to the Model or howev er y ou’re ar ranging it Thes e methods can als o be called from within unit tes ts , meaning y ou don’t need to automate the UI lay er dir ectly to tes t all functionality Test layer CP S C 310: Introduction to S oftware E ngineer ing I solateab ilit y C an the component being tes ted be is olated? Is olated components are: ● S impler to reas on about (e.g., root caus e analy s is ). ● L es s prone to non-deter minis m. ● F as ter. What is the cos t to do this ? If an element cannot be naturally is olated, can we s imulate it? ● S imulated dependencies can als o enable v alidating unus ual s tates . CP S C 310: Introduction to S oftware E ngineer ing I solateab ilit y A nother way to think about this is b ein g ab le t o iso lat e w h er e a fau lt o ccu rr ed , o r w h er e a t est failed. How often hav e y ou had to “track down the s ource” of a failing tes t -- putting “got here” all ov er the place. That means y our tes t did not nicely is olate the caus e of the failure. A ﬁ ner grained tes t s uite, or a more ins tr umented codebas e, would help y ou is olate bugs fas ter. A ls o choos ing the r ight granular ity of methods and then tes ting them indiv idually is k ey to being able to is olate er ror s . CP S C 310: Introduction to S oftware E ngineer ing Mocking d ep end encies Often we rely on por tions of the s y s tem which are... ● Non-deter minis tic ● S low ● Us er-dr iv en ● Not y et built Mocks adhere to the contract (inter face) but s imulate behav ior. R eal implementation is s ubs tituted in production. ( help s w it h and req uires isolat ab ilit y) CP S C 310: Introduction to S oftware E ngineer ing S copeSpeed K ind s of test s b y scop e Us es Mocks for Is olation No Mocks ! Mock ob ject e xamp le W e are tr y ing to tes t this 1 This is per haps …. S low; Not y et built; Unreliable; R andom 2 S o we mak e this ins tead. B ut it needs to prov ide precis ely the s ame inter face as the real S er v er, and mus t per fectly confor m to the S er v er Inter face. 3 This is all we s hould hav e to change in the client 4 Things to think about: ● How to s et up the hierarchy ● How to declare ● How to ins tantiate ● What to implement Mocking help s w it h root cause analysis Client implementation Client tests S erver implementation S erver tests Mocking help s w it h root cause analysis Client implementation Client tests S erver implementation S erver tests F ail F ail …where is the root cause of the bug? Mocking help s w it h root cause analysis Client implementation S erver mock Client mock S erver implementation Client tests S erver tests Client implementation Client tests S erver implementation S erver tests F ail F ail Mocking help s w it h root cause analysis Client implementation S erver mock Client mock S erver implementation Client tests S erver tests Client implementation Client tests S erver implementation S erver tests F ail F ail F ail P ass Ro o t cau se h ere CP S C 310: Introduction to S oftware E ngineer ing E t hics in S oft w are E ngineering P rov ide a moral compas s to guide profes s ional dev eloper s . • P roject des ign: identify and communicate beneﬁ t/impact. • Tes ting: ens ure accuracy , s ecur ity , and fair nes s . • Maintenance: addres s v ulnerabilities and ongoing confor mance. P rofes s ional E thics (A CM, IE E E ): • Codiﬁ es s tandards and v alues for s oftware engineer s . • Obligations that mus t be upheld to improv e people’s liv es . CP S C 310: Introduction to S oftware E ngineer ing A CM Cod e of E t hics CP S C 310: Introduction to S oftware E ngineer ing A CM Cod e of E t hics CP S C 310: Introduction to S oftware E ngineer ing A CM Cod e of E t hics CP S C 310: Introduction to S oftware E ngineer ing A CM Cod e of E t hics CP S C 310: Introduction to S oftware E ngineer ing E t hics in test ing ● S oftware is a k ey par t of many as pects of s ociety. ● P oor ly v alidated s oftware can clear ly caus e direct har m. ○ To health and s afety : E .g., Medical dev ices , car cras hes , etc. ○ To ﬁ nancial wellbeing: E .g., S tock mar k et cras hes , bank er ror s . ○ To cus tomer s : E .g., s elling product that does not wor k. ● S oftware v alidation can als o caus e unanticipated har m. ○ S y s tematic tes ting proces s es are fundamental to mitigating this r is k. ○ Thes e unanticipated har ms are often ethical v iolations . ● Dur ing tes ting, we cons ider not jus t whether : ○ A behav iour is cor rect. ○ B ut als o if the ‘cor rect’ behav iour is ‘r ight’ (ethically s ound). CP S C 310: Introduction to S oftware E ngineer ing F ace detection Y ou r un an app that people mos tly interact with on their mobile dev ices . To max imiz e s creen s pace yo u d ecid e yo u w an t t o au t o m atically cr o p an y u ser -u p lo ad ed im ag es t o th eir m o st im p o r tan t p ar t to tr y to encourage us er s to click the photo to s ee the full v er s ion. The main intuition behind the feature is that if there’s a face in the image, y ou s hould highlight the face. Y our team is coordinating a back end team that manages the algor ithm, a frontend team that is building for the web, and the mobile client team. While deﬁ ning the deﬁ nitions -of-done for this feature, what equiv alence clas s es s hould y ou cons ider ? ethics vig nette 1 CP S C 310: Introduction to S oftware E ngineer ing ethics vig nette 1: F ace d etect ion @ Tw it ter CP S C 310: Introduction to S oftware E ngineer ing I nput #1 I nput #2 ethics vig nette 1: F ace d etect ion @ Tw it ter CP S C 310: Introduction to S oftware E ngineer ing Twitter has a large number of us er s and collects v as t analy tics about how thos e us er s interact with the s er v ice. S tev e was the lead for the mobile logs infras tr ucture. He was as k ed to e x tend logs s o the data could be s ellable, including details of all of the places indiv idual us er s opened the app, etc. This would be v aluable becaus e y ou could not only track y our bus ines s , but how much people were v is iting y our competitor s . A) B uild the feature. B) R efus e to build the feature. ethics vig nette 2: Tw it ter A nalyt ics Dat a","libVersion":"0.2.1","langs":""}