{"path":".obsidian/plugins/text-extractor/cache/ecfb5ddb1723bbad2d3767b8e0944851.json","text":"2 Interpreters and Graphs Several modern programming languages, including JavaScript, Python, Perl, and Ruby, include a feature called parallel assignment, which allows multiple assignment operations to be encoded in a single line of code. For example, the Python code x,y = 0,1 simultaneously sets « to 0 and y to 1. The values of the right-hand side of the assignment are all determined by the old values of the variables. Thus, the Python code a,b = b,a swaps the values of @ and b, and the following Python code computes the nth Fibonacci number: def fib(n): prev, curr = 1, 0 while n > 0: prev, curr, n = curr, prev+curr, n—1 return curr Suppose the interpreter you are writing needs to convert every parallel assignment into an equivalent sequence of individual assignments. For example, the parallel assignment a,b = 0,1 can be serialized in either order — either a=0; b=1 or b=1;a=0 — but the parallel assignment x,y = x+1,x+y can only be serialized as y=x+y; x=x+1. Serialization may require one (or even more) additional temporary variables. For example, serializing a,b = b,a requires a temporary variable. Your task is to design an algorithm to determine whether a given parallel assignment can be serialized without additional temporary variables. To formalize this, say there are n parallel assignments. The i*\" assignment is of the form “v; + R;”, where v; is a single variable and R; is an expression involving many variables. For simplicity, you may assume the following: e Each variable can only appear on the left-hand side of one assignment. e Computing a right-hand side R; doesn’t have any “side effects”. That is, computing R; does not involve functions that modify variables.","libVersion":"0.2.1","langs":"eng"}