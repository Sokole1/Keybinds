{"path":".obsidian/plugins/text-extractor/cache/bbd0df0fd8854331a48c9b5b3ec91b29.json","text":"4. There a more efficient way to find a node v ¢ T with the shortest path to s, i.e., the node v that minimizes minyer d[u] + w(u,v). The idea is to maintain distances d[v] for all v € V, representing the best way to attach v to the tree T’ constructed so far. Initially d[v] = oo for all v, except for node s. Each time we add a node v to the tree, we update d[z] for all z adjacent to v, where z is not yet in T'. A priority queue data structure is good for this purpose, see Chapter 2 of the text. A priority queue @ contains a set of n items, where each item v has an associated numerical key. For our purposes, the items will be nodes and key for node v will be the quantity d[v]. Operations on the queue include: o CREATE(Q,n,d): Creates a priority queue with n items numbered 1 to n, which all have the same key d = d[v]. The runtime cost is O(n). o EXTRACTMIN(Q): Returns the item with the lowest-valued key, and removes this item from Q. The cost is O(logn). o CHANGEKEY (Q,v,d'): Changes the key of item v in queue @ to d’. The cost is O(logn). Flesh out the missing details in the code below, using the priority queue operations. procedure WSP-GREEDY-DIJKSTRA(s) > create a priority queue whose keys are the initial values of d[v] for each v € V' T+ 0 while T'# V do > find a node v ¢ T with minimum d[v] addvto T for all neighbours z of v do if z ¢ T then > update the key for z to be min{d[z],d[v] + w(v,z)}) 5. What is the runtime of this implementation of Dijkstra’s algorithm?","libVersion":"0.2.1","langs":"eng"}