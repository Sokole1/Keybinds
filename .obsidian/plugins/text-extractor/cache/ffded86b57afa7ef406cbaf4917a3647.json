{"path":".obsidian/plugins/text-extractor/cache/ffded86b57afa7ef406cbaf4917a3647.json","text":"Directory entry constraints Consider a file system that uses the following structure for its dirents. typedef uint32_t ino_t; struct dirent { ino_t d_ino; __uintl6_t d_reclen; __uint8_t d_type; __uint8_t d_namlen; char d_name[255+1]; IH #define DT_DIR 4 #define DT_REG 8 #define DT_LNK 10 Determine which of the following statements are true. Assume that: ¢ filenames cannot contain nul characters (‘\\2' or equivalently 2) ¢ filenames are not necessarily nul-terminated ¢ any padding bytes in the record are set to zero ¢ adirectory block contains 4096 bytes For the storage scheme using this dirent structure to work and align properly, d_reclen must be exactly equal to the ceiling of (4 + 4 + d_namlen) / 4. By scanning the bytes in the name itself, we can determine the name length and so derive d_namlen. Alignment is a good reason to make the inode number the first field and d_reclen the second rather than the other way around. If d_reclen were not included in the structure, then given d_namlen and knowing the C structure padding rules, we can derive d_reclen.","libVersion":"0.2.1","langs":"eng"}