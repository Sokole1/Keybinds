{"path":".obsidian/plugins/text-extractor/cache/75c4da21a42ced81058eb9b7ebd0d6fe.json","text":"CPSC 320: Graph Play Solutions∗ In this worksheet you’ll develop a better algorithm for the Weighted Shortest Paths (WSP) problem. Step 5: Design an algorithm for WSP that is faster than the reduction approach. 1. Does bfs suggest any “greedy” strategies to building shortest path trees for weighted graphs, adding one node of G at a time? Sketch out some ideas and try them on examples. Don’t concern yourselves too much about implementation details yet. SOLUTION: • Try 1: Starting with a tree just containing the root s, a natural idea is to add nodes one at a time, always adding the node that we can attach on to the tree with the cheapest edge. procedure WSP-Greedy-Incorrect-Attempt(s) T ← {s} ▷ T is the set of nodes in the tree while T ̸= V do ﬁnd a node v /∈ T with the cheapest edge to some u in T , i.e., ﬁnd v that minimizes minu∈T w(u, v) add v to T While this works on our initial example, it does not work for the following example. After nodes r and t are added, q can be connected most cheaply to t, but the shortest path is actually via r. • Try 2: We can get an algorithm that behaves exactly like bfs if instead of attaching the node with the cheapest edge, we attach the node with the shortest path to s. In this way, nodes are added to the tree in exactly the same order that they would be in the bfs algorithm, ensuring correctness. Dijkstra is credited with this algorithm. ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1 2. Here is Dijkstra’s greedy algorithm for the Weighted Shortest Paths problem. This pseudocode keeps track of the shortest path from s to each node u that is added to the tree. We’ll denote this distance by d[u]. Try out the algorithm on a small example. procedure WSP-Greedy-Dijkstra(s) d[s] ← 0 T ← {s} T is the set of nodes in the tree while T ̸= V do ﬁnd a node v /∈ T that minimizes the quantity minu∈T d[u] + w(u, v) add v to T d[v] ← minu∈T d[u] + w(u, v) 3. In each iteration of the while loop, to ﬁnd the needed v, we could enumerate through each edge (u, v) of the graph, checking if u ∈ T and v ̸∈ T and keeping track of the minimum value of d[u] + w(u, v) for such pairs. Give an upper bound on the time that this approach takes, and using this, get a total upper bound on the runtime of the algorithm. SOLUTION: This would take O(m) time per iteration, resulting in a total runtime of O(nm) since there are n iterations of the while loop. 2 4. There a more eﬃcient way to ﬁnd a node v /∈ T with the shortest path to s, i.e., the node v that minimizes minu∈T d[u] + w(u, v). The idea is to maintain distances d[v] for all v ∈ V , representing the best way to attach v to the tree T constructed so far. Initially d[v] = ∞ for all v, except for node s. Each time we add a node v to the tree, we update d[x] for all x adjacent to v, where x is not yet in T . A priority queue data structure is good for this purpose, see Chapter 2 of the text. A priority queue Q contains a set of n items, where each item v has an associated numerical key. For our purposes, the items will be nodes and key for node v will be the quantity d[v]. Operations on the queue include: • Create(Q, n, d): Creates a priority queue Q with n items numbered 1 to n, which all have the same key d = d[v]. The runtime cost is O(n). • ExtractMin(Q): Returns the item with the lowest-valued key, and removes this item from Q. The cost is O(log n). • ChangeKey (Q, v, d′): Changes the key of item v in queue Q to d′. The cost is O(log n). Flesh out the missing details in the code below, using the priority queue operations. SOLUTION: procedure WSP-Greedy-Dijkstra(s) ▷ create a priority queue whose keys are the initial values of d[v] for each v ∈ V Create(Q, n, ∞) ChangeKey(Q, s, 0) T ← ∅ while T ̸= V do ▷ ﬁnd a node v /∈ T with minimum d[v] v ← ExtractMin(Q) add v to T for all neighbours x of v do if x ̸∈ T then ▷ update the key for x to be min{d[x], d[v] + w(v, x)}) ChangeKey(Q, x, min{d[x], d[v] + w(v, x)}) 5. What is the runtime of this implementation of Dijkstra’s algorithm? SOLUTION: Creating the priority queue takes O(n) time. There are n iterations of the while loop, since one node is added to T on each iteration. When node v is added, the cost of ﬁnding v is O(log n), and the cost of adding v to the tree is O(1). The cost of each iteration of the for loop is O(log n), and the number of iterations is the degree of v, i.e., the number of neighbours that v has. So the total cost is O(n) + ∑ v∈V (O(log n) + O(1) + degree(v)O(log n)) = O(n log n) + ∑ v∈V degree(v)O(log n) = O(n log n + m log n) = O(m log n), where the last equality follows since the graph is connected. 3","libVersion":"0.2.1","langs":""}