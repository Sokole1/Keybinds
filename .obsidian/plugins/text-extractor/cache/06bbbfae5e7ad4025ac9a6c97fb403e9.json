{"path":".obsidian/plugins/text-extractor/cache/06bbbfae5e7ad4025ac9a6c97fb403e9.json","text":"Install ortools # ! pip install ortools Helper function # useful for printing long __dir__ def printlist(long_list,perline=5): for i,item in enumerate(long_list): print(item,end=\", \") if (i+1)%perline == 0: print() Problem to solve link max 3ùë• + 4ùë¶ ùë• + 2ùë¶ ‚©Ω 14 3ùë• ‚àí ùë¶ ‚©æ 0 ùë• ‚àí ùë¶ ‚©Ω 2 Import library from ortools.linear_solver import pywraplp # what's been imported printlist(pywraplp.__dir__()) 1 __name__, __doc__, __package__, __loader__, __spec__, __file__, __cached__, __builtins__, _swig_python_version_info, _pywraplp, __builtin__, _swig_repr, _swig_setattr_nondynamic_instance_variable, _swig_setattr_nondynamic_class_variable, _swig_add_metaclass, _SwigNonDynamicMeta, numbers, OFFSET_KEY, inf, LinearExpr, ProductCst, Sum, SumArray, SumCst, LinearConstraint, VariableExpr, Solver, __lshift__, Objective, Variable, Constraint, MPSolverParameters, cvar, ModelExportOptions, ExportModelAsLpFormat, ExportModelAsMpsFormat, FindErrorInModelProto, setup_variable_operator, opname, useful_classes = [\"Objective\", \"Constraint\", \"Variable\", \"Solver\"] Create a ‚ÄòGLOP‚Äô solver # \"GLOP\" google linear optimization solver solver = pywraplp.Solver.CreateSolver(\"GLOP\") # what's in the solver printlist(solver.__dir__()) this, __module__, __doc__, thisown, __repr__, CLP_LINEAR_PROGRAMMING, GLPK_LINEAR_PROGRAMMING, GLOP_LINEAR_PROGRAMMING, PDLP_LINEAR_PROGRAMMING, SCIP_MIXED_INTEGER_PROGRAMMING, GLPK_MIXED_INTEGER_PROGRAMMING, CBC_MIXED_INTEGER_PROGRAMMING, GUROBI_LINEAR_PROGRAMMING, GUROBI_MIXED_INTEGER_PROGRAMMING, CPLEX_LINEAR_PROGRAMMING, CPLEX_MIXED_INTEGER_PROGRAMMING, XPRESS_LINEAR_PROGRAMMING, XPRESS_MIXED_INTEGER_PROGRAMMING, BOP_INTEGER_PROGRAMMING, SAT_INTEGER_PROGRAMMING, __init__, __swig_destroy__, CreateSolver, SupportsProblemType, Clear, NumVariables, variables, variable, LookupVariable, Var, NumVar, IntVar, BoolVar, NumConstraints, constraints, constraint, LookupConstraint, Constraint, Objective, OPTIMAL, FEASIBLE, INFEASIBLE, UNBOUNDED, ABNORMAL, MODEL_INVALID, NOT_SOLVED, Solve, ComputeConstraintActivities, VerifySolution, InterruptSolve, FillSolutionResponseProto, SolveWithProto, ExportModelToProto, SetSolverSpecificParametersAsString, FREE, AT_LOWER_BOUND, AT_UPPER_BOUND, FIXED_VALUE, BASIC, infinity, EnableOutput, SuppressOutput, iterations, nodes, SolverVersion, ComputeExactConditionNumber, NextSolution, set_time_limit, wall_time, LoadModelFromProto, LoadModelFromProtoWithUniqueNamesOrDie, LoadSolutionFromProto, ExportModelAsLpFormat, ExportModelAsMpsFormat, SetHint, SetNumThreads, Add, Sum, RowConstraint, Minimize, Maximize, Infinity, SetTimeLimit, WallTime, Iterations, __dict__, __weakref__, __new__, __hash__, __str__, __getattribute__, __setattr__, __delattr__, __lt__, __le__, 2 __eq__, __ne__, __gt__, __ge__, __reduce_ex__, __reduce__, __subclasshook__, __init_subclass__, __format__, __sizeof__, __dir__, __class__, useful_solver_methods = [\"Objective\", \"NumVar\", \"Constraint\", \"NumConstraints\",\"Add\",\"Minimize\",\"Maximize\", \"LookupVariable\", \"LookupConstraint\"] # print help documentation # solver.NumVar? Create variables x = solver.NumVar(-solver.infinity(), solver.infinity(), \"xx\") # we set lower bound to -infinity! y = solver.NumVar(-solver.infinity(), solver.infinity(), \"yy\") print(\"Number of variables =\", solver.NumVariables()) print(\"Name of variable x is:\", x.name()) print(\"Name of variable y is:\", y.name()) Number of variables = 2 Name of variable x is: xx Name of variable y is: yy check variable bounds print(f\"lower and upper bounds of x: {x.lb()}, {x.ub()}\") print(f\"lower and upper bounds of y: {y.lb()}, {y.ub()}\") lower and upper bounds of x: -inf, inf lower and upper bounds of y: -inf, inf Infinity and negative infinity solver.infinity(), -solver.infinity(), -solver.infinity()<=solver.infinity() (inf, -inf, True) 3 explore the ‚ÄòVariable‚Äô object # type(x) #ortools.linear_solver.pywraplp.Variable printlist(x.__dir__()) this, __module__, __doc__, thisown, __init__, name, SetInteger, integer, solution_value, index, lb, ub, SetBounds, reduced_cost, basis_status, branching_priority, SetBranchingPriority, __str__, __repr__, __getattr__, SolutionValue, Integer, Lb, Ub, SetLb, SetUb, ReducedCost, __swig_destroy__, __dict__, __weakref__, __add__, __radd__, __sub__, __rsub__, __mul__, __rmul__, __div__, __truediv__, __neg__, __eq__, __ge__, __le__, __gt__, __lt__, __ne__, __new__, __hash__, __getattribute__, __setattr__, __delattr__, __reduce_ex__, __reduce__, __subclasshook__, __init_subclass__, __format__, __sizeof__, __dir__, __class__, useful_variable_methods = [\"lb\",\"ub\",\"SetBounds\",\"solution_value\"] # x.SetBounds? look up variable by name solver.LookupVariable('xx').lb(), solver.LookupVariable('xx').ub() (-inf, inf) Add constraints (use variable objects as if they are numbers) # Constraint 0: x + 2y <= 14. solver.Add(x + 2 * y <= 14.0) # solver.Add(x + 2 * y <= 14.0, 'can give it a name') # Constraint 1: 3x - y >= 0. 4 solver.Add(3 * x - y >= 0.0) # Constraint 2: x - y <= 2. solver.Add(x - y <= 2.0) print(\"Number of constraints =\", solver.NumConstraints()) Number of constraints = 6 Add objective function # Objective function: 3x + 4y. objective = solver.Maximize(3 * x + 4 * y) Start the solver status = solver.Solve() Check solution if status == pywraplp.Solver.OPTIMAL: # the problem is solved print(f\"Optimal solution is: x={x.solution_value():.0f}, y={y.solution_value():.0f}\") print(f\"Optimal value is: {solver.Objective().Value():.0f}\") Optimal solution is: x=6, y=4 Optimal value is: 34 Another example max 3ùë• + 2ùë¶ ùë• + ùë¶ ‚©Ω 1 ùë• ‚©æ 0 ùë¶ ‚©æ 0 5 from ortools.linear_solver import pywraplp # create solver another_solver = pywraplp.Solver.CreateSolver('GLOP') # variables x = another_solver.NumVar(0,another_solver.infinity(),'xx') y = another_solver.NumVar(0,another_solver.infinity(),'yy') # add constraints another_solver.Add(x+y<=1) # define objective another_solver.Maximize(3*x+2*y) # invoke solver status = another_solver.Solve() # check solution if status == pywraplp.Solver.OPTIMAL: # the problem is solved print(f\"Optimal solution is: x={x.solution_value():.0f}, y={y.solution_value():.0f}\") print(f\"Optimal value is: {another_solver.Objective().Value():.0f}\") Optimal solution is: x=1, y=0 Optimal value is: 3 Example (book 2.1) using matrix notation max 5ùë•1 + 4ùë•2 + 3ùë•3 2ùë•1 + 3ùë•2 + ùë•3 ‚©Ω 5 4ùë•1 + ùë•2 + 2ùë•3 ‚©Ω 11 3ùë•1 + 4ùë•2 + 2ùë•3 ‚©Ω 8 from ortools.linear_solver import pywraplp def SolveEg_2_1(): data_obj = [5,4,3] data_A = [ [2,3,1], [4,1,2], [3,4,2] ] 6 data_b = [5,11,8] # Instantiate a Glop solver and naming it. solver = pywraplp.Solver.CreateSolver('GLOP') if not solver: return # define our variables xs = ['x1','x2','x3'] vars = [solver.NumVar(0.0, solver.infinity(), x) for x in xs] print('Number of variables =', solver.NumVariables()) # constraints, one per inequality (equality) constraints = [] for i, b in enumerate(data_b): constraints.append(solver.Constraint(-solver.infinity(),b)) for j, d in enumerate(data_A[i]): constraints[i].SetCoefficient(vars[j], d) # objective: max objective = solver.Objective() for j, d in enumerate(data_obj): objective.SetCoefficient(vars[j], d) objective.SetMaximization() status = solver.Solve() # Check that the problem has an optimal solution. if status != solver.OPTIMAL: print('The problem does not have an optimal solution!') if status == solver.FEASIBLE: print('A potentially suboptimal solution was found.') else: print('The solver could not solve the problem.') exit(1) # Display solution solution = [0] * len(data_obj) for i, var in enumerate(vars): print(f'{xs[i]} : {var.solution_value():.1f}') 7 print(f'\\nOptimal value: {objective.Value():.1f}') SolveEg_2_1() Number of variables = 3 x1 : 2.0 x2 : 0.0 x3 : 1.0 Optimal value: 13.0 8","libVersion":"0.2.1","langs":""}