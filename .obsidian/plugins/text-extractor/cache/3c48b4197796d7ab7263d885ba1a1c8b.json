{"path":".obsidian/plugins/text-extractor/cache/3c48b4197796d7ab7263d885ba1a1c8b.json","text":"6. (4 points) Given the DFS tree T rooted at , explain how to compute the quantities I(v), li(v), and £y (v) for all v € V' in linear time. ‘We initialize a counter called I that keeps track of the current level. = 0 initially. We also ini- tialize the values of I(u), I7;(v), (1) for all nodes to co. We start by assigning I(s) = I, I(v) = L,Up(v) = 1. Then for all neighbours of s in G. We assign I,(v/) = 1, 1,,(+') = L. Now we increment I by one. Then we call this recursive function f for each of the children of s in T. f takes in v and I where v is the node to evaluate and 1 s the level. f starts by assigning I(v) = I and l(v) = L — 1,Ep(v) = L — 1 only if doing so will lower the value of l(v) or Up(u) respectively. The base case is if v has no children. In that case, we return Uy (z). Otherwise if v has children we do the following For all neighbours of of v in G, we assign Ij(1/) = L, l;(+') = I, only if doing so will lower the value of I;(v') or U(v') respectively. Then we call f(1/,1-+ 1) for each of the children. Since f returns I4(x/) we assign £;(v) to that value f it is lower. procedure CoMPUTE-I(v) — Ij(v) — I (v)(G. T) © G is a connected, unweighted, undirected graph with n > 2 nodes and m edges. o T is the DFS tree of G. for all v € V do 1) & 00 1(v) + 00 () « 00 10 ifs) -1 I(s) 1 (s) 1 for all neighbours v of s in G do I(v) « 1 () <1 for all children v of s in T do call COMPUTE-HELPER(v, I +1) procedure COMPUTE-HELPER(v, 1) Iw) 1 if 11 < l(v) then 7 In() - 1-1 if 1— 1< () then B) —1-1 if v has no children then return £ (v) for all neighbours +/ of v in G do if 1 < U (t)) then i) 1 if 1 < U (v/) then b) 1 for all children o/ of v in T do. Iychild « COMPUTE-HELPER(Y/, 1 +1) if Lrehild < Up(v) then In(v) + Irchild return £ (v) Explanation of algorithm:","libVersion":"0.2.1","langs":"eng"}