{"path":".obsidian/plugins/text-extractor/cache/7f36332f89fae14474f9e52847b98266.json","text":"CPSC 320 2023W1: Tutorial 6 1 Exhibition guarding In the Exhibition Guarding Problem, we are given a line L that represents a long hallway in a gallery; assume that the line has a left and right end. We are also given an unordered array X of real numbers that represent the positions of precious objects in this hallway, where a position marks the distance from the left end of the line. A guard at a position p on the line can protect objects within distance d of p, that is, objects in the range [p − d, p + d]. 1. Here is a greedy algorithm that ﬁnds the minimum number of guard positions needed to protect all objects in X. The algorithm ensures that the leftmost guard protects the object at the leftmost position, while choosing the leftmost position to be as far to the right as possible, so the guard protects as many other objects as possible. Then the algorithm is called recursively with the remaining unguarded objects. The following pseudocode captures this idea. procedure Place-Guards(X[1..n], d) ▷ X contains positions of n ≥ 0 objects on a line ▷ d is the distance (both to the left and right) that a guard can protect sort X in increasing order return Place-Guards-Helper(X[1..n], d) procedure Place-Guards-Helper(X[1..n], d) if n == 0 then return the empty set ▷ there are no objects, so no guard is needed else p ← X[1] + d ▷ place a guard as far right as possible while protecting X[1] ▷ skip the other objects protected by this guard i ← 2 while i ≤ n and X[i] ≤ p + d do i ← i + 1 return {p} + Place-Guards-Helper(X[i..n], d) 2. What is the running time of your algorithm? 3. Brieﬂy justify why your algorithm produces a valid solution, i.e., a set of guard positions that ensures that all objects are guarded. (Do not concern yourself yet with whether the set of positions is minimized.) 4. You’d also like to show that your algorithm produces a good i.e., optimal, solution that minimizes the number of guards. We can use an exchange argument (described in Chapter 4 of K&T) for this purpose: If G∗ is an optimal solution for instance (X[1..n], d) of our problem, we transform G∗ into the solution, say G, found by our greedy algorithm on the same instance, while keeping it optimal. It follows that G is also optimal. 1 Show the ﬁrst step of the exchange argument. Depending on the details of your algorithm, this might involve the following. Let p∗ 1 and p1 be the positions of the ﬁrst (leftmost) guard in G∗ and G, respectively. Show that G∗ − {p∗ 1} + {p1} is an optimal solution for instance (X[1..n], d). 5. Prove by induction on n, the number of objects, that your algorithm is correct. 2","libVersion":"0.2.1","langs":""}