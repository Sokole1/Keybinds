{"path":".obsidian/plugins/text-extractor/cache/7c0f40267e671e080aea0df7484aa95e.json","text":"CPSC 320 2023W1: Tutorial 1 Solutions 1 Recursive Permutation Generation The brute force algorithm for stable matching in the worksheet relied on a means to generate permu- tations. The following recursive algorithm can be used to generate all n! permutations of a set of n distinct integers, which are stored in an array p[1..n]. 1: function Generate-All-Permutations(p[1..n], i) 2: ▷ p[1..n] contains n distinct integers, 1 ≤ i ≤ n 3: if i = 1 then 4: return p[1..n] 5: else 6: for j from i downto 1 do 7: swap(p[i],p[j]) 8: Generate-All-Permutations(p[1..n], i − 1) 9: swap(p[i],p[j]) 10: end for 11: end if 12: end function 1. When n = 4, i = 4, and the value of the array is initially 3,2,9,5 (i.e., p[1] = 3, p[2] = 2, p[3] = 9, and p[4] = 5), what is the ﬁrst permutation that is returned? SOLUTION: 3,2,9,5 2. When n = 4, i = 4, and the value of the array is initially 3,2,9,5, what is the second permutation that is returned? SOLUTION: 2,3,9,5 3. Let n = 3 and let p[1..3] be 1,2,3. What is the sequence of permutations that are returned by Generate-All-Permutations(p[1..3], 3]? SOLUTION: 1,2,3 2,1,3 1,3,2 3,1,2 3,2,1 2,3,1 1 4. Use induction on i to prove the following claim. Claim: Let n > 0 and let 1 ≤ i ≤ n. For any value of the array p[1..n], when a call to Generate- All-Permutations(p[1..n], i) is made, the value of p[1..n] upon returning from the call is exactly the same as the initial value when that call is made. SOLUTION: We’ll prove this by induction on i. Base case: i = 1. In this case, line 4 is executed, and so the array is not changed. As a result, its value upon returning from the call is the same as its initial value when the call was made. Inductive Hypothesis: Let 1 < i ≤ n, and suppose that that the claim holds for i − 1. Inductive Step: We show that the claim holds for i, where 1 < i ≤ n. On each iteration of the for loop, the array p[1..n] is changed by the swap at line 7. When line 8 completes, the value of the array is the same as it was at the end of line 7, by the inductive hypothesis. The swap at line 9 reverses that done in line 7, returning the array to its value at the start of the loop. So when the for loop completes, the array’s value is the same as it was at the start of the function call. 2 Review proof by contradiction Let a, b and n be non-negative real numbers. Suppose that a · b = n. Prove that the statement either a ≤ √n (1) or b ≤ √n (2) is true. SOLUTION: We use proof by contradiction. Suppose not, such that the statement is false. This means that “(1) or (2)” is false. By De Morgan’s law, that means that (1) is false and (2) is false. In other words, a > √n and b > √n. Multiplying these two inequalities, we obtain that a · b > n. This contradicts our hypothesis that a · b = n. Therefore we were incorrect when we assumed the statement is false, so the statement is true. 2","libVersion":"0.2.1","langs":""}