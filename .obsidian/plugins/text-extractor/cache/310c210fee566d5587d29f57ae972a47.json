{"path":".obsidian/plugins/text-extractor/cache/310c210fee566d5587d29f57ae972a47.json","text":"CPSC 320 2023W1: Assignment 4 This assignment is due on Wednesday Nov 22 at 10pm on Gradescope. Assignments submitted before noon on Thursday will be accepted, but a penalty of 15% will be applied. Please follow the guidelines provided in Assignment 1. As usual, submission and formatting rules for Assignment 1 apply to this assignment as well. 1 List of names of group members (as listed on Canvas) Provide the list here. This is worth 1 mark. Include student numbers as a secondary failsafe if you wish. 2 Statement on collaboration and use of resources To develop good practices in doing homeworks, citing resources and acknowledging input from others, please complete the following. This question is worth 2 marks. 1. All group members have read and followed the guidelines for groupwork on assignments given on the website (see https://www.students.cs.ubc.ca/~cs-320/2021S2/coursework.html, under Assignments). Yes No 2. We used the following resources (list books, online sources, etc. that you consulted): 3. One or more of us consulted with course staﬀ during oﬃce hours. Yes No 4. One or more of us collaborated with other CPSC 320 students; none of us took written notes during our consultations and we took at least a half-hour break afterwards. Yes No If yes, please list their name(s) here: 5. One or more of us collaborated with or consulted others outside of CPSC 320; none of us took written notes during our consultations and we took at least a half-hour break afterwards. Yes No If yes, please list their name(s) here: 1 3 Lighting the Beacons An instance of the \"Lighting the Beacons\" problem from Tutorial 8 is speciﬁed by: (i) A sorted table D[1..n] of distances (in kilometers) from a source hill 1 to subsequent hills in a line that lead to a target hill n ≥ 1. All entries of D are distinct, and successive hills are at most 100km apart. (ii) A table P [1..n] of the probabilities that a beacon on each hill will successfully transmit the signal to a successor that is within 100km, with P [1] = 1. A valid solution to the problem is a chain of hills from the source but not including the target, with successive hills no more than 100km apart and the last hill in the chain no more than 100km from the target. An optimal solution is a valid solution such that if the source beacon is lit, the signal will be received at the target (hill n) with maximum probability. Note that the guards assigned to a beacon in a chain only light their beacon if they see the signal from the preceding beacon in the chain, even if an earlier beacon in the chain might be visible within 100km. As a result, the probability that a signal reaches the target along a valid chain is the product of the transmission probabilities of beacons in the chain. Let OP T (j) represent the maximum probability that a signal is transmitted from the source to beacon j. In the tutorial you developed the following recurrence relation for OP T (j): OP T (j) = { 1, if j = 1, maxi≤j′≤j−1{OP T (j′) × p(j′)}, if j > 1. Here, i is the index of the furthest hill preceding j that is still within 100km of hill j, so D[j] − D[i] ≤ 100, but D[j] − D[i − 1] > 100 or i = 1. 1. (4 marks) Using the recurrence relation, develop a memoized algorithm for computing OP T (n). Remember that a memoized algorithm always has a recursive helper function. Algorithm 1 Memoized approach for computing OPT(n) procedure Memo-Beacon(D[1...n], P [1...n]) ▷ n ≥ 1 ▷ initialization of a solution array goes here ▷ a call to the recursive helper function goes here procedure Memo-Beacon-Helper(D[1...j], P [1...j]) ▷ j ≥ 1 ▷ put pseudocode for the helper function here 2. (5 marks) Using the recurrence relation, develop a dynamic programming algorithm for com- puting OP T (n). 3. (2 marks) Suppose that the distinct entries in array D are all integers. In this case, if i is the index of the furthest hill preceding j that is still within 100km of hill j, there are at most 100 possible hills between i and j (including i and j themselves). We consider 100 to be a constant, i.e., 100 = O(1). Give a big-O-bound on the runtime of your dynamic programming algorithm from part 2 in this case, and brieﬂy justify your bound. 2 4 Edge Loads Revisited Recall the edge load problem from Assignment 2. An instance is an undirected, unweighted, con- nected, graph G = (V, E), with n nodes and m edges. For two nodes x and y let the (x, y)-edge load of an edge e in the graph, which we’ll denote by load(x, y, e), be the number of shortest paths between x and y that pass through e. Let load(e) be the sum of load(x, y, e), taken over all pairs of nodes (x, y). Example: For the graph on the left below, you saw that for example, if e = (1, 6) then load(1, 7, e) = 2, with the two paths being 1, 6, 3, 7 and 1, 6, 4, 7, and also load(1, 8, e) = 2. A BFS tree for this graph, rooted at node 1, is shown on the right, with dashed edges added, which may be useful for later parts of the problem. You also saw in Assignment 2 that we can calculate load(e) for all e by summing up the quantity load(x, y, e) for all pairs of nodes (x, y), but the time is O(n2m). Here you’ll develop a faster approach to calculating all of the quantities load(e). As usual, we let ds[v] denote the depth of node v in a BFS tree rooted at s, and we will also let ds = maxv∈V ds[v]. You can assume that these quantities have been precomputed and the algorithms that follow have access to these quantities. 1. (1 mark) Let load(s, e) be the number of shortest paths from s to any other node that goes through edge e. That is, load(s, e) = ∑ y∈V load(s, y, e). Let e = (u, v), and assume that u is closer to s than v, i.e. ds[u] < ds[v]. The paths counted in load(s, e) are comprised of an \"upper path\", from s to u, followed by v, and ﬁnally a \"lower path\", from v to some destination node. For our example graph, if e = (2, 3), then load(1, e) = 3, since there is one shortest path from 1 to 3, one from 1 to 7, and one from 1 to 8 that all go through edge (2, 3). (a) If e = (6, 4) what is load(1, e)? 0 1 2 3 4 (b) If e = (6, 5) what is load(1, e)? 0 1 2 3 4 2. (1 mark) Let lows(v) be the number of \"lower paths\" from node v in a BFS tree rooted at s. Each such path visits nodes at successively deeper levels of tree, following either tree or dashed edges that go deeper from one level to the next in the tree. Formally, lows(v) = 1 if v if a leaf, and otherwise lows(v) = 1 + ∑ x | (v, x) ∈ E, ds[x] = ds[v] + 1 lows(x). 3 Example: low1(6) = 8, since in the BFS tree rooted at 1, the nodes 6, 3, 4, and 5 can be reached by one shortest path from 6, while both nodes 7 and 8 can be reached via two shortest paths from 6. (Remember that dashed edges that go deeper are allowed on these paths.) (a) What is low1(2)? 1 2 3 4 (b) What is low1(4)? 1 2 3 4 3. (2 marks) Here is a recursive algorithm that calculates lows(v) for all nodes v, when the call Calculate-Lowers(s) is made. procedure Calculate-Lowers(u) lows(u) ← 1 ▷ there is a \"lower\" path from u to itself if ds[u] < ds then ▷ u is not a leaf of a BFS tree rooted at s for all edges (u, v) such that ds[v] == ds[u] + 1 do lows(u) ← lows(u)+ Calculate-Lowers(v) Suppose that we make the call Calculate-Lowers(s) on the example graph given above. On which nodes v is the call Calculate-Lowers(v) made more than once? List all such nodes v. No justiﬁcation needed. 4. (5 marks) Write a memoized (recursive) version of the Calculate-Lower algorithm, that avoids making multiple recursive calls to the same node on any input. Ideally it should run in O(n + m) time. procedure Memo-Calculate-Lowers(u) 5. (3 marks) What is the runtime of your algorithm of part 4? Justify your answer. 6. (1 mark) Let c(s, u) be the number of shortest paths from s to u. (You developed an algorithm to compute this quantity in Assignment 2.) Consider the following expressions, where e = (u, v) and ds[u] < ds[v]. Which one is correct? Choose one. load(s, e) = c(s, u) + lows(v) load(s, e) = c(s, u) × lows(v) load(s, e) = lows(u) + c(s, v) load(s, e) = lows(v) × c(s, v) 7. (2 marks) What is load(s, e) when e = (u, v) and u and v are equidistant from s (i.e., when ds[u] = ds[v])? Brieﬂy justify your answer. 8. (2 marks) Putting together the Θ(nm)-time algorithm to calculate all of the quantities c(x, y) from Assignment 2, an algorithm to compute lows(x) in O(n + m) time (e.g., from part 4), as well as the expressions of parts 6 and 7, what is the overall runtime to compute all of the quantities load(s, e), for all nodes s and edges e? Choose all that apply. Θ(n + m) Θ(n(n + m)) Θ((n + m) log n) Θ((n + m)2 log n) Θ(n + m)2) Θ(nm) 4 9. (1 mark) To wrap things up, suppose that all of the quantities load(s, e), for all nodes s and edges e, have already been calculated. What is the remaining time needed to compute all the quantities load(e) for all edges e, using the quantities load(s, e)? Check one. Θ(n) Θ(m) Θ(mn) Θ(mn2) 5 5 Subset Sums mod m In this example of dynamic programming, the recurrence describes a set of values, rather than a single value as in earlier examples. An instance I of the problem is a set {x1, x2, . . . , xn} of nonnegative integers and a positive integer m. We say that a value v, with 0 ≤ v ≤ m − 1, is feasible with respect to instance I if for some non-empty subset R of {x1, x2, . . . , xn}, ∑ x∈R x ≡ v (mod m). Also, for each i, 0 ≤ i ≤ n, let V (i) be the set of feasible values with respect to instance ({x1, x2, . . . , xi}, m). 1. (3 marks) Explain why the following recurrence holds for V (i). V (i) = { ∅, if i = 0 V (i − 1) ∪ ∪v∈V (i−1){(v + xi) (mod m)} ∪ {xi (mod m)}, if 1 ≤ i ≤ n. 2. (4 marks) Design a dynamic programming algorithm that, given an instance I = ({x1, x2, . . . , xn}, m) of Subset Sums mod m, determines whether 0 is feasible with respect to I. The algorithm outputs \"Yes\" or \"No\". Your algorithm should run in O(nm) time. Your pseudocode should create a solution array, Soln[0..n], and should store the set of values V (i) in Soln[i]. The pseudocode can use set operations such as ∪ as in the recurrence above. procedure Subset-Sum-mod-m(S = {x1, x2, . . . , xn}, m) ▷ returns \"Yes\" if for some non-empty subset R of S, ∑ x∈R x ≡ 0 (mod m) ▷ and returns \"No\" otherwise create an array Soln[0..n] ▷ entries of this array will be sets ▷ put the rest of the pseudocode here 3. (3 marks) Explain why your algorithm of part 2 runs in time O(nm). 4. (5 marks) Suppose that indeed there is a subset R of S such that ∑ x∈R x ≡ 0 (mod m). Write an algorithm that ﬁnds such a subset R. You can assume that an array Soln[0..n] has already been pre-computed, where Soln[i] stores the set V (i), and your algorithm can use the array Soln. Your algorithm should run in time O(nm). 5. (2 marks) Explain why your algorithm of part 4 runs in time O(nm). 6","libVersion":"0.2.1","langs":""}