{"path":".obsidian/plugins/text-extractor/cache/4fceb6efa4a56aff27bddc44f6c83707.json","text":"CPSC 320 2020W2: Take-home Test 2 Solutions 1. [0 marks] I hereby pledge that I have read and will abide by the rules, regulations, and expectations set out in the Academic Calendar, with particular attention paid to: ‹ The Student Declaration ‹ The Academic Honesty and Standards ‹ The Student Conduct During Examinations ‹ And any special rules for conduct as set out by the examiner. I a˚rm that I will not give or receive any unauthorized help on this examination, that all work will be my own, and that I will abide by any special rules for conduct set out by the examiner. True False 2. [3 marks] Recall (once again) the de˝nition of the Dominating Set problem: Given a graph G = (V, E) and an integer k, we want to ˝nd a subset W of V such that |W | ≤ k, and every elements of V − W is joined by an edge to an element of W . One of your friends came up with the following algorithm to ˝nd a dominating set of a graph G that is as small as possible: While V is not empty Let v be the element of V with the highest degree Add v to W Delete v and all of its neighbours from V Your friend asks you to prove the correctness of this algorithm using the \u0010greedy algorithm stays ahead\u0011 approach. What is the ˝rst statement that you will need to prove? Solution : You will need to prove that there is a minimum dominating set of G that contains the element of V with the highest degree. 3. [4 marks] To prove the correctness of a greedy algorithm using an exchange argument , we show how given our greedy solution SG and an arbitrary solution S that is not the same as SG, we can construct a solution S′ that has two properties. a. [2 marks] List one of the two properties that S′ must have. Solution : S′ must be more similar to SG than S, for some de˝nition of \u0010more similar\u0011. For instance, depending on the problem, \u0010more similar\u0011 might mean S′ has more edges in common with SG than S, or S′ might have a longer initial sequence whose elements are the same as those of SG than S. b. [2 marks] List the other property that S′ must have. Solution : S′ must be \u0010at least as good\u0011 as S with respect to the quantity we are trying to optimize. 4. [6 marks] You are given the problem of minimizing a quantity X[m, n] that depends on two sequences A = (a1, a2, . . . , am), B = (b1, b2, . . . , bn) of values. This quantity can be described by the recurrence relation X[m, n] = { (am − bn) + min{X[m − 1, n − 1] + 1, X[m − 1, n + 1] − 1, X[m, n − 1]} if m ≥ 1 and n ≥ 1 max{m, n} if m = 0 or n = 0 Write pseudo-code for a memoized algorithm ComputeX that computes X[m, n]. 1 Solution : The recurrence relation was missing one case to avoid an out-of-bound array access. It's ˝ne if you didn't notice it (neither the instructor nor the TA who proofread the exam had noticed) and we will not deduct marks for it. Here's a recurrence relation that is identical except that it does not su˙er from this de˝ciency: X[i, j] =  | | (ai − bj) + min{X[i − 1, j − 1] + 1, X[i − 1, j + 1] − 1, X[i, j − 1]} if i ≥ 1 and 1 ≤ j < n (ai − bj) + min{X[i − 1, j − 1] + 1, X[i, j − 1]} if i ≥ 1 and j = n max{i, j} if i = 0 or j = 0 Here is the memoized algorithm ComputeX requested by the question: function ComputeX(A, B, m, n) X ← new m × n array // Assume 1-based indexing Initialize every entry of X to null return ComputeXHelper(m, n) function ComputeXHelper(i, j) if i = 0 or j = 0 then return max(i, j) if X[i, j] is null then firstterm = ComputeXHelper(i-1, j-1) + 1 thirdterm = ComputeXHelper(i, j-1) if j = n then X[i, j] = A[i] - B[j] + min(firstterm, thirdterm) else secondterm = ComputeXHelper(i-1, j+1) - 1 X[i, j] = A[i] - B[k] + min(firstterm, secondterm, thirdterm) endif endif return X[i, j] 5. [3 marks] Suppose now that you want to write pseudo-code for an iterative algorithm to compute the value X[m, n] from the previous question. What would the loops used in your solution look like (ignoring base cases)? Loop (a): for i ← 1 to m for j ← 1 to n X[i, j] = ... Loop (b): for j ← 1 to n for i ← 1 to m X[i, j] = ... Only loop (a) will work. Only loop (b) will work. Both loop (a) and loop (b) will work. Neither loop (a) nor loop (b) will work. 2 6. [6 marks] Let G = (V, E) be an undirected graph with n nodes. We will call the graph G a path if its nodes can be written as v1, v2, . . . , vn with an edge between vi and vj if and only if the numbers i and j di˙er by exactly 1. With each node vi, we associate a positive integer weight wi. For example, in the following path, the weights are the numbers drawn inside the nodes. Consider the problem of ˝nding the subset of the vertices V of G with the largest total weight, subject to the following condition: If a node vi with weight wi is chosen as part of the subset, then none of the nodes vi−1, vi−2, . . . , vi−wi can be chosen. For instance, if we choose v4 as part of the subset for the graph G in the picture, then we are not allowed to include v3 and v2 (because the weight of v4 is 2). This problem can be solved using dynamic programming. Let Qi be the weight of the subset of {v1, v2, . . . , vi} with the largest total weight, subject to the constraint above. Write a recurrence re- lation for Qi. Solution : This is similar to the weighted interval scheduling problem: either node vi is in the subset, or it's not. If it's not, then Qi is the same as the highest weight subset of {v1, v2, . . . vi−1} that satis˝es the constraint. If it is, then we combine vi with the highest weight subset of {v1, v2, . . . vi−wi−1}. Q[i] =  | | w1 if i = 1 max{Q[i − 1], wi} if i > 1 and i − wi − 1 ≤ 0 max{Q[i − 1], wi + Q[i − wi − 1]} if i − wi − 1 ≥ 1 3","libVersion":"0.2.1","langs":""}