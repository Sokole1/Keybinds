{"path":".obsidian/plugins/text-extractor/cache/ec3a403543fb0fabe78a7d43f7fa17b4.json","text":"CPSC 320: Graph Play In this worksheet you’ll develop a better algorithm for the Weighted Shortest Paths (WSP) problem. Step 5: Design an algorithm for WSP that is faster than the reduction approach. 1. Does bfs suggest any “greedy” strategies to building shortest path trees for weighted graphs, adding one node of G at a time? Sketch out some ideas and try them on examples. Don’t concern yourselves too much about implementation details yet. 1 2. Here is Dijkstra’s greedy algorithm for the Weighted Shortest Paths problem. This pseudocode keeps track of the shortest path from s to each node u that is added to the tree. We’ll denote this distance by d[u]. Try out the algorithm on a small example. procedure WSP-Greedy-Dijkstra(s) d[s] ← 0 T ← {s} T is the set of nodes in the tree while T ̸= V do ﬁnd a node v /∈ T that minimizes the quantity minu∈T d[u] + w(u, v) add v to T d[v] ← minu∈T d[u] + w(u, v) 3. In each iteration of the while loop, to ﬁnd the needed v, we could enumerate through each edge (u, v) of the graph, checking if u ∈ T and v ̸∈ T and keeping track of the minimum value of d[u] + w(u, v) for such pairs. Give an upper bound on the time that this approach takes, and using this, get a total upper bound on the runtime of the algorithm. 2 4. There a more eﬃcient way to ﬁnd a node v /∈ T with the shortest path to s, i.e., the node v that minimizes minu∈T d[u] + w(u, v). The idea is to maintain distances d[v] for all v ∈ V , representing the best way to attach v to the tree T constructed so far. Initially d[v] = ∞ for all v, except for node s. Each time we add a node v to the tree, we update d[x] for all x adjacent to v, where x is not yet in T . A priority queue data structure is good for this purpose, see Chapter 2 of the text. A priority queue Q contains a set of n items, where each item v has an associated numerical key. For our purposes, the items will be nodes and key for node v will be the quantity d[v]. Operations on the queue include: • Create(Q, n, d): Creates a priority queue Q with n items numbered 1 to n, which all have the same key d = d[v]. The runtime cost is O(n). • ExtractMin(Q): Returns the item with the lowest-valued key, and removes this item from Q. The cost is O(log n). • ChangeKey (Q, v, d′): Changes the key of item v in queue Q to d′. The cost is O(log n). Flesh out the missing details in the code below, using the priority queue operations. procedure WSP-Greedy-Dijkstra(s) ▷ create a priority queue whose keys are the initial values of d[v] for each v ∈ V T ← ∅ while T ̸= V do ▷ ﬁnd a node v /∈ T with minimum d[v] add v to T for all neighbours x of v do if x ̸∈ T then ▷ update the key for x to be min{d[x], d[v] + w(v, x)}) 5. What is the runtime of this implementation of Dijkstra’s algorithm? 3","libVersion":"0.2.1","langs":""}