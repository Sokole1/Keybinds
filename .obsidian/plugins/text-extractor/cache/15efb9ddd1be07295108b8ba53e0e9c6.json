{"path":".obsidian/plugins/text-extractor/cache/15efb9ddd1be07295108b8ba53e0e9c6.json","text":"CPSC 310: Introduction to Software Engineering “Many client-speciﬁc inter faces are better than one general-purpose inter face.” [http://en.wikipedia.org/wiki/Inter face_segregation_principle] Inter face Segregation P rinciple DILOS CPSC 310: Introduction to Software Engineering ● Clients should not have to depend on unnecessar y methods. ● No implementation should be forced to provide methods that do not ﬁt into their abstraction! ○ This is a classic pathway to SRP and LSP violations! ● Solution : Move towards role-based inter faces. ○ Clients need only know about the methods that are of interest to them. ○ This relates strongly to the concept of high cohesion. DILOSInter face Segregation P rinciple CPSC 310: Introduction to Software Engineering W e can immediately see that merge conﬂicts will become a problem in a multi-person team. F ood versus drinks → Diver gent Changes.const b: Bak er yInter face = new Bak er yImp(); DETEC TING THE FLA W A T THE SUB TYPE : What we have here is an SRP violation, C A USED B Y the ISP violation! Because the divergent changes indicate SRP. Client S tar ting a Bak er y DILOS CPSC 310: Introduction to Software Engineering DETEC TING THE FLA W A T THE CLIENT SIDE The ﬂaw FROM THE CLIENT’S PERSPEC TIVE Optimised for baking! No attention paid for coﬀee shop! CoﬀeeShopApp forced to rely on methods it doesn’t need because it only has Bak er yInter face to work with. Business is Good. Coﬀee C ar t? This is not as good! Now the CoﬀeeShopApp client is only using par t of the Bak er yInter face, but it has to know about all of it. It’s lik ely that changes to the implementation of some of those methods could aﬀect the implementations of others. DILOS CPSC 310: Introduction to Software Engineering DETEC TING THE FLA W A T THE CLIENT SIDE The ﬂaw FROM THE CLIENT’S PERSPEC TIVE CoﬀeeShpImpl ---- sellCoﬀee sellJuice sellCak e << throw not imp’l sellBr ead << throw not imp’l F ood versus drinks → Diver gent Changes. Business is Good. Coﬀee C ar t? This is not as good! Now the CoﬀeeShopApp client is only using par t of the Bak er yInter face, but it has to know about all of it. It’s lik ely that changes to the implementation of some of those methods could aﬀect the implementations of others. DILOS CPSC 310: Introduction to Software Engineering • “no client should be for ced to depend on methods it does not use” Ultimately Bak er yInter face might be a good design for a bak er y but is bad at being a Coﬀee Shop. Business is Good. Coﬀee C ar t? This is not as good! Now the CoﬀeeShopApp client is only using par t of the Bak er yInter face, but it has to know about all of it. It’s lik ely that changes to the implementation of some of those methods could aﬀect the implementations of others. DILOS CPSC 310: Introduction to Software Engineering What other principle is being violated? LSP!! Special implementation? DILOS CPSC 310: Introduction to Software Engineering Divergent changes SRP V iolation Extract Interface Refactoring. Extract sellCoffee sellJuice → CoffeeShopInter face Bak er yImpl ---- sellC ak e() sellBread() CoffeeShpImpl ---- sellCoffee() sellJuice() ISP V iolation Bak er yInt ---- sellC ak e() sellBread() CoﬀeeShpInt ---- sellCoﬀee() sellJuice() Bak er yApp ---- …. ... Bak er yApp ------ const cs: CoffeeShpInt = new CoffeeShopImpl(); const b: Bak er yInter face = new Bak er yImpl(); Same thing ISP forces responsibilities on others (the client, the implementers). SRP describes implementation level collisions. DILOS CPSC 310: Introduction to Software Engineering These can also be fields Bak er yInt er face Bad cohesion → Divergent changes → Extract Class → Extract Inter face → Inter face Seg P. No LSP violation! An Improved Design This class would contain: cs: CoffeeShopInter face = new CoffeeShopImpl(); This class would contain: cs: CoffeeShopInter face = new CoffeeShopImpl(); b: Bak er yInter face = new Bak er yImpl(); DILOS CPSC 310: Introduction to Software Engineering “Depend upon abstr actions , do not depend upon implementations .” High-level modules should not depend on low-level modules. Both should depend on abstractions. Restated: Abstractions should not depend on details . Details should depend on abstractions . [ http://en.wikipedia.org/wiki/Dependency_inversion_principle] Depend upon means DECLARING an entity of that type. Dependency Inversion DILOS CPSC 310: Introduction to Software Engineering Dependency Inversion DILOS CPSC 310: Introduction to Software Engineering InsightF acadeIInsightF acade Team A ’s Repo Gr ader Repo Aut oTest Dependency Inversion DILOS CPSC 310: Introduction to Software Engineering InsightF acade.spec.ts Dependency Inversion DILOS InsightF acadeIInsightF acade Team A ’s Repo Gr ader Repo Aut oTest CPSC 310: Introduction to Software Engineering OLD: const data: ArrayList = new ArrayList(); NEW: const data: Collection = new ArrayList( ); → What class of future changes does this enable? OLD: const s: Ser ver = new Ser ver( ); NEW: const s: Ser verInter face = new Ser verImplementation( ); → What class of future changes does this enable? Concrete DI Examples data.add(‘cs310’); // only knows data as a Collection inter face, not its concrete type. s.star t(); // only knows about s as the inter face type. DILOS CPSC 310: Introduction to Software Engineering Typical Class Design DILOS CPSC 310: Introduction to Software Engineering Nice clean calls down from within public methods. All the guts down here. P ublic Methods are the ‘Inter face’DILOS CPSC 310: Introduction to Software Engineering P ublic C alls ‘Down’ to Impl DILOS CPSC 310: Introduction to Software Engineering Combining These… DILOS CPSC 310: Introduction to Software Engineering P rivate Behaviours Depend on Abstractions! DILOSDesign P rinciples Recap P r agmatic P r ogr ammer : Eliminate eﬀects between unrelated things by designing components that are: Self-contained, independent, and have a single, well-deﬁned purpose .DILOS CPSC 310: Introduction to Software Engineering A class should have only one reason to change. responsibility single A class should have only a Single Responsibility DILOS CPSC 310: Introduction to Software Engineering closed A class must be to internal changes open but still be for e xtensions When designing classes, do not plan for brand new functionality to be added by modifying the core of the class. Instead, design your class so that e xtensions can be made in a modular way, to provide new functionality by leveraging the power of the inheritance facilities of the language, or through pre-accommodated addition of methods. Open/Closed DILOS CPSC 310: Introduction to Software Engineering subtype super typeObjects of a in a program may be replaced with objects of a without altering any desirable proper ties of the program If S is a subtype of T, then objects of type T (super type) in a program may be replaced with objects of type S (subtype) without altering any of the desirable proper ties of that program. Lisk ov Substitution DILOS CPSC 310: Introduction to Software Engineering client No should be forced to depend on methods it does not use A move towards role-based inter faces: No implementation class should be forced to provide methods that do not ﬁt into its abstraction! (SRP and LSP violations!) Clients need only know about the methods that are of interest to them. Int er face Segregation DILOS CPSC 310: Introduction to Software Engineering High-level modules should not depend on low-level modules; instead, they should depend on abstractions. implementations abstractions not Depend on Dependency Inversion DILOS","libVersion":"0.2.1","langs":""}