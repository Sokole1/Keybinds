{"path":".obsidian/plugins/text-extractor/cache/ee9c2fc337c84e9111101c0be4b85784.json","text":"CPSC 320 Test 2 November 10th, 2020 \u0015 You have 60 minutes to write the 4 questions on this examination. A total of 40 marks are available. \u0015 Justify all of your answers. \u0015 You are allowed to access the course web site, Canvas, your notes, the textbook and (only to ask a question if you believe you have found an error on the exam) private posts on Piazza, but not other web sites. You are not allowed to contact people other than the course sta˙. \u0015 Keep your answers short. If you run out of space for a question, you have written too much. \u0015 The number in square brackets to the left of the question number indicates the number of marks allocated for that question. Use these to help you determine how much time you should spend on each question. \u0015 Use the back of the pages for your rough work. \u0015 Good luck! UNIVERSITY REGULATIONS: \u0015 Each candidate should be prepared to produce, upon request, his/her UBC card. \u0015 CAUTION: candidates guilty of any of the following, or similar, dishonest practices shall be immediately dismissed from the examination and shall be liable to disciplinary action. 1. Having at the place of writing, or making use of, any books, papers or memoranda, electronic equipment, or other memory aid or communication devices, other than those authorised by the examiners. 2. Speaking or communicating with other candidates. page 2 out of 4 1 The Master Theorem Which Θ bounds will the Master Theorem give for each of the following recurrence relations? 1. [3 marks] T (n) = { 8T (n/4) + n log n if n ≥ 4 Θ(1) if n ≤ 3 2. [3 marks] T (n) = { 13T (n/7) + n2 if n ≥ 7 Θ(1) if n ≤ 6 2 Writing a recurrence Write a recurrence relation that describes the worst-case running time of the following algorithm as a function on n. To help you, we've provided a LaTeX template that you can cut and paste into the response ˝eld (you will still need to ˝ll in the actual answer). Assume that function square_root runs in constant time. Algorithm SSA(A, first, n) if n == 0 return 0 else if n == 1 return A[first] else if n == 2 return square_root(A[first] * A[first+1]) else threef = 3 * ⌊ n/5 ⌋ return square_root(SSA(A, first, threef) * SSA(A, first + threef, n - threef)) 3 Solving a recurrence Using a method of your choice, give a tight ( Θ) bound on the function T (n) de˝ned by the following recurrence relation: T (n) = { T (3n/5) + T (4n/5) + n2 if n ≥ 5 Θ(1) if n ≤ 4 4 Highest Point on a Circle In this question, you are given n ≥ 3 points in the xy plane, all of which lie on a circle. The points are stored in an array P of points, indexed from P [0] to P [n − 1], in counter-clockwise order (the direction of the dashed, gray arrow in the picture). For example, here's an instance with n = 6: page 3 out of 4 P[0] P[1] P[2] P[3] P[4] P[5] Notice that the points are not guaranteed to be evenly spaced around the circle (although they could be). Also, note how P [0] might be any of the points (it's not the leftmost or rightmost or highest or lowest or anything), but from there, P [1], . . . , P [n − 1] are in counter-clockwise order going around the circle. And after P [n − 1], the next point going counter-clockwise around the circle is back to P [0]. Your task in this question is to complete the pseudocode below so that it correctly returns the index of the highest point , namely, the point in the array with the largest y-coordinate. For example, in the picture above, the code should return 4, because P [4] has the largest y-coordinate (it's the furthest towards the top of the page). Furthermore, the runtime of your completed pseudocode must be O(log n). Here are some tips that might make the pseudocode easier to write: ‹ Use the syntax P [i].x and P [i].y to refer to the x- and y-coordinates of the ith point P [i]. ‹ You may assume that no two points have the same x- or y-coordinates if you wish. ‹ You may assume in your pseudocode that array accesses \u0010wrap around\u0011 when the index goes negative or ≥ n, e.g., P [−1] is the same as P [n − 1], and P [n] is the same as P [0]. ‹ We have provided a helper function trend(int i) that takes an index i and returns TOP if P [i] is higher up (has a greater y-coordinate) than both P [i − 1] and P [i + 1]; BOTTOM if P [i] is lower than both P [i − 1] and P [i + 1]; UPWARD if P [i] is higher than P [i − 1] and lower than P [i + 1]; and DOWNWARD if P [i] is lower than P [i − 1] and higher than P [i + 1]. Intuitively, this function tells you the direction you are going at point P [i] if you are following the points around the circle in order. enum direction{TOP, BOTTOM, UPWARD, DOWNWARD}; direction trend(int i) { if (P[i].y < P[i-1].y) { if (P[i].y < P[i+1].y) return BOTTOM; else return DOWNWARD; } else { if (P[i].y > P[i+1].y) return TOP; else return UPWARD; } } ‹ We've also provided more than enough base cases in the pseudocode, so you can concentrate on the dividing-and-conquering instead of the details of the base cases. page 4 out of 4 1. [12 marks] Here's the start of the main pseudocode. Fill in the missing parts so that your code ˝nds the highest point and runs in O(log n) time. (Hint: If i < j and trend (i) is UPWARD and trend (j) is DOWNWARD, what can you conclude about the the index of the highest point? What other cases do you need to handle?) int find_top(int low, int high) { // You should maintain the invariant that low<=high and // that the point with the highest y-coordinate is among P[low..high]. // So, to find the top point among all of them, the top-level call to // this function is find_top(0,n-1). // Base Cases if (trend(low)==TOP) return low; if (trend(high)==TOP) return high; // YOUR CODE STARTS HERE!","libVersion":"0.2.1","langs":""}