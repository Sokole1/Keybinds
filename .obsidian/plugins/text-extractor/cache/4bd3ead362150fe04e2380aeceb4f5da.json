{"path":".obsidian/plugins/text-extractor/cache/4bd3ead362150fe04e2380aeceb4f5da.json","text":"CPSC 340: Machine Learning and Data Mining More Regularization Last Time: L2-Regularization • We discussed regularization: – Adding a continuous penalty on the model complexity: – Best parameter λ almost always leads to improved test error. • L2-regularized least squares is also known as “ridge regression”. • Can be solved as a linear system like least squares. – Numerous other benefits: • Solution is unique, less sensitive to data, gradient descent converges faster. Regularizing the y-Intercept? • Should we regularize the y-intercept? • No! Why encourage it to be closer to zero? (It could be anywhere.) – You should be allowed to shift function up/down globally. • Yes! It makes the solution unique and it easier to compute ‘w’. • Compromise: regularize by a smaller amount than other variables. Parametric vs. Non-Parametric Transforms • We’ve been using linear models with polynomial bases: • But polynomials are not the only possible bases: – Exponentials, logarithms, trigonometric functions, etc. – The right basis will vastly improve performance. – If we use the wrong basis, our accuracy is limited even with lots of data. – But the right basis may not be obvious. Parametric vs. Non-Parametric Transforms • We’ve been using linear models with polynomial bases: • Alternative is non-parametric bases: – Size of basis (number of features) grows with ‘n’. – Model gets more complicated as you get more data. – Can model complicated functions where you don’t know the right basis. • With enough data. – Classic example is “Gaussian RBFs” (“Gaussian” == “normal distribution”). • Gaussian RBFs are universal approximators (compact subets of ℝd) – Enough bumps can approximate any continuous function to arbitrary precision. – Achieve optimal test error as ‘n’ goes to infinity. Gaussian RBFs: A Sum of “Bumps”Gaussian RBFs: A Sum of “Bumps” • Polynomial fit: • Constructing a function from bumps (“smooth histogram”): Gaussian RBFs: A Sum of “Bumps” • Red is weight*feature, green is prediction (sum of red lines): Gaussian RBF Parameters • Some obvious questions: 1. How many bumps should we use? 2. Where should the bumps be centered? 3. How high should the bumps go? 4. How wide should the bumps be? • The usual answers: 1. We use ‘n’ bumps (non-parametric basis). 2. Each bump is centered on one training example xi. 3. Fitting regression weights ‘w’ gives us the heights (and signs). 4. The width is a hyper-parameter (narrow bumps == complicated model). Gaussian RBFs: Formal Details • What is a radial basis functions (RBFs)? – A set of non-parametric bases that depend on distances to training points. – Have ‘n’ features, with feature ‘j’ depending on distance to example ‘i’. • Typically the feature will decrease as the distance increases: • What is a radial basis functions (RBFs)? – Most common choice of ‘g’ is Gaussian RBF: • Variance σ2 is a hyper-parameter controlling “width”. – This affects fundamental trade-off (set it using a validation set). – Why don’t we have 2𝜋𝜎 in the above formula? • If you do not regularize it does not matter: – If ‘v’ is least squares solution with features zi, then ( 2𝜋𝜎)v is solution with features (1/ 2𝜋𝜎)zi. – So you get the same predictions (least squares is invariant to scaling of features). • If you regularize it “sort of” matters: – It changes the effect of a fixed λ. – But the regularization path is the same, so if you search for the best λ you get same predictions. Gaussian RBFs: Formal DetailsGaussian RBFs: Formal Details • What is a radial basis functions (RBFs)? – The training and testing matrices when using RBFs: Gaussian RBFs: Pseudo-CodeNon-Parametric Basis: RBFs • Least squares with Gaussian RBFs for different σ values: RBFs and Regularization • Gaussian Radial basis functions (RBFs) predictions: – Flexible bases that can model any continuous function. – But with ‘n’ data points RBFs have ‘n’ basis functions. • How do we avoid overfitting with this huge number of features? – We regularize ‘w’ and use validation error to choose 𝜎 and λ. RBFs, Regularization, and Validation • A model that is hard to beat: – RBF basis with L2-regularization and cross-validation to choose 𝜎 and λ. – Flexible non-parametric basis, magic of regularization, and tuning for test error. – Can add bias or linear/poly basis to do better away from data. – Expensive at test time: need distance to all training examples. 16 RBFs, Regularization, and Validation • A model that is hard to beat: – RBF basis with L2-regularization and cross-validation to choose 𝜎 and λ. – Flexible non-parametric basis, magic of regularization, and tuning for test error! – Expensive at test time: needs distance to all training examples. Hyper-Parameter Optimization • In this setting we have 2 hyper-parameters (𝜎 and λ). • More complicated models have even more hyper-parameters. – This makes searching all values expensive (increases over-fitting risk). • Leads to the problem of hyper-parameter optimization. – Try to efficiently find “best” hyper-parameters. • Simplest approaches: – Exhaustive search: try all combinations among a fixed set of σ and λ values. – Random search: try random values. Hyper-Parameter Optimization • Other common hyper-parameter optimization methods: – Exhaustive search with pruning: • If it “looks” like test error is getting worse as you decrease λ, stop decreasing it. – Coordinate search: • Optimize one hyper-parameter at a time, keeping the others fixed. • Repeatedly go through the hyper-parameters – Stochastic local search: • Generic global optimization methods (simulated annealing, genetic algorithms, and so on). – Bayesian optimization: • Use RBF regression to build model of how hyper-parameters affect validation error. • Try the best guess based on the model, then repeat. Next Topic: Interpolation vs. Extrapolation Predicting the Future • In principle, we can use any features xi that we think are relevant. • This makes it tempting to use time as a feature, and predict future. https://gravityandlevity.wordpress.com/2009/04/22/the-fastest-possible-mile/ Predicting the Future • In principle, we can use any features xi that we think are relevant. • This makes it tempting to use time as a feature, and predict future. https://gravityandlevity.wordpress.com/2009/04/22/the-fastest-possible-mi https://overthehillsports.wordpress.com/tag/hicham-el-guerrouj/le/ Predicting 100m times 400 years in the future? https://plus.maths.org/content/sites/plus.maths.org/files/articles/2011/usain/graph2.gif Predicting 100m times 400 years in the future? https://plus.maths.org/content/sites/plus.maths.org/files/articles/2011/usain/graph2.gif http://www.washingtonpost.com/blogs/london-2012-olympics/wp/2012/08/08/report-usain-bolt-invited-to-tryout-for-manchester-united/ Interpolation vs Extrapolation • Interpolation is task of predicting “between the data points”. – Regression models are good at this if you have enough data and function is continuous. • Extrapolation is task of prediction outside the range of the data points. – Without assumptions, regression models can be embarrassingly-bad at this. • If you run the 100m regression models backwards in time: – They predict that humans used to be really really slow! • If you run the 100m regression models forwards in time: – They might eventually predict arbitrarily-small 100m times. – The linear model actually predicts negative times in the future. • These time traveling races in 2060 should be pretty exciting! • Some discussion here: – http://callingbullshit.org/case_studies/case_study_gender_gap_running.html https://www.smbc-comics.com/comic/rise-of-the-machines No Free Lunch, Consistency, and the FutureNo Free Lunch, Consistency, and the FutureNo Free Lunch, Consistency, and the FutureNo Free Lunch, Consistency, and the Future • We can resolve “blue vs. green” by collecting more data: No Free Lunch, Consistency, and the FutureNo Free Lunch, Consistency, and the FutureNo Free Lunch, Consistency, and the FutureNo Free Lunch, Consistency, and the FutureNo Free Lunch, Consistency, and the FutureNo Free Lunch, Consistency, and the FutureDiscussion: Climate Models • Has Earth warmed up over last 100 years? (Consistency zone) – Data clearly says “yes”. • Will Earth continue to warm over next 100 years? (generalization error) – We should be more skeptical about models that predict future events. https://en.wikipedia.org/wiki/Global_warming Discussion: Climate Models • So should we all become global warming skeptics? • If we average over models that overfit in *independent* ways, we expect the test error to be lower, so this gives more confidence: – We should be skeptical of individual models, but agreeing predictions made by models with different data/assumptions are more likely be true. • All the near-future predictions agree, so they are likely to be accurate. – And it’s probably reasonable to assume fairly continuous change (no big “jumps”). • Variance is higher further into future, so predictions are less reliable. – Relying more on assumptions and less on data. https://en.wikipedia.org/wiki/Global_warming Index Funds: Ensemble Extrapolation for Investing • Want to do extrapolation when investing money. – What will this be worth in the future? • Index funds can be viewed as an ensemble method for investing. – For example, buy stock in top 500 companies proportional to value. – Tries to follow average price increase/decrease. – This simple investing strategy outperforms most managed funds. http://fibydesign.com/005-introduction-to-index-investing-stocks-index-funds-vtsax/ Next Topic: L1-Regularization Previously: Search and Score • We talked about search and score for feature selection: – Define a “score” and “search” for features with the best score. • Usual scores count the number of non-zeroes (“L0-norm”): • But it’s hard to find the ‘w’ minimizing this objective. • We discussed forward selection, but requires fitting O(d2) models. Previously: Search and Score • What if we want to pick among millions or billions of variables? • If ‘d’ is large, forward selection is too slow: – For least squares, need to fit O(d2) models at cost of O(nd2 + d3). – Total cost O(nd4 + d5), and even if you are clever still costs O(nd2 + d4). • The situation is worse if we are not using basic least squares: – For robust regression, need to run gradient descent O(d2) times. – With regularization, need to search for lambda O(d2) times. L1-Regularization • Instead of L0- or L2-norm, consider regularizing by the L1-norm: • Like L2-norm, it’s convex and improves our test error. • Like L0-norm, it encourages elements of ‘w’ to be exactly zero. • L1-regularization simultaneously regularizes and selects features. – Very fast alternative to search and score. – Sometimes called “LASSO” regularization. L2-Regularization vs. L1-Regularization • Regularization path of wj values as ‘λ’ varies: • L1-Regularization sets values to exactly 0 (next slides explore why). Regularizers and Sparsity • L1-regularization gives sparsity but L2-regularization does not. – But don’t they both shrink variables towards zero? • What is the penalty for setting wj = 0.00001? • L0-regularization: penalty of λ. – A constant penalty for any non-zero value. – Encourages you to set wj exactly to zero, but otherwise doesn’t care if wj is small or not. • L2-regularization: penalty of (λ/2)(0.00001)2 = 0.0000000005λ. – The penalty gets smaller as you get closer to zero. – The penalty asymptotically vanishes as wj approaches 0 (no incentive for “exact” zeroes). • L1-regularization: penalty of λ|0.00001| = 0.00001λ. – The penalty stays is proportional to how far away wj is from zero. – There is still something to be gained from making a tiny value exactly equal to 0. L2-Regularization vs. L1-Regularization • L2-Regularization: – Insensitive to changes in data. – Decreased variance: • Lower test error. – Closed-form solution. – Solution is unique. – All ‘wj’ tend to be non-zero. – Can learn with linear number of irrelevant features. • E.g., only O(d) relevant features. • L1-Regularization: – Insensitive to changes in data. – Decreased variance: • Lower test error. – Requires iterative solver. – Solution is not unique. – Many ‘wj’ tend to be zero. – Can learn with exponential number of irrelevant features. • E.g., only O(log(d)) relevant features. Paper on this result by Andrew Ng L1-Regularization Applications • Used to give super-resolution in imaging black holes. – Sparsity arises in a particular basis. • Another application: – Use L1-regularization with Gaussian RBFs to reduce prediction time. https://iopscience.iop.org/article/10.1088/1742-6596/699/1/012006/pdf Summary • Radial basis functions: – Non-parametric bases that can model any function. – But prediction is slow since with ‘n’ training examples you have ‘n’ features. • Interpolation vs. Extrapolation: – Machine learning with large ‘n’ is good at predicting “between the data”. – Without assumptions, can be arbitrarily bad “away from the data”. • L1-regularization: – Simultaneous regularization and feature selection. – Robust to having lots of irrelevant features. • Next time: are we really going to use regression for classification? Ockham’s Razor vs. No Free Lunch • Ockham’s razor is a problem-solving principle: – “Among competing hypotheses, the one with the fewest assumptions should be selected.” – Suggests we should select linear model. • Fundamental trade-off: – If same training error, pick model less likely to overfit. – Formal version of Occam’s problem-solving principle. – Also suggests we should select linear model. • No free lunch theorem: – There exists possible datasets where you should select the green model. Regularizers and Sparsity • L1-regularization gives sparsity but L2-regularization doesn’t. – But don’t they both shrink variables to zero? • Consider problem where 3 vectors can get minimum training error: • Without regularization, we could choose any of these 3. – They all have same error, so regularization will “break tie”. • With L0-regularization, we would choose w2: Regularizers and Sparsity • L1-regularization gives sparsity but L2-regularization doesn’t. – But don’t they both shrink variables to zero? • Consider problem where 3 vectors can get minimum training error: • With L2-regularization, we would choose w3: • L2-regularization focuses on decreasing largest (makes wj similar). Regularizers and Sparsity • L1-regularization gives sparsity but L2-regularization doesn’t. – But don’t they both shrink variables to zero? • Consider problem where 3 vectors can get minimum training error: • With L1-regularization, we would choose w2: • L1-regularization focuses on decreasing all wj until they are 0. Sparsity and Least Squares • Consider 1D least squares objective: • This is a convex 1D quadratic function of ‘w’ (i.e., a parabola): • This variable does not look relevant (minimum is close to 0). – But for finite ‘n’ the minimum is unlikely to be exactly zero. Sparsity and L0-Regularization • Consider 1D L0-regularized least squares objective: • This is a convex 1D quadratic function but with a discontinuity at 0: • L0-regularized minimum is often exactly at the ‘discontinuity’ at 0: – Sets the feature to exactly 0 (does feature selection), but is non-convex. Sparsity and L2-Regularization • Consider 1D L2-regularized least squares objective: • This is a convex 1D quadratic function of ‘w’ (i.e., a parabola): • L2-regularization moves it closer to zero, but not all the way to zero. – It doesn’t do feature selection (“penalty goes to 0 as slope goes to 0”). Sparsity and L1-Regularization • Consider 1D L1-regularized least squares objective: • This is a convex piecwise-quadratic function of ‘w’ with ‘kink’ at 0: • L1-regularization tends to set variables to exactly 0 (feature selection). – Penalty on slope is 𝜆 even if you are close to zero. – Big 𝜆 selects few features, small 𝜆 allows many features. Sparsity and Regularization (with d=1)Why doesn’t L2-Regularization set variables to 0? • Consider an L2-regularized least squares problem with 1 feature: • Let’s solve for the optimal ‘w’: • So as λ gets bigger, ‘w’ converges to 0. • However, for all finite λ ‘w’ will be non-zero unless yTx = 0 exactly. – But it’s very unlikely that yTx will be exactly zero. Why doesn’t L2-Regularization set variables to 0? 58 • Small 𝜆 Big 𝜆 • Solution further from zero Solution closer to zero (but not exactly 0) Why does L1-Regularization set things to 0? • Consider an L1-regularized least squares problem with 1 feature: • If (w = 0), then “left” limit and “right“ limit are given by: • So which direction should “gradient descent” go in? Why does L1-Regularization set things to 0? 60 • Small λ Big λ • Solution nonzero Solution exactly zero (minimum of left parabola is past origin, but right parabola is not) (minimum of both parabola are past the origin) L2-regularization vs. L1-regularization • So with 1 feature: – L2-regularization only sets ‘w’ to 0 if yTx = 0. • There is a only a single possible yTx value where the variable gets set to zero. • And λ has nothing to do with the sparsity. – L1-regularization sets ‘w’ to 0 if |yTx| ≤ λ. • There is a range of possible yTx values where the variable gets set to zero. • And increasing λ increases the sparsity since the range of yTx grows. • Note that it’s important that the function is non-differentiable: – Differentiable regularizers penalizing size would need yTx = 0 for sparsity. L1-Loss vs. Huber Loss • The same reasoning tells us the difference between the L1 *loss* and the Huber loss. They are very similar in that they both grow linearly far away from 0. So both are both robust but… – With the L1 loss the model often passes exactly through some points. – With Huber the model doesn’t necessarily pass through any points. • Why? With L1-regularization we were causing the elements of ’w’ to be exactly 0. Analogously, with the L1-loss we cause the elements of ‘r’ (the residual) to be exactly zero. But zero residual for an example means you pass through that example exactly. 62 Non-Uniqueness of L1-Regularized Solution • How can L1-regularized least squares solution not be unique? – Isn’t it convex? • Convexity implies that minimum value of f(w) is unique (if exists), but there may be multiple ‘w’ values that achieve the minimum. • Consider L1-regularized least squares with d=2, where feature 2 is a copy of a feature 1. For a solution (w1,w2) we have: • So we can get the same squared error with different w1 and w2 values that have the same sum. Further, if neither w1 or w2 changes sign, then |w1| + |w2| will be the same so the new w1 and w2 will be a solution. Splines in 1D • For 1D interpolation, alternative to polynomials/RBFs are splines: – Use a polynomial in the region between each data point. – Constrain some derivatives of the polynomials to yield a unique solution. • Most common example is cubic spline: – Use a degree-3 polynomial between each pair of points. – Enforce that f’(x) and f’’(x) of polynomials agree at all point. – “Natural” spline also enforces f’’(x) = 0 for smallest and largest x. • Non-trivial fact: natural cubic splines are sum of: – Y-intercept. – Linear basis. – RBFs with g(ε) = ε3. • Different than Gaussian RBF because it increases with distance. http://www.physics.arizona.edu/~restrepo/475A/Notes/sourcea-/node35.html Splines in Higher Dimensions • Splines generalize to higher dimensions if data lies on a grid. – Many methods exist for grid-structured data (linear, cubic, splines, etc.). – For more general (“scattered”) data, there isn’t a natural generalization. • Common 2D “scattered” data interpolation is thin-plate splines: – Based on curve made when bending sheets of metal. – Corresponds to RBFs with g(ε) = ε2 log(ε). • Natural splines and thin-plate splines: special cases of “polyharmonic” splines: – Less sensitive to parameters than Gaussian RBF. http://step.polymtl.ca/~rv101/thinplates/ L2-Regularization vs. L1-Regularization • L2-regularization conceptually restricts ‘w’ to a ball. L2-Regularization vs. L1-Regularization • L2-regularization conceptually restricts ‘w’ to a ball. • L1-regularization restricts to the L1 “ball”: – Solutions tend to be at corners where wj are zero. Related Infinite Series video","libVersion":"0.2.1","langs":""}