{"path":".obsidian/plugins/text-extractor/cache/e9e7f6ae19813ebfbbf22c4dd6531134.json","text":"CPSC 320: Memoization and Dynamic Programming I Solutions ∗ You want to make change in the world, but to get started, you’re just .. . making change. You have an unlimited supply of quarters (25 cents), dimes (10 cents), nickels (5 cents), and pennies (1 cent, once upon a time). You want to make change for n \u0000 0 cents using the minimum number of coins. 1 Build intuition through examples. 1. Here is an optimal greedy algorithm to make change. Try it on at least one instance. function Greedy-Change(n) while n> 0 do if n \u0000 25 then give a quarter and reduce n by 25 else if n \u0000 10 then give a dime and reduce n by 10 else if n \u0000 5 then give a nickel and reduce n by 5 else give a penny and reduce n by 1 SOLUTION: 0 cents of change is a trivial instance; no coins are given. Also, 1, 5, 10, and 25 are trivial instances; the algorithm gives the coin matching its denomination. Here are some more examples of what the algorithm gives: • 2: 2 coins: 2 pennies • 4: 4 coins: 4 pennies • 6: 2 coins: 1 nickel, 1 penny • 16: 3 coins: 1 dime, 1 nickel, and 1 penny • 33: 5 coins: 1 quarter, 1 nickel, and 3 pennies • 142: 9 coins: 5 quarters, 1 dime, 1 nickel, 2 pennies 2. A few years back, the Canadian government eliminated the penny. Imagine the Canadian government accidentally eliminated the nickel rather than the penny. That is, assume you have an unlimited supply of quarters, dimes, and pennies, but no nickels. Adapt algorithm Greedy-Change for the case where the nickel is eliminated, by changing the code above. Then see if you can ﬁnd a counterexample to its correctness. SOLUTION: It’s straightforward to simply eliminate the nickel case from the greedy algorithm above. It’s not obvious that this breaks the algorithm, and yet it does! The ﬁrst of our small cases above that fails is the 33 case. Our algorithm now says this is 9 coins (1 quarter and 8 pennies), but the optimal solution is only 6 coins (3 dimes and 3 pennies). Working from there, we can see that the smallest failing case is n = 30, for which the optimal solution is 3 dimes rather than 1 quarter and 5 pennies. ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1 2 Write down a formal problem speciﬁcation. We’ll assume that a currency which includes the penny is ﬁxed, with coins of value 1,v1,. ..vk for some k \u0000 1. We’ll work with the currency 1, 10, 25 in what follows, but want an algorithm that can easily be adapted to work more generally. What is an instance of the making change problem? This is an example of a minimization problem; what quantity are we trying to minimize? SOLUTION: Since the currency is ﬁxed, an instance of the problem is a nonnegative integer n.We want to minimize the number of coins to make change for n. We’ll denote this minimum by C(n). Since the number of coins needed to make change is proportional to n, we’ll use n as a measure of the problem size (even though the number of bits needed to represent n is O(log n)). 3 Evaluate brute force. As is often the case, this approach will lead us to even better approaches later on. It will be helpful to write our brute force algorithm recursively. We’ll build up to that in several steps. 1. To make the change, you must start by handing the customer some coin. What are your options? SOLUTION: Our options are to hand out a quarter, a dime, or a penny. 2. Imagine that in order to make n = 81 cents of change using the minimum number of coins, you can start by handing the customer a quarter. Clearly describe the subproblem you are left with (but don’t solve it). You can use the notation above in the formal problem speciﬁcation. SOLUTION: If we start with a quarter, then we are left with the subproblem of determining the minimum number of coins needed to make change for 56 cents. Then the total number of coins that we use is 1+ C(56). 3. Even if we’re not sure that a quarter is an optimal move, we can still get an upper bound on the number of coins by considering the subproblem we are left with when we start with a quarter. What upper bound do we get on C(81)? SOLUTION: We get that C(81)  1+ C(56). 4. What other upper bounds on C(81) do we get if we consider each of the other \"ﬁrst coin\" options (besides a quarter), and the corresponding subproblem? SOLUTION: If we start with a dime, we are left with the subproblem of determining C(81 \u0000 10 = C(71).So, C(81)  C(71) + 1. With a penny: C(81)  C(81 \u0000 1) + 1 = C(80) + 1. 5. There are three choices of coin to give ﬁrst. Can you express C(81) as the minimum of three options? SOLUTION: Any way we give change must start with one of a quarter, a dime, or a penny. There- fore, whichever of these three is best is the optimal solution: C(81) = min {C(81 \u0000 25) + 1,C(81 \u0000 10) + 1,C(81 \u0000 1) + 1}. We can easily generalize that to a recursive formula for C(n) for suﬃciently large n: C(n)=min {C(n \u0000 25) + 1,C(n \u0000 10) + 1,C(n \u0000 1) + 1}. Notice that here we are using a recurrence to express the solution to a minimization problem. Recur- rences are very useful for this purpose, as well as expressing runtimes of (recursive) algorithms. 2 6. Now, consider the more general problem of making change when there are k +1 diﬀerent coins available, with one being a penny, and the remaining k coins having values v1,v2,. .., vk, all of which are greater than 1. Let C 0(n) be the minimum number of coins needed in this case. For suﬃciently large n, how can you express C 0(n) in terms of C 0() evaluated on amounts smaller than n? SOLUTION: Generalizing our previous recurrence, we get: C 0(n)= min {C 0(n \u0000 v1)+1,C 0(n \u0000 v2)+1,. .., C 0(n \u0000 vk)+1,C 0(n \u0000 1) + 1}. 7. Complete the following recursive brute force algorithm for making change: SOLUTION: Implemented inline below. function Brute-Force-Change(n) if n< 0 then return inﬁnity else if n =0 then return 0 else if n> 0 then return the minimum of: Brute-Force-Change(n \u0000 25)+ 1, Brute-Force-Change(n \u0000 10)+ 1, Brute-Force-Change(n \u0000 1)+ 1 8. Complete the following recurrence for the runtime of algorithm Brute-Force-Change: SOLUTION: For some constant c> 0, T (n)= c for n  0 T (n)= T (n \u0000 25) + T (n \u0000 10) + T (n \u0000 1) + c, otherwise. The constant c accounts for time needed to determine which of the three cases applies and, if in case 3, to to initiate the recursive calls and assemble the results of those calls. 3 9. Give a disappointing ⌦-bound on the runtime of Brute-Force-Change by following these steps: (a) T (n) is hard to deal with because the three recursive terms in part (8) above are diﬀerent. To lower bound T (n), we make them all equal to the smallest term. Complete the lower bound that we get for the recursive case when we do this: SOLUTION: As long as T is a non-decreasing function—which is often true for algorithms—we can say that T (n) \u0000 T (n \u0000 1) for suﬃciently large n. That means that T (n \u0000 1) \u0000 T (n \u0000 10) \u0000 T (n \u0000 25), which lets us rewrite the recursive case T (n)= T (n \u0000 25) + T (n \u0000 10) + T (n \u0000 1) + c as T (n) \u0000 3T (n \u0000 25) + c. (b) Now, draw a recurrence tree for the recurrence of part 9a and ﬁgure out its number of levels, work per level, and total work. SOLUTION: Here’s our tree: Here, the work at the leaves will dominate. (The work at any level is almost three times as much as the work at all previous levels.) We reach the leaves when n reaches one of our base cases: n \u0000 i ⇤ 25 ⇡ 0. Solving for i, we get i ⇡ n/25, which makes sense, as we’re going down by quarters as long as possible. Thus, the work in the leaves is 3n/25c =(31/25)nc ⇡ 1.045nc. While the base isn’t much larger than 1, that’s still exponential growth. For example, for n = 500, that’s already 3486784401c. For n = 1000, the coeﬃcient has about 20 digits. Clearly, this scales poorly. (And, our original algorithm is exponential with a much larger base.) [Note: For recurrences T (n) where there is just one term involving T on the right hand side, we could \"unroll\" the recurrence as follows: T (n) \u0000 3T (n \u0000 25) + c \u0000 3(3T (n \u0000 2 ⇤ 25) + c)+ c =32T (n \u0000 2 ⇤ 25) + 3c + c \u0000 ... \u0000 3iT (n \u0000 i ⇤ 25) + 3i\u00001c + .. . 3c + c =3iT (n \u0000 i ⇤ 25) + c i\u00001X j=0 3j. As in the recursion tree method, we see that we reach the base case when i = n/25,and so T (n) \u0000 c Pn/25 j=0 3j \u0000 3n/25, as before.] 4 10. Why is the performance so bad? Does this algorithm waste time trying to solve the same subproblem more than once? For n = 81, draw the ﬁrst three levels (the root at level 0 plus two more levels) of the recursion tree for Brute-Force-Change to assess this. Label each node by the size of its subproblem. Does any subproblem appear more than once? SOLUTION: Consider the ﬁrst three levels of the recursion tree for Brute-Force-Change(81): Notice the two nodes for n = 55 (in italics). The leftmost one appears as a child of the root’s left child, but then the same value appears under the root’s right child (and, although we didn’t draw enough of the tree to see it, it appears additional times in all three subtrees of the root). In fact, if we draw out the whole tree, node 55 appears 48 times in the recursion tree. (How do we know? That’s how many diﬀerent ways you can make the 26 cents in change that get us from 81 cents to 55 cents: 2 ways with a quarter and a penny, 28 ways with two dimes and six pennies, 17 ways with one dime and sixteen pennies, and 1 way with twenty-six pennies. Each way of making the change is a path from the root to a node labeled 55.) So, however much that node costs, we pay its cost 48 times. As we get deeper in the tree, the number of repeats of subtrees grows exponentially. We’re spending essentially all our time recomputing the optimal solution to problems we’ve already solved! (Even in these three levels, we can already see two other repeats, for n = 46 and n = 70.) 5","libVersion":"0.2.1","langs":""}