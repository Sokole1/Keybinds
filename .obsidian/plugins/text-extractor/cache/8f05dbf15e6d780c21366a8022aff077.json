{"path":".obsidian/plugins/text-extractor/cache/8f05dbf15e6d780c21366a8022aff077.json","text":"Test 2 solutions 1 The Master Theorem Which Θ bounds will the Master Theorem give for each of the following recurrence relations? 1. [3 marks] T (n) = { 8T (n/4) + n log n if n ≥ 4 Θ(1) if n ≤ 3 nlog4 8 n log2 n n log n The Master theorem can not be used to obtain a tight bound on T (n). We have a = 8, b = 4 and so logb a = log4 8 is between 1 and 2. Thus n log n ∈ O(nlog4 8−ε) for some small enough ε, meaning that we are in Case 1 of the Master theorem. 2. [3 marks] T (n) = { 13T (n/7) + n2 if n ≥ 7 Θ(1) if n ≤ 6 nlog7 13 n2 log n n2 The Master theorem can not be used to obtain a tight bound on T (n). We have a = 13, b = 7 and so logb a = log7 13 is between 1 and 2. Thus n2 ∈ Ω(nlog7 13−ε for some small enough ε, meaning that the only possible case is Case 3. Now af (n/b) = 13f (n/7) = 13n2/49 < δn2 for δ = 0.5, so Case 3 does apply. 2 Writing a recurrence Write a recurrence relation that describes the worst-case running time of the following algorithm as a function on n. To help you, we've provided a LaTeX template that you can cut and paste into the response ˝eld (you will still need to ˝ll in the actual answer). Assume that function square_root runs in constant time. Algorithm SSA(A, first, n) if n == 0 return 0 else if n == 1 return A[first] else if n == 2 return square_root(A[first] * A[first+1]) else threef = 3 * ⌊ n/5 ⌋ return square_root(SSA(A, first, threef) * SSA(A, first + threef, n - threef)) page 2 out of 5 Solution : T (n) = { Θ(1) if n ≤ 2 T (3⌊n/5⌋) + T (n − 3⌊n/5⌋) + Θ(1) if n ≥ 3 or, more simply but slightly less precisely, T (n) = { Θ(1) if n ≤ 2 T (3n/5) + T (2n/5) + Θ(1) if n ≥ 3 3 Solving a recurrence Using a method of your choice, give a tight ( Θ) bound on the function T (n) de˝ned by the following recurrence relation: T (n) = { T (3n/5) + T (4n/5) + n2 if n ≥ 5 Θ(1) if n ≤ 4 We use recursion trees. As shown in the ˝gure below, each level of the tree up to the level where the ˝rst leaf appears performs n2 works. Since the ˝rst leaf appears at level log5/3 n, this means T (n) ∈ Ω(n2 log5/3 n) = Ω(n2 log n). Below this level, each level does at most n2 work up to the level where the last leaf occurs. So T (n) ∈ O(n2 log5/4 n) = O(n2 log n). Combining these two results, we get T (n) ∈ Θ(n2 log n). 4 Highest Point on a Circle In this question, you are given n ≥ 3 points in the xy plane, all of which lie on a circle. The points are stored in an array P of points, indexed from P [0] to P [n − 1], in counter-clockwise order (the direction of the dashed, gray arrow in the picture). For example, here's an instance with n = 6: page 3 out of 5 P[0] P[1] P[2] P[3] P[4] P[5] Notice that the points are not guaranteed to be evenly spaced around the circle (although they could be). Also, note how P [0] might be any of the points (it's not the leftmost or rightmost or highest or lowest or anything), but from there, P [1], . . . , P [n − 1] are in counter-clockwise order going around the circle. And after P [n − 1], the next point going counter-clockwise around the circle is back to P [0]. Your task in this question is to complete the pseudocode below so that it correctly returns the index of the highest point , namely, the point in the array with the largest y-coordinate. For example, in the picture above, the code should return 4, because P [4] has the largest y-coordinate (it's the furthest towards the top of the page). Furthermore, the runtime of your completed pseudocode must be O(log n). Here are some tips that might make the pseudocode easier to write: ‹ Use the syntax P [i].x and P [i].y to refer to the x- and y-coordinates of the ith point P [i]. ‹ You may assume that no two points have the same x- or y-coordinates if you wish. ‹ You may assume in your pseudocode that array accesses \u0010wrap around\u0011 when the index goes negative or ≥ n, e.g., P [−1] is the same as P [n − 1], and P [n] is the same as P [0]. ‹ We have provided a helper function trend(int i) that takes an index i and returns TOP if P [i] is higher up (has a greater y-coordinate) than both P [i − 1] and P [i + 1]; BOTTOM if P [i] is lower than both P [i − 1] and P [i + 1]; UPWARD if P [i] is higher than P [i − 1] and lower than P [i + 1]; and DOWNWARD if P [i] is lower than P [i − 1] and higher than P [i + 1]. Intuitively, this function tells you the direction you are going at point P [i] if you are following the points around the circle in order. enum direction{TOP, BOTTOM, UPWARD, DOWNWARD}; direction trend(int i) { if (P[i].y < P[i-1].y) { if (P[i].y < P[i+1].y) return BOTTOM; else return DOWNWARD; } else { if (P[i].y > P[i+1].y) return TOP; else return UPWARD; } } ‹ We've also provided more than enough base cases in the pseudocode, so you can concentrate on the dividing-and-conquering instead of the details of the base cases. page 4 out of 5 1. [12 marks] Here's the start of the main pseudocode. Fill in the missing parts so that your code ˝nds the highest point and runs in O(log n) time. (Hint: If i < j and trend (i) is UPWARD and trend (j) is DOWNWARD, what can you conclude about the the index of the highest point? What other cases do you need to handle?) int find_top(int low, int high) { // You should maintain the invariant that low<=high and // that the point with the highest y-coordinate is among P[low..high]. // So, to find the top point among all of them, the top-level call to // this function is find_top(0,n-1). // Base Cases if (trend(low)==TOP) return low; if (trend(high)==TOP) return high; // YOUR CODE STARTS HERE! Solution : // The key insight is that the trend value will always go from // BOTTOM to a bunch of UPWARDs, then TOP, and then a bunch of DOWNWARDS, // and then repeating as you go around the circle. // This means we can use binary search to find the TOP, // and get the O(log n) runtime. // The main difficulty is that you don't know where in this cycle we are, // so there are many special cases to think about. int mid = (low+high)/2; if (trend(mid)==TOP) return mid; // Eliminates some boundary cases. if ((trend(low)==BOTTOM) || (trend(low)==UPWARD)) { if (trend(mid)==DOWNWARD) { // Highest point definitely in P[low+1..mid-1] return find_top(low+1,mid-1); } else { // trend(mid) must be UPWARD // The tricky part here is determining whether all points P[low..mid] // are UPWARD, in which case the TOP is in the other half, // or if P[low..mid] wraps all the way around the circle. if (P[low].y > P[mid].y) { // We must have wrapped-around, since P[mid] is lower than P[low] // Therefore, TOP must be in this range. return find_top(low+1,mid-1); } else { // We didn't wrap around, so TOP must be in other half. return find_top(mid+1,high-1); } } page 5 out of 5 } else { // trend(low) is DOWNWARD if ((trend(mid)==DOWNWARD) || (trend(mid)==BOTTOM)) { // Similar to above, we need to distinguish whether P[low..mid] is all // DOWNWARD or if it wrapped. // (If trend(mid) is BOTTOM, then we know we didn't wrap, so we could // have split that case out, but this is more symmetric.) if (P[low].y < P[mid].y) { // We must have wrapped-around, since P[mid] is higher than P[low] // Therefore, TOP must be in this range. return find_top(low+1,mid-1); } else { // We didn't wrap around, so TOP must be in other half. return find_top(mid+1,high-1); } } } else { } else { // trend(mid) must be UPWARD // Highest point definitely in other half. return find_top(mid+1,high-1); } } }","libVersion":"0.2.1","langs":""}