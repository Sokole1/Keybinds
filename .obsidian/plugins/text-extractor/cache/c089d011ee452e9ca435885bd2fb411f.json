{"path":".obsidian/plugins/text-extractor/cache/c089d011ee452e9ca435885bd2fb411f.json","text":"CPSC 320 2023W1: Assignment 1 Solutions 3 Matching Preferences Here is an instance of the SMP (stable matching problem) with two applicants and two employers that has at least two stable solutions: e1: a1, a2 a1 : e2, e1 e2: a2, a1 a2 : e1, e2 The matching {(e1, a1), (e2, a2)} is stable since both employers are matched with their top choice. Also the matching {(e1, a2), (e2, a1)} is stable since both applicants are matched with their top choice. The matching {(e1, a1), (e2, a2)} is best for both employers, while matching {(e1, a2), (e2, a1)} is best for both applicants. More generally, let I be an SMP instance with (at least) two diﬀerent stable matchings M and M ′. We say that employer e prefers matching M over M ′ if e prefers its match in M over its match in M ′. That is (using notation from the worksheet) if (e, a) ∈ M and (e, a′) ∈ M ′, then a >e a′. 1. (3 points) Show an instance of SMP with four applicants and four employers, and show two stable matchings M and M ′ for this instance, such that two employers prefer M to M ′ while the remaining two employers prefer M ′ to M . Hint: Build on the example given above. (Make sure to provide a short justiﬁcation of your answer.) SOLUTION: The instance I is e1: a1, a2, a3, a4 a1 : e2, e1, e3, e4 e2: a2, a1, a3, a4 a2 : e1, e2, e3, e4 e3: a3, a4, a1, a2 a3 : e4, e3, e1, e2 e4: a4, a3, a1, a2 a4 : e3, e4, e1, e2 Let matchings M and M ′ be M = {(e1, a1), (e2, a2), (e3, a4), (e4, a3)} M ′ = {(e1, a2), (e2, a1), (e3, a3), (e4, a3)} Both matchings are stable since in each pairing either the applicant or the employer is matched with their ﬁrst-ranked choice. Also, employers e1 and e2 prefer M since they are matched with their highest-ranked applicants, while employers e3 and e4 prefer M ′ for the same reason. 2. (1 point) Let G(I, M, M ′) be the bipartite graph whose nodes are employers and applicants of I, and with an edge between e and a if either (e, a) ∈ M or (e, a) ∈ M ′. Is the graph G(I, M, M ′) for your SMP instance of part 1 connected? Give a short justiﬁcation. (Note: While this question refers to graphs, you don’t need any knowledge of graph algorithms to complete the question.) 1 SOLUTION: The graph is not connected, since the nodes e1, e2, a1, a2 are disconnected from the nodes e3, e4, a3, a4. 3. (2 points) In this and the subsequent parts of the problem let I be an instance with n ≥ employers and n applicants, with distinct stable matchings M and M ′. Without loss of generality, let e1 be an employer that prefers M over M ′, and let e1 be matched with a1 in M , that is (e1, a1) ∈ M . Let e2 be the employer matched with a1 in M ′, and let a2 be the applicant matched with e2 in M . That is, we have: M M ′ (e1, a1) (e1, ??) (e2, a2) (e2, a1) . . . . . . Show that e2 >a1 e1 and that a2 >e2 a1. SOLUTION: • e2 >a1 e1: Suppose to the contrary that a1 prefers e1 to e2. Then, since e1 prefers a1 to its match in M ′, (e1, a1) is an instability for M ′. So M ′ is not stable, contradiction. • a2 >e2 a1: Suppose to the contrary that e2 prefers a1 to a2. Then, since by the previous fact, a1 prefers e2 to e1, M is not stable, contradiction. 4. (2 points) Now suppose that there are i distinct employers e1, e2, . . . ei, and i distinct applicants a1, a2, . . . ai, such that in the matchings we have: M M ′ (e1, a1) (e1, ??) (e2, a2) (e2, a1) . . . . . . (ei−1, ai−1) (ei−1, ai−2) (ei, ai) (ei, ai−1) Suppose furthermore that e1, e2, . . . ei−1 prefer their matches in M to their matches in M ′. Show that ai−1 must prefer ei to ei−1 and furthermore, that ei must prefer ai to ai−1. SOLUTION: First, suppose to the contrary that ai−1 prefers ei−1 to ei. Then, since ei−1 prefers ai−1 to its match in M ′, M ′ is not stable, contradiction. Second, suppose to the contrary that ei prefers ai−1 to ai. Then, since we have just shown that ai−1 prefers ei to ei−1, M is not stable, another contradiction. 5. (3 points) Now, suppose that the graph G(I, M, M ′) is connected. Show that if one employer prefers M over M ′, then it must be the case that all employers prefer M over M ′. SOLUTION: Without loss of generality, let e1 prefer its match in M with its match in M ′, and let (e1, a1) be in M . Also without loss of generality, let e2 be matched with a1 in M ′ and let e2 be matched with a2 in M . Continuing inductively in this way, once e1, . . . , ei−1 and a1, . . . ai−1 are deﬁned, let ei be the employer matched with ai−1 in M ′ and let ai be the match of ei in M . If i < n, then it cannot be that ai = a1; otherwise the subgraph of G(I, M, M ′) involving 2 e1, . . . , ei, a1, . . . ai−1 is disconnected from the remaining nodes, contradicting our assumption that G(I, M, M ′) is connected. Therefore, e1 must be matched with an. From part 4, we see by induction that since e1 prefers a1 its match in M to an, its match in M ′ (the base case), and also for every i > 1, ei must prefer ai, its match in M , to ai−1, its match in M ′ (the inductive step). 3 4 Recursive Permutation Generation In this problem you’ll show that the recursive permutation generation algorithm from the ﬁrst tutorial does generate all permutations of the numbers in an array. Here is the algorithm again. 1: function Generate-All-Permutations(p[1..n], i) 2: ▷ p[1..n] contains n distinct integers, 1 ≤ i ≤ n 3: if i = 1 then 4: return p[1..n] 5: else 6: for j from i downto 1 do 7: swap(p[i],p[j]) 8: Generate-All-Permutations(p[1..n], i − 1) 9: swap(p[i],p[j]) For a set S of i distinct numbers and a sequence s of additional distinct numbers, let permut(S, s) be the set of all i! permutations obtained by permuting the numbers in S, and then appending the sequence of numbers s. For example, if n = 4, S = {1, 3} and s = 4, 2 then permut(S, s) = {(1, 3, 4, 2), (3, 1, 4, 2)}. When the sequence s is empty we denote it by ϵ and we’ll shorten the notation by writing permut({a1, a2, . . . , ai}) to mean permut({a1, a2, . . . , ai}, ϵ). 1. (2 points) Give a short explanation as to why, for any i in the range 2 ≤ i ≤ n, permut({a1, a2, . . . , ai}, ai+1, ai+2, . . . , an) is the same as the set ∪1≤j≤ipermut({a1, a2, . . . , aj−1, aj+1, . . . , ai}, aj, ai+1, . . . , an). SOLUTION: The set of all all permutations in permut({a1, a2, . . . , ai}, ai+1, ai+2, . . . , an) can be partitioned into i subsets, with the jth of these subsets containing those permutations ending in aj, ai+1, ai+2, . . . , an. There are (i − 1)! permutations in each subset. The set permut({a1, a2, . . . , aj−1, aj+1, . . . , ai}, aj, ai+1, . . . , an) generates exactly the set of permutations in the jth subset of the partition. So the untion of these sets is exactly the set permut({a1, a2, . . . , ai}, ai+1, ai+2, . . . , an). 4 2. (5 points) Use induction on i to prove the following claim: Claim: Let a1, a2, . . . , an be the sequence of distinct numbers in array p[1..n]. Then for any i, 1 ≤ i ≤ n, Generate-All-Permutations(p[1..n], i) returns exactly the i! permutations in the set permut({a1, a2, . . . , ai}, ai+1, ai+2, . . . , an). SOLUTION: Base case: The base case is when i = 1. In this case we have that permut({a1, a2, . . . , ai}, ai+1, ai+2, . . . , an) = permut({a1}, a2, . . . , an) = {a1, a2, . . . , an}. Also, when i = 1, the algorithm executes line 4, returning the single permutation a1, a2, . . . , an as required. Inductive step: Let 2 ≤ i ≤ n. Suppose that the claim is true for i − 1 (this is the inductive hypothesis). We’ll show that the claim is true for i. Since i > 1, the call Generate-All-Permutations(p[1..n], i) enters the for loop at line 6. Within the for loop, the algorithm ﬁrst swaps p[i] with p[j] at line 7. Assuming that the array elements are in their original order a1, a2, . . . , an before the swap, the ﬁrst i − 1 elements in the array after the swap are exactly those in the set {a1, a2, . . . , aj−1, aj+1, . . . , ai}, and the remaining sequence of numbers, in order, are aj, ai+1, . . . , an. By the induction hypothesis, the recursive call Generate-All-Permutations(p[1..n], i − 1) at line 8 produces the set of permutations permut({a1, a2, . . . , aj−1, aj+1, . . . , ai}, aj, ai+1, . . . , an). By the claim proved in the tutorial, line 9 then restores the order of the array entries to a1, . . . , an. As a result, since the range of j in the for loop is between i and 1, the set of all permutations produced when the for loop is executed is ∪1≤j≤ipermut({a1, a2, . . . , aj−1, aj+1, . . . , ai}, aj, ai+1, . . . , an). By the previous part of this problem, this is exactly the set permut({a1, a2, . . . , ai}, ai+1, ai+2, . . . , an). 5 5 A Number Sieve The following Number-Sieve algorithm repeatedly scans an array containing the numbers 1,2, . . . , n in order. On the ﬁrst iteration of the while loop, the algorithm removes every second number, by replacing the number with −1. On subsequent iterations every third number from the remaining set of numbers (not counting the −1’s) is removed; then every fourth number and so on. The algorithm terminates once no number is removed on some iteration. We’ll call the numbers that are never removed the lucky numbers. The ﬁrst few lucky numbers in a suﬃciently long array are 1, 3, 7, 13, 19. 1: function Number-Sieve(p[1..n]) 2: ▷ p[1..n] initially contains the numbers 1, 2, . . . , n in this order 3: done ← false 4: k = 1 5: while not done do 6: k = k + 1 7: j ← 0 8: done ← true 9: for i from 1 to n do ▷ Remove every kth of the remaining positive numbers in p 10: if p[i] ̸= −1 then 11: j ← j + 1 12: if j == k then 13: p[i] ← −1 14: j ← 0 15: done ← false 16: return the list of positive numbers remaining in p 1. (4 points) One nice feature of big-O analysis of algorithm runtime is that we can often ignore annoying ﬂoors and ceilings. Show that if we ignore these, then for k ≥ 1 there are n/k positive numbers remaining in the array at the start of the kth iteration of the while loop (assuming that the algorithm has not already terminated). SOLUTION: We can show this by induction. The base case is when k = 1, in which case all n numbers of the array are positive by the initial condition expressed in line 2. Let k ≥ 1 and suppose that n/k positive numbers remain in the array at the start of the kth iteration of the while loop. In the (k +1)st iteration, lines 10-14 remove one number from every k + 1 successive positive numbers. Ignoring ﬂoors and ceilings, the total number of positive numbers removed is therefore n/(k(k + 1)), and the quantity of positive numbers remaining is n/k − n/(k(k + 1)) = n/(k + 1). 2. (3 points) What is the runtime of Number-Sieve, as a function of n? SOLUTION: Each iteration of the while loop takes Θ(n) time, since each of the lines 6-8, and also lines 11-15 inside the for loop, take O(1) time and the for loop (line 9) has n iterations. The while loop terminates when no positive number is removed on some iteration. This happens on the ﬁrst iteration k such that there are fewer than k positive numbers left in the array at the start of iteration k. By the previous part, if we ignore ﬂoors and ceilings, there are n/k positive numbers in the array at the start of iteration k. So the while loop terminates when n/k < k. Solving for k, and again ignoring ﬂoors and ceilings, we get k = √n. Since each iteration takes Θ(n) time and there are roughly √n iterations, the overall runtime is Θ(n√n). 6 6 Computing Averages Let p[1..n] be a 1D array of real-valued numbers. We want to create a 2D n × n array P , where P [i][j] = 0 if j < i and otherwise P [i][j] = µ(i, j), where µ(i, j) is the average of the numbers in the sub-array p[i..j]. That is, if i ≤ j, then µ(i, j) = (p[i] + p[i + 1] + . . . + p[j])/(j − i + 1). 1. (3 points) Here is one algorithm that creates P and computes all entries in the 2D array P [1..n][1..n]. Explain why the runtime is Θ(n3). 1: function Compute-Averages(p[1..n]) 2: create the 2D (uninitialized) array P [1..n][1..n] 3: for i from 1 to n do 4: for j from 1 to n do 5: if j < i then 6: P [i][j] ← 0 7: else 8: P [i][j] ← (p[i] + p[i + 1] . . . p[j])/(j − i + 1) SOLUTION: This algorithm runs in time O(n3). There are n2 iterations of the outer two for loops. When i ≤ j, the time for line 8 is O(j − i), since j − i additions are needed, and when i > j the time needed is O(1) (lines 5 and 6). In both cases the time is O(n). Since j − i ≤ n, the total runtime is O(n3). Next we show that the runtime is Ω(n3). When i is in the range 1 to n/4 and j is in the range 3n/4 to n, then line 7 takes Θ(j − i) = Θ(n) time, since i − j ≥ n/2. The number of iterations of the outer loop for i in the range 1 to n/4 is n/4, and also the number of iterations of the inner loop for j in the range 3n/4 to n range is roughly n/4. So the runtime just for the iteration where i and j are in the above ranges is (n/4)(n/4)Θ(n) = Θ(n3). The total runtime over all iterations is at least this quantity, and so is Ω(n3). From these two parts we have that the runtime is Θ(n3). 2. (2 points) Modify the above algorithm to obtain an algorithm that runs in time Θ(n2) time. You do not need to provide a justiﬁcation of your runtime or the correctness of your algorithm. SOLUTION: The idea is to use previously computed entries of P to help compute new entries more eﬃciently. 1: function Compute-Averages(p[1..n]) 2: for i from 1 to n do 3: for j from 1 to n do 4: if j < i then 5: P [i][j] ← 0 6: else if i == j then 7: P [i][j] ← p[i] 8: else ▷ i < j 9: P [i][j] ← (P [i][j − 1] × (j − i)) + p[j])/(j − i + 1) 7","libVersion":"0.2.1","langs":""}