{"path":".obsidian/plugins/text-extractor/cache/e2e6ad51947b01bf0166239f2c1575e9.json","text":"4 Edge Loads Revisited Recall the edge load problem from Assignment 2. An instance is an undirected, unweighted, con- nected, graph G = (V, E), with n nodes and m edges. For two nodes z and y let the (z,y)-edge load of an edge e in the graph, which we’ll denote by load(z,y, €), be the number of shortest paths between z and y that pass through e. Let load(e) be the sum of load(z,y, €), taken over all pairs of nodes (z,y). Example: For the graph on the left below, you saw that for example, if e = (1,6) then load(1,7,¢) = 2, with the two paths being 1,6,3,7 and 1,6,4,7, and also load(1,8,e) = 2. A BFS tree for this graph, rooted at node 1, is shown on the right, with dashed edges added, which may be useful for later parts of the problem. You also saw in Assignment 2 that we can calculate load(e) for all e by summing up the quantity load(z, y, €) for all pairs of nodes (z,y), but the time is O(n?m). Here you’ll develop a faster approach to calculating all of the quantities load(e). As usual, we let ds[v] denote the depth of node v in a BFS tree rooted at s, and we will also let d; = max,cy ds[v]. You can assume that these quantities have been precomputed and the algorithms that follow have access to these quantities. 1. (1 mark) Let load(s,e) be the number of shortest paths from s to any other node that goes through edge e. That is, load(s,e) = Z load(s,y, €). yev Let e = (u,v), and assume that u is closer to s than v, i.e. ds[u] < ds[v]. The paths counted in load(s,e) are comprised of an \"upper path\", from s to u, followed by v, and finally a \"lower path\", from v to some destination node. For our example graph, if e = (2,3), then load(1, e) = 3, since there is one shortest path from 1 to 3, one from 1 to 7, and one from 1 to 8 that all go through edge (2, 3). (a) If e = (6,4) what is load(1,e)? Oo O1 O 2 O3 O 4 (b) If e = (6,5) what is load(1,¢€)? Oo O1 O 2 O 3 O 4","libVersion":"0.2.1","langs":"eng"}