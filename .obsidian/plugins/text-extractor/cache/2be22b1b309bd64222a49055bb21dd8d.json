{"path":".obsidian/plugins/text-extractor/cache/2be22b1b309bd64222a49055bb21dd8d.json","text":"R2.1. Measuring Pointer Offsets in C Consider the following two struct definitions: struct sl { uint16_t sf1[5]; uint8_t *sf2; }; struct s2 { struct sl f1; uint32_t f2; struct s2 xf3; }; And these definitions: struct sl basel[9]; struct s2 base2[4]; For each of the following problems, indicate how many bytes larger than the base pointer being used is the expression. E.g., for ((uint8_t *)basel)+1, you would write 1 since the result is an address 1 byte larger than basel's address. If there is not enough information to know the answer, leave the answer blank. Assume we are using our typical 64-bit machine. 1. ((struct s2x) basel) + 2 integer bytes @ 2.&((base2 + 1)->f1l.sf1[0]) integer bytes @ 3. &(base2[3].3) integer bytes @ 4.base2[3].f3 integer bytes @ 5. ((uint16_tx) base2) + 5 integer bytes @ 6. &(base2[1].f1.sf2) integer bytes @ Save & Grade Single attempt Additional attempts available with new variants @","libVersion":"0.2.1","langs":"eng"}