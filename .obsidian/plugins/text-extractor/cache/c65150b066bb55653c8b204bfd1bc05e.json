{"path":".obsidian/plugins/text-extractor/cache/c65150b066bb55653c8b204bfd1bc05e.json","text":"1 Exhibition guarding In the Exhibition Guarding Problem, we are given a line L that represents a long hallway in a gallery; assume that the line has a left and right end. We are also given an unordered array X of real numbers that represent the positions of precious objects in this hallway, where a position marks the distance from the left end of the line. A guard at a position p on the line can protect objects within distance d of p, that is, objects in the range [p — d,p + dJ. 1. Here is a greedy algorithm that finds the minimum number of guard positions needed to protect all objects in X. The algorithm ensures that the leftmost guard protects the object at the leftmost position, while choosing the leftmost position to be as far to the right as possible, so the guard protects as many other objects as possible. Then the algorithm is called recursively with the remaining unguarded objects. The following pseudocode captures this idea. procedure PLACE-GUARDS(X[1..n],d) > X contains positions of n > 0 objects on a line > d is the distance (both to the left and right) that a guard can protect sort X in increasing order return PLACE-GUARDS-HELPER(X [1..n], d) procedure PLACE-GUARDS-HELPER(X [1..n], d) if n == 0 then return the empty set > there are no objects, so no guard is needed else p+ X[1]+d > place a guard as far right as possible while protecting X 1] > skip the other objects protected by this guard 142 while i <n and X[i] < p+d do i—i+1 return {p} + PLACE-GUARDS-HELPER(X [i..n], d) 2. What is the running time of your algorithm? 3. Briefly justify why your algorithm produces a wvalid solution, i.e., a set of guard positions that ensures that all objects are guarded. (Do not concern yourself yet with whether the set of positions is minimized.)","libVersion":"0.2.1","langs":"eng"}