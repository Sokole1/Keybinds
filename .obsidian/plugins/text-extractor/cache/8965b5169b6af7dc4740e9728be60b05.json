{"path":".obsidian/plugins/text-extractor/cache/8965b5169b6af7dc4740e9728be60b05.json","text":"Pl4] Pl3] - Plo] Pl P2 u P3| Notice that the points are not guaranteed to be evenly spaced around the circle (although they could be). Also, note how P[0] might be any of the points (it’s not the leftmost or rightmost or highest or lowest or anything), but from there, P[1],..., P[n — 1] are in counter-clockwise order going around the circle. And after P[n — 1], the next point going counter-clockwise around the circle is back to P[0]. Your task in this question is to complete the pseudocode below so that it correctly returns the index of the highest point, namely, the point in the array with the largest y-coordinate. For example, in the picture above, the code should return 4, because P[4] has the largest y-coordinate (it’s the furthest towards the top of the page). Furthermore, the runtime of your completed pseudocode must be O(logn). Here are some tips that might make the pseudocode easier to write: e Use the syntax Pli].z and Pli].y to refer to the z- and y-coordinates of the ith point P[i]. e You may assume that no two points have the same z- or y-coordinates if you wish. e You may assume in your pseudocode that array accesses “wrap around” when the index goes negative or >n, e.g., P[—1] is the same as P[n — 1], and P[n] is the same as P[0]. e We have provided a helper function trend(int i) that takes an index ¢ and returns TOP if P[i] is higher up (has a greater y-coordinate) than both P[i — 1] and P[i + 1]; BOTTOM if P[i] is lower than both P[i — 1] and P[i 4 1]; UPWARD if P[i] is higher than P[i — 1] and lower than P[i + 1]; and DOWNWARD if P[i] is lower than P[i — 1] and higher than P[i + 1]. Intuitively, this function tells you the direction you are going at point P[i] if you are following the points around the circle in order. enum direction{TOP, BOTTOM, UPWARD, DOWNWARD}; direction trend(int i) { if (P[il.y < P[i-1].y) { if (P[i].y < P[i+1].y) return BOTTOM; else return DOWNWARD; } else { if (P[i]l.y > P[i+1].y) return TOP; else return UPWARD; } } e We've also provided more than enough base cases in the pseudocode, so you can concentrate on the dividing-and-conquering instead of the details of the base cases.","libVersion":"0.2.1","langs":"eng"}