{"path":".obsidian/plugins/text-extractor/cache/9cf412396a239675fa7c08e26e80d57d.json","text":"CPSC 320 2023W1: Tutorial 5 1 A spanning algorithm Let G = (V, E) be a connected, undirected graph with n ≥ 2 nodes and m weighted edges, where w(e) denotes the weight of edge e. The following algorithm is similar but not identical to Kruskal’s minimum spanning tree algorithm (if you have not read that yet, you should still be able to complete these problems). procedure Spanning(G = (V, E), w()) G′ = (V, E′) where E′ = ∅ ▷ initially there are no edges in the output produced while G′ is not connected do E-new = ∅ for each connected component C of G′ = (V, E′) do choose any edge e = (u, v) ∈ E of minimum weight w(e) that connects a node u in C to a node v that is not in C E-new = E-new ∪{e} E′ = E′ ∪ E-new ▷ edges in E-new are added to the output return G′ = (V, E′) 1. For the following graph, when the edge weights are all 1, describe edge choices in the for loop of the ﬁrst iteration of the while loop, which ensure that the algorithm halts after that ﬁrst iteration. 2. For the same graph above, describe alternative edge choices in the ﬁrst iteration of the while loop, that result in more than one iteration of the while loop. 3. Consider the“line” graph with nodes 1,2, ...n and edges (1, 2), (2, 3), ..., (n − 1, n). On this graph, how many iterations of the while loop will be executed in the worst case? 4. For the same line graph as in the previous part, how many iterations of the while loop will be executed in the best case? 5. Provide an example of a graph G and weight function w() on which the algorithm may not produce a tree. 1 2 Knapsack with Structured Weights: Part 2 Let’s continue with the Knapsack problem we saw in Tutorial 5. A problem instance is a set of n items, numbered 1, ..., n. Each item i has a positive weight wi > 0 and a positive value vi > 0. Furthermore, we’re given an overall weight capacity C. The problem is to select a subset S ⊆ {1, ..., n} that maximizes the total value of S, but keeps the total weight below C. Formally, we want to maximize V (S) = ∑ i∈S vi, subject to ∑ i∈S wi ≤ C. We’re considering the special case of the problem where the capacity as C is 1, and restrict the weights to be either 1/2, 1/4, 1/8, or 1/16. We showed last time that if we sort the 1/16-weight items in decreasing order of value, and then pair up the items in sequence (i.e. the 1st and 2nd items form a pair, then the 3rd and 4th items, then the 5th and 6th, etc.). then there is an optimal solution that uses that uses the c highest-valued pairs, for some c. Now here’s the key idea of our greedy algorithm. Given an instance I of the problem, create a new instance I ′ as follows. Initially I ′ = I. Sort the 1/16-weight items in decreasing order of value, and pair them up. Now, for each pair of items (i, j) delete the items from I ′ and replace them with a new item whose weight is wi + wj and whose value is vi + vj. Instance I ′ has no 1/16-weight items. There’s a natural correspondence between solutions for I and I ′, where each ”paired” item in a solution S′ for I ′ is replaced by the two individual items in the corresponding solution S for I, and vice versa. Note also that corresponding solutions S and S′ have the same total value, i.e., V (S) = V (S′) Use this to show that: 1. The value of an optimal solution for instance I is less than or equal to the value of an optimal solution for instance I ′. 2. The value of an optimal solution for instance I ′ is less than or equal to the value of an optimal solution for instance I. Given an original problem instance, we’ve seen how to eliminate the 1/16-weight items to create an equivalent problem without 1/16-weight instances. 3. How do we now solve the resulting problem instance that has no 1/16-weight items? 2","libVersion":"0.2.1","langs":""}