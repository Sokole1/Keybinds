{"path":".obsidian/plugins/text-extractor/cache/786c7f30a75b8fbe022f01b52c03fc96.json","text":"3 Lighting the Beacons An instance of the \"Lighting the Beacons\" problem from Tutorial 8 is specified by: (i) A sorted table D[1..n] of distances (in kilometers) from a source hill 1 to subsequent hills in a line that lead to a target hill n > 1. All entries of D are distinct, and successive hills are at most 100km apart. (ii) A table P[1..n] of the probabilities that a beacon on each hill will successfully transmit the signal to a successor that is within 100km, with P[1] = 1. A walid solution to the problem is a chain of hills from the source but not including the target, with successive hills no more than 100km apart and the last hill in the chain no more than 100km from the target. An optimal solution is a valid solution such that if the source beacon is lit, the signal will be received at the target (hill n) with maximum probability. Note that the guards assigned to a beacon in a chain only light their beacon if they see the signal from the preceding beacon in the chain, even if an earlier beacon in the chain might be visible within 100km. As a result, the probability that a signal reaches the target along a valid chain is the product of the transmission probabilities of beacons in the chain. Let OPT(j) represent the maximum probability that a signal is transmitted from the source to beacon j. In the tutorial you developed the following recurrence relation for OPT(j): . 1 ifj=1 OPT(j) = ’ . . A N { maxicjr<j1{OPT(j') x p(i\")}, if j > 1. Here, i is the index of the furthest hill preceding j that is still within 100km of hill 7, so D[j]— D[i] < 100, but D[j] — D[i — 1] > 100 or i = 1. 1. (4 marks) Using the recurrence relation, develop a memoized algorithm for computing OPT'(n). Remember that a memoized algorithm always has a recursive helper function. procedure MEMO-BEACON(D[1...n], P[l..n]) >n>1 > initialization of a solution array goes here > a call to the recursive helper function goes here procedure MEMO-BEACON-HELPER(D[1...j], P[l...j]) »>j>1 > put pseudocode for the helper function here 2. (5 marks) Using the recurrence relation, develop a dynamic programming algorithm for com- puting OPT (n). 3. (2 marks) Suppose that the distinct entries in array D are all integers. In this case, if i is the index of the furthest hill preceding j that is still within 100km of hill j, there are at most 100 possible hills between i and j (including i and j themselves). We consider 100 to be a constant, i.e., 100 = O(1). Give a big-O-bound on the runtime of your dynamic programming algorithm from part [2]in this case, and briefly justify your bound.","libVersion":"0.2.1","langs":"eng"}