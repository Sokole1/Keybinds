{"path":".obsidian/plugins/text-extractor/cache/54a1de65476864d229a81c5d1a3c9f45.json","text":"3. (4 points) Here is an inductive definition for ¢(z,v): If = v then there is exactly one shortest path from z to z, so ¢(z,z) is 1. Otherwise, c(z,v) = Z c(z,u). u| (u,v) € E, and do(u] = do[v] — 1 Intuitively, in the bfs tree rooted at z, we count the number of shortest paths to all nodes u at level d[v] — 1, such that there is an edge (either a tree edge or a dashed edge) from u to v. Provide code in the spaces indicated below, to obtain an algorithm that computes ¢(z,v) for all pairs of nodes. For each node z, this code first initializes ¢(z,v) for all v, and then calls a version of breadth first search that your selection will modify. Your algorithm should run in ©(nm) time. 2 procedure COUNT-SHORTEST-PATHS(G) > G is an undirected, connected graph with at least one node > compute ¢(z,v), the number of shortest paths, from z to v, for all pairs of nodes (z,v) for all z € V do > add code here to initialize c(z,v) for all v € V: call MODIFIED-BFS(z) procedure MODIFIED-BFS(s) for each v € [1..n] do dg[v] + o0 Lo + {s}; ds[s] - 0;d + 1 while L4 #V do Ly« 0 for each u € Ly—; do for each v adjacent to u do if dy[v] == oo then add v to Lg; ds[v] + d; plv] +u > add your code here: d<d+1","libVersion":"0.2.1","langs":"eng"}