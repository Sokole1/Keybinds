{"path":".obsidian/plugins/text-extractor/cache/f7a25fbc9020045ee56a0ba4e5abe342.json","text":"Module 2: Testing CPSC 310Nick Bradley & Katharine K err F or personal use only, please do not distribute on non-UBC domains. CPSC 310: Introduction to Software Engineering ● Explain diﬀerent kinds of tests ● Explain the diﬀerence between black bo x and glass bo x testing, both in terms of when they happen, and how the tests are devised. ● Explain how tests for a par ticular version of a system become regression tests as the system evolves. ● P roperly form a test with the right par ts (setup, call, check). ● Explain why line coverage is often considered insuﬃcient as a measure of suite completeness. ● Create test suites that achieve line and branch coverage, and that achieve boundar y and equivalence class testing. ● Assess the above kinds of coverage in a given test suite. ● Explain why mock objects are helpful. ● P rovide the design/implementation for a mock object given the component to test and a “real” component’s inter face. ● Explain mutation testing. ● Suggest mutants given some code, or ﬁnd mutants that some tests might not ﬁnd. ● Explain how to achieve the various kinds of testability and be able to spot when they are not achieved. ● Explain why TDD aﬀords testability. ● Explain and identify architectural choices to aﬀord improved testability. ● Explain four phase test and given-when-then ● Explain fuzz testing. ● Contrast random fuzzing, generator-based fuzzing, and mutational fuzzing. ● Describe diﬀerent kinds of asser tions and justify their beneﬁts and tradeoﬀs. T estingExaminable skills CPSC 310: Introduction to Software Engineering L ecture L earning Outcomes By the end of this lecture, you will be able to answer: ● Why do we test? ● When do we write tests? ● How do we classify tests? ● How do we create an eﬀective test suite? ● What are ethics in software engineering? ● How does ethics apply to testing?4 “Testing shows the presence , not the absence of bugs.” — Dijkstra Testing Testing Intro CPSC 310: Introduction to Software Engineering Why test software? The Ariane 5 …. http://youtu.be/gp_D8r-2hwk CPSC 310: Introduction to Software Engineering Sadly, the primar y cause was found to be a piece of softwar e which had been r etained fr om the pr evious launchers syst ems and which was not r equir ed during the ﬂight of Ariane 5. The software was used in the Iner tial Reference S ystem (SRI) to calculate the attitude of the launcher. In Ariane 4, this software was allowed to continue functioning during the ﬁrst 50 seconds of ﬂight as it could other wise delay launching if the countdown was halted for any other reason, this was not necessar y for Ariane 5. As well, the software contained implicit assumptions about the parameters, in par ticular the horizontal velocity that were safe for Ariane 4 but not Ariane 5. The failure occurred because the horizontal velocity e x ceeded the maximum value for a 16 bit unsigned integer when it was conver ted from its signed 64 bit representation. This failur e gener at ed an e x ception in the code which was not caught and thus pr opagat ed up thr ough the pr ocessor and ultimat ely caused the SRI t o fail. The failure triggered the automatic fail-over to the backup SRI which had already failed for the same reason. This combined failure was then communicated to the main computer responsible for controlling the jets of the rock et, however, this information was misinterpreted as valid commands. As a result of the invalid commands, the engine no zzles were swung to an e xtreme position and the launcher was destroyed shor tly after wards. The failur e was thus entir ely due t o a single line of code. This should have been caught in testing!!! An uncaught e x ception! CPSC 310: Introduction to Software EngineeringCPSC 310: Introduction to Software Engineering Deepwater Horizon [http://neilstudd.ghost.io/2017/02/11/screen-testing-preview-deepwater-horizon/ ] “T ight deadlines encourage bad decisions” CPSC 310: Introduction to Software Engineering Deepwater Horizon “No slack to ﬁx technical debt” [http://neilstudd.ghost.io/2017/02/11/screen-testing-preview-deepwater-horizon/ ] CPSC 310: Introduction to Software Engineering Deepwater Horizon “P oor communication across repor ting lines” [http://neilstudd.ghost.io/2017/02/11/screen-testing-preview-deepwater-horizon/ ] CPSC 310: Introduction to Software Engineering Deepwater Horizon “Interpreting the results of tests” [http://neilstudd.ghost.io/2017/02/11/screen-testing-preview-deepwater-horizon/ ] CPSC 310: Introduction to Software Engineering Deepwater Horizon “The per fect storm” [http://neilstudd.ghost.io/2017/02/11/screen-testing-preview-deepwater-horizon/ ] CPSC 310: Introduction to Software Engineering Deepwater Horizon CPSC 310: Introduction to Software Engineering Given a ﬁnite amount of time and resources , testing enables validating that a system has an acceptable risk of costly or dangerous defects. —Bob Binder CPSC 310: Introduction to Software Engineering Why not test? ● Good reasons: ○ I don’t know how! ○ L egacy code ● Bad reasons: ○ Bad design ○ Doesn’t catch bugs (now) ○ Slow ○ Boring ○ Hard to change ○ That’s QA ’s job CPSC 310: Introduction to Software Engineering Common testing assumptions ● “The cost of ﬁxing faults rises e xponentially with how late [e.g., requirements, design, implementation, deployment] they are detected.” ○ This is commonly stated but is based on evidence from 20+ years ago. ○ This assumption does not seem to hold for modern processes, tools, and languages. ● S till necessar y to validate that the system works. ● Impor tant that system continues to work as it evolves. CPSC 310: Introduction to Software Engineering Test Driven Development (TDD): Red, green, refactor Image: http://slides.com/tonygaskell/mocha-chai#/1/1 S t ep 1 S t ep 2 S t ep 3 CPSC 310: Introduction to Software Engineering Red, green, refactor ● What you are doing in the P roject: ○ C0: W rite tests (S tep 1) ○ C1: W rite implementation (S tep 2) ○ C2: Refactor (S tep 3) S t ep 1 S t ep 2 S t ep 3 CPSC 310: Introduction to Software Engineering Image: http://slides.com/tonygaskell/mocha-chai#/1/1 Red, green, refactor S t ep 1 CPSC 310: Introduction to Software Engineering Testing terminology • SUT/CUT: S ystem/Code Under Test. • Glass-bo x: Tests that consider internals of CUT. • Black-bo x: Tests that are oblivious of internals of CUT. • Eﬀectiveness: The probability of detecting a bug per unit of eﬀor t. • Higher testability: More eﬀective tests, same cost. • L ower testability: F ewer weak er tests, same cost. • Repeatability: The lik elihood that running the same test twice will yield the same result. • Flaky test: Tests that pass/fail non-deterministically. CPSC 310: Introduction to Software Engineering CPSC 210 reminder: Each test has: • A meaningful name: that describes the reason for the test. These names are impor tant as tests are a crucial form of documentation. • Setup: Required code to get into desired state. Sometimes this is refactored into the @Before code. • Ex ecution: Invok es the CUT. • V alidation: V alidates that the CUT behaved as e xpected. • Tear down: Sometimes it is necessar y to reset par ts of the system after a test; often in @After code. CPSC 310: Introduction to Software Engineering Test Components // Meaningful Name it( \"should list one dataset\", () => { // Setup insightFacade.addDataset(“courses”); // Execution const datasets = await insightFacade.listDatasets(); // Validation expect(datasets).to.deep.equal([“courses”]); }); // Teardown afterEach(() => { clearDisk(); }); CPSC 310: Introduction to Software Engineering Test Components // Meaningful Name it( \"should list one dataset\", () => { // Setup insightFacade.addDataset(“courses”); // Execution const datasets = await insightFacade.listDatasets(); // Validation expect(datasets).to.deep.equal([“courses”]); }); // Teardown afterEach(() => { clearDisk(); }); Def. Code Under Test (CUT) or S ystem Under Test (SUT) CPSC 310: Introduction to Software Engineering Kinds of tests by scope ScopeSpeed Inﬂuences CPSC 310: Introduction to Software Engineering Scope Unit tests V er y Isolat edSpeed So V er y F ast Def: test behaviour of a single unit CPSC 310: Introduction to Software Engineering Integration tests ScopeSpeed Def: test how par ts of the system work together CPSC 310: Introduction to Software Engineering ScopeSpeed End-to-End (or S ystem) tests Def: test how the entire application works (as if you were the client) Flaky Tests Def. Tests that pass and fail non-deterministically. As scope increases, tests are more lik ely to become ﬂaky. ScopeSpeed Odds of Flakiness increase Courses class Kinds of tests by scope (e xamples) Unit Int egr ation End-t o-End sortById(courses) Single Method Multiple classes, includes database Button click in a browser Courses DB Get Courses CPSC 310: Introduction to Software Engineering Kinds of tests by purpose (Test Suites) Smok e ● C aptures core functionality. ● S tability of the build. ● V er y reliable as they need to catch major issues. V er y fast to run. Small Test Suite. ● Run to ﬁnd any major issues. Regression ● C aptures all e xisting functionality (no new tests). ● Quality of the build. ● Slower to run as the test suite is typically large. ● Run to ensure no e xisting behaviour has changed (e.g. after a refactor). CPSC 310: Introduction to Software Engineering Kinds of tests by purpose (Test Suites) Acceptance ● C aptures new functionality added by feature ○ Required functionality from users perspective ● Run to ensure end product solves the problem it was intended to solve CPSC 310: Introduction to Software Engineering Glass Bo x vs. Black Bo x Testing Def. Glass Bo x testing considers the implementation of a speciﬁcation. Def. Black Bo x testing does not consider (or even have access to) an implementation. (It does have access to the speciﬁcation)Which kinds of tests (e.g. unit, integration, end-to-end) are usually created with these types of testing? Black Bo x TestingCPSC 310: Introduction to Software Engineering Black Bo x testing (no access to system internals) 1: Read speciﬁcation. 2: W rite tests. 3: Go to 1. CPSC 310: Introduction to Software Engineering 1: Read speciﬁcation. 2: W rite tests. 3: Go to 1. On test failure, three options are possible: ● Fix system. ● Fix speciﬁcation. ● Fix test. Black Bo x testing (no access to system internals) CPSC 310: Introduction to Software Engineering 1: Read speciﬁcation. 2: W rite tests. 3: Go to 1. ➔ What are the advantages of black bo x over glass bo x testing? Black Bo x testing (no access to system internals) CPSC 310: Introduction to Software Engineering 1: Read speciﬁcation. 2: W rite tests. 3: Go to 1. ➔ What are the advantages of black bo x over glass bo x testing? ◆ Finds high severity bugs: act lik e a user (follow APIs). ◆ Easy to get star ted: more clear what to test (client-facing methods). ◆ L ess over ﬁtting to implementation: emphasis on speciﬁcation. ◆ P aralleliz e development and testing: no need to access implementation. Black Bo x testing (no access to system internals) CPSC 310: Introduction to Software Engineering 1: Read speciﬁcation. 2: W rite tests. 3: Go to 1. ➔ What are the advantages of black bo x over glass bo x testing? ➔ What are the disadvantages of black bo x testing? Black Bo x testing (no access to system internals) CPSC 310: Introduction to Software Engineering 1: Read speciﬁcation. 2: W rite tests. 3: Go to 1. ➔ What are the advantages of black bo x over glass bo x testing? ➔ What are the disadvantages of black bo x testing? ◆ Need well-deﬁned speciﬁcations :-) ◆ P oor e xplainability: test fails… but why? ◆ Intentional handicap: can’t use the implementation! Black Bo x testing (no access to system internals) CPSC 310: Introduction to Software Engineering When reading a method speciﬁcation to write tests, look for: • Equivalence Class P ar titioning (ECP): • A systematic way of covering the (possibly unbounded) space of inputs/outputs. • Help you to avoid redundant tests. • Boundar y V alue Analysis (BV A): • Help to ﬁnd most common errors hiding in edge cases. Black Bo x testing (no access to system internals) CPSC 310: Introduction to Software Engineering Equivalence Class P ar titioning (ECP) CPSC 310: Introduction to Software Engineering Input /Output par titioning • P ar titioning all possible inputs to CUT into equivalence classes which characteriz e sets of inputs with something in common. • W e do not consider intentions/actions/outputs of the CUT, e x cept to asser t on the correctness of an output for an input. • S trength of asser tion will depend on how well the spec describes relationship between inputs and outputs. • REQUIRES clause constrain our input par titioning (they codify assumptions CUT mak es about inputs). • Input par titioning must also respect PL inputs’ types, if known. • In general, additional knowledge of CUT may constrain inputs.CPSC 310: Introduction to Software Engineering • P ar titioning all possible inputs to CUT into equivalence classes which characteriz e sets of inputs with something in common . // Computes the string r epr esentation of the boolean. // // If the ar gument is true, a string equal to “true ” is r eturned; // other wise, a string equal to “false ” is r eturned. public toString(v al: boolean): string e.g., toString(true); Input /Output par titioning What are the input for toString() ? CPSC 310: Introduction to Software Engineering • P ar titioning all possible inputs to CUT into equivalence classes which characteriz e sets of inputs with something in common . // Computes the string r epr esentation of the boolean. // // If the ar gument is true, a string equal to “true ” is r eturned; // other wise, a string equal to “false ” is r eturned. public toString(v al: boolean): string The Boolean can only tak e on two possible values. The two input par titions are ﬁnite and contain one element each: ● toString(b) where b is true ● toString(b) where b is false Input /Output par titioning CPSC 310: Introduction to Software Engineering • P ar titioning all possible inputs to CUT into equivalence classes which characteriz e sets of inputs with something in common . // Computes the string r epr esentation of the boolean. // // If the ar gument is true, a string equal to “true ” is r eturned; // other wise, a string equal to “false ” is r eturned. public toString(v al: boolean): string The Boolean can only tak e on two possible values. The two input par titions are ﬁnite and contain one element each: ● b is true → expect(toString(true)).to.equal(“true ”); ● b is false → expect(toString(false)).to.equal(“false ”) Choose a representative from each par tition for the concrete test Input /Output par titioning CPSC 310: Introduction to Software Engineering • P ar titioning all possible inputs to CUT into equivalence classes which characteriz e sets of inputs with something in common . // Computes the absolute v alue of a number. If the ar gument is not // negativ e, the ar gument is r eturned. If the ar gument is negativ e, the // negation of the ar gument is r eturned. public static Math::abs(n: number): number Input /Output par titioning CPSC 310: Introduction to Software Engineering Input /Output par titioning • P ar titioning all possible inputs to CUT into equivalence classes which characteriz e sets of inputs with something in common . The spec calls out ‘not negative’ and ‘negative’ argument values. W e therefore derive the following 2 par titions/equivalence classes: ● n is a negative value ● n is a positive value // Computes the absolute v alue of a number. If the ar gument is not // negativ e, the ar gument is r eturned. If the ar gument is negativ e, the // negation of the ar gument is r eturned. public static Math::abs(n: number): number CPSC 310: Introduction to Software Engineering Input /Output par titioning • P ar titioning all possible inputs to CUT into equivalence classes which characteriz e sets of inputs with something in common . The spec calls out ‘not negative’ and ‘negative’ argument values. W e therefore derive the following 2 par titions/equivalence classes: ● n is a negative value ● n is a positive value // Computes the absolute v alue of a number. If the ar gument is not // negativ e, the ar gument is r eturned. If the ar gument is negativ e, the // negation of the ar gument is r eturned. public static Math::abs(n: number): number Choose representative from par tition for the concrete test CPSC 310: Introduction to Software Engineering Input/ Output par titioning • P ar titioning all possible outputs to CUT into equivalence classes which characteriz e sets of outputs with something in common. • Here, we do not consider inputs to CUT, e x cept to asser t on the correctness of the output for the given input. • Note: output par titioning requires an e xtra step : to test an output par tition we need to formulate inputs that cause an output in that par tition. (This may be diﬃcult) CPSC 310: Introduction to Software Engineering • P ar titioning of all possible outputs to CUT into equivalence classes which characteriz e sets of outputs with something in common. What are the output par titions for abs ? Input/ Output par titioning // Computes the absolute v alue of a number. If the ar gument is not // negativ e, the ar gument is r eturned. If the ar gument is negativ e, the // negation of the ar gument is r eturned. public static Math::abs(n: number): number CPSC 310: Introduction to Software Engineering • P ar titioning of all possible outputs to CUT into equivalence classes which characteriz e sets of outputs with something in common. F rom this spec we e xpect one kind of output: positive values. This gives us one output par tition: ● Output is a positive number Input/ Output par titioning // Computes the absolute v alue of a number. If the ar gument is not // negativ e, the ar gument is r eturned. If the ar gument is negativ e, the // negation of the ar gument is r eturned. public static Math::abs(n: number): number CPSC 310: Introduction to Software Engineering // Computes the gr eater of two int v alues. That is, the r esult is the // ar gument closer to the v alue of Number.M AX_V AL UE. If the ar guments // ha v e the same v alue, the r esult is that same v alue. public static Math::max(n: number, m: number): number Input/ Output par titioning CPSC 310: Introduction to Software Engineering The most we can say about the output of this function is that it must be a number. W e don’t have anything better than the number type to help us with output par titioning. So, we could par tition the outputs into: ● negative values ● positive values Input/ Output par titioning // Computes the gr eater of two int v alues. That is, the r esult is the // ar gument closer to the v alue of Number.M AX_V AL UE. If the ar guments // ha v e the same v alue, the r esult is that same v alue. public static Math::max(n: number, m: number): number CPSC 310: Introduction to Software Engineering Code Under Test (CUT) Inputs Outputs Relating input/output par titioning CPSC 310: Introduction to Software Engineering Output par titioning: 1. Determine output par titions 2. 3. Relating input/output par titioning Code Under Test (CUT) Inputs Outputs CPSC 310: Introduction to Software Engineering Output par titioning: 1. Determine output par titions 2. Select representative outputs per par tition 3. Relating input/output par titioning Code Under Test (CUT) Inputs Outputs CPSC 310: Introduction to Software Engineering Output par titioning: 1. Determine output par titions 2. Select representative outputs per par tition 3. Determine inputs that map to outputs Relating input/output par titioning Code Under Test (CUT) Inputs Outputs CPSC 310: Introduction to Software Engineering Relating input/output par titioning Concrete e xample: // Computes a human readable v ersion of distance. // Input: distance dist in meters // Requires: dist >= 0 // Returns: A string representation of dist. // Example return v alues: 0m, 100m, 1km, 1.2km, 1,000km public distT oHumanString(dist: number): string CPSC 310: Introduction to Software Engineering distT oHuman String Outputs dist > 0 Xm Xkm X,000km dist = 0 Relating input/output par titioning // Computes a human readable v ersion of distance. // Input: distance dist in meters // Requires: dist >= 0 // Returns: A string representation of dist. // Example return v alues: 0m, 100m, 1km, 1.2km, 1,000km public distT oHumanString(dist: number): stringInputs CPSC 310: Introduction to Software Engineering Outputs dist > 0 100m Xm Xkm X,000km dist = 0 1km 1,000km Relating input/output par titioning // Computes a human readable v ersion of distance. // Input: distance dist in meters // Requires: dist >= 0 // Returns: A string representation of dist. // Example return v alues: 0m, 100m, 1km, 1.2km, 1,000km public distT oHumanString(dist: number): stringInputs distT oHuman String CPSC 310: Introduction to Software Engineering Inputs Outputs dist > 0 100m Xm Xkm X,000km dist = 0 1km 1,000km distToHumanString 100 1000 100000 0 Relating input/output par titioning // Computes a human readable v ersion of distance. // Input: distance dist in meters // Requires: dist >= 0 // Returns: A string representation of dist. // Example return v alues: 0m, 100m, 1km, 1.2km, 1,000km public distT oHumanString(dist: number): string CPSC 310: Introduction to Software Engineering Relating input/output par titioning Inputs Outputs dist > 0 100m Xm Xkm X,000km dist = 0 1km 1,000km 100 1000 1000000 // Computes a human readable v ersion of distance. // Example return values: 0m, 100m, 1km, 1.2km, 1,000km public distT oHumanString ( dist: number ): string { asser t ( dist > 0 ) ; const output = dist ; let suﬃx = null; if ( dist < 1000 ) { suﬃx = \"m \"; } else { suﬃx += \"km \" ; } // Compute output String r eturn ( output + suﬃx ) ; } CPSC 310: Introduction to Software Engineering Inputs Outputs dist > 0 100m Xm Xkm X,000km dist = 0 1km 1,000km 100 1000 1000000 Spot the bug(s) Relating input/output par titioning // Computes a human readable v ersion of distance. // Example return values: 0m, 100m, 1km, 1.2km, 1,000km public distT oHumanString ( dist: number ): string { asser t ( dist > 0 ) ; const output = dist ; let suﬃx = null; if ( dist < 1000 ) { suﬃx = \"m \"; } else { suﬃx += \"km \" ; } // Compute output String r eturn ( output + suﬃx ) ; } CPSC 310: Introduction to Software Engineering Relating input/output par titioning Inputs Outputs dist > 0 100m Xm Xkm X,000km dist = 0 1km 1,000km test pass test fail test fail 100 1000 1000000 // Computes a human readable v ersion of distance. // Example return values: 0m, 100m, 1km, 1.2km, 1,000km public distT oHumanString ( dist: number ): string { asser t ( dist > 0 ) ; const output = dist ; let suﬃx = null; if ( dist < 1000 ) { suﬃx = \"m \"; } else { suﬃx += \"km \" ; } // Compute output String r eturn ( output + suﬃx ) ; } CPSC 310: Introduction to Software Engineering // Computes a human readable v ersion of distance. // Example return values: 0m, 100m, 1km, 1.2km, 1,000km public distT oHumanString ( dist: number ): string { asser t ( dist > 0 ) ; const output = dist ; let suﬃx = null; if ( dist < 1000 ) { suﬃx = \"m \"; } else { suﬃx += \"km \" ; } // Compute output String r eturn ( output + suﬃx ) ; } Inputs Outputs dist > 0 100m Xm Xkm X,000km dist = 0 1km 1,000km test pass test fail test fail 100 1000 1000000 Input par titioning would only ﬁnd these bugs by chance . Relating input/output par titioning In this case output par titioning is better at ﬁnding the bug. CPSC 310: Introduction to Software Engineering When reading a method speciﬁcation to write tests, look for: • Equivalence Classes P ar titions (ECP): • A strategic way of covering the (often unbounded) space of inputs/outputs. • Help you to avoid redundant tests. • Boundar y V alue Analysis (BV A): • Help to ﬁnd most common errors hiding in edge cases. Black Bo x testing CPSC 310: Introduction to Software Engineering Boundar y value analysis Typos lik e <= instead of < will generate a L O T of bugs! So test on either side of each boundar y! // Computes mortgage interest rate based on credit score. // Input: credit score between 30 and 85, or throws // Returns: the interest rate bucket: // - high for poor credit scores up to 69 // - medium for fair credit scores between 70 and 73 // - low for good credit scores 74 and over public getMortgageRate ( score: number ): “low” | “medium” | “high” CPSC 310: Introduction to Software Engineering Boundar y value analysis Input /Output P ar titions Identify input par tition // Computes mortgage interest rate based on credit score. // Input: credit score between 30 and 85 , or throws // Returns: the interest rate bucket: // - high for poor credit scores up to 69 // - medium for fair credit scores between 70 and 73 // - low for good credit scores 74 and over public getMortgageRate ( score: number ): “low” | “medium” | “high” CPSC 310: Introduction to Software Engineering Boundar y value analysis // Computes mortgage interest rate based on credit score. // Input: credit score between 30 and 85 , or throws // Returns: the interest rate bucket: // - high for poor credit scores up to 69 // - medium for fair credit scores between 70 and 73 // - low for good credit scores 74 and over public getMortgageRate ( score: number ): “low” | “medium” | “high” 30 85 Input /Output P ar titions Identify boundaries CPSC 310: Introduction to Software Engineering Boundar y value analysis // Computes mortgage interest rate based on credit score. // Input: credit score between 30 and 85 , or throws // Returns: the interest rate bucket: // - high for poor credit scores up to 69 // - medium for fair credit scores between 70 and 73 // - low for good credit scores 74 and over public getMortgageRate ( score: number ): “low” | “medium” | “high” [29 , 30 ] [85 , 86 ] Out-of-bound values Input /Output P ar titions CPSC 310: Introduction to Software Engineering // Computes mortgage interest rate based on credit score. // Input: credit score between 30 and 85 , or throws // Returns: the interest rate bucket: // - high for poor credit scores up to 69 // - medium for fair credit scores between 70 and 73 // - low for good credit scores 74 and over public getMortgageRate ( score: number ): “low” | “medium” | “high” [29 , 30 , 31 ] [84 , 85 , 86 ] In-bound values Input /Output P ar titions Boundar y value analysis CPSC 310: Introduction to Software Engineering Boundar y value analysis // Computes mortgage interest rate based on credit score. // Input: credit score between 30 and 85, or throws // Returns: the interest rate bucket: // - high for poor credit scores up to 69 // - medium for fair credit scores between 70 and 73 // - low for good credit scores 74 and over public getMortgageRate ( score: number ): “low” | “medium” | “high” Input/ Output P ar titions Identify output par titions CPSC 310: Introduction to Software Engineering Boundar y value analysis // Computes mortgage interest rate based on credit score. // Input: credit score between 30 and 85, or throws // Returns: the interest rate bucket: // - high for poor credit scores up to 69 // - medium for fair credit scores between 70 and 73 // - low for good credit scores 74 and over public getMortgageRate ( score: number ): “low” | “medium” | “high” [68 , 69 , 70 ] [69 , 70 , 71 ] [72 , 73 , 74 ][73 , 74 , 75 ] Input/ Output P ar titions Boundar y values for each par tition CPSC 310: Introduction to Software Engineering Boundar y testing // Computes mortgage interest rate based on credit score. // Input: credit score between 30 and 85, or throws // Returns: the interest rate bucket: // - high for poor credit scores up to 69 // - medium for fair credit scores between 70 and 73 // - low for good credit scores 74 and over public getMortgageRate ( score: number ): “low” | “medium” | “high” C ases: [29, 30, 31, 68, 69, 70, 71, 72, 73, 74, 75, 84, 85, 86] high medium lowExpect: err or err or Test all boundar y values CPSC 310: Introduction to Software Engineering Boundar y testing [https://blog.r esear ch.google/2006/06/ e xtra-e xtra-r ead-all-about-it-nearly . html]CPSC 310: Introduction to Software Engineering 1: public static int binarySearch(int[] a, int key) { 2: int low = 0; 3: int high = a.length - 1; 4: 5: while (low <= high) { 6: int mid = (low + high) / 2; 7: int midVal = a[mid]; 8: 9: if (midVal < key) 10: low = mid + 1 11: else if (midVal > key) 12: high = mid - 1; 13: else 14: return mid; // key found 15: } 16: return -(low + 1); // key not found. 17: } [https://blog.r esear ch.google/2006/06/ e xtra-e xtra-r ead-all-about-it-nearly . html] Boundar y testing CPSC 310: Introduction to Software Engineering 1: public static int binarySearch(int[] a, int key) { 2: int low = 0; 3: int high = a.length - 1; 4: 5: while (low <= high) { 6: int mid = (low + high) / 2; 7: int midVal = a[mid]; 8: 9: if (midVal < key) 10: low = mid + 1 11: else if (midVal > key) 12: high = mid - 1; 13: else 14: return mid; // key found 15: } 16: return -(low + 1); // key not found. 17: } “The gener al lesson that I tak e away fr om this bug is humility: It is har d to write even the smallest piece of code corr ectly [..] W e must pr ogr am car efully, defensively, and r emain ever vigilant. ” - Joshua Bloch [https://blog.r esear ch.google/2006/06/ e xtra-e xtra-r ead-all-about-it-nearly . html] Boundar y testing CPSC 310: Introduction to Software Engineering Eﬀective testing strategies ● F or testing to be eﬀective, it must be intentionally per formed. ● This is not an ad hoc process: speciﬁcations are carefully e xamined to determine correct behaviour. ● Creating tests often uncovers incomplete speciﬁcations. ● Tests are code too! Since they are e xpensive to write and maintain, they must be thought of as ﬁrst-class ar tifacts.","libVersion":"0.2.1","langs":""}