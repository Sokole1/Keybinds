{"path":".obsidian/plugins/text-extractor/cache/8ffdf0218fdcb2d03e379ae55ec972f1.json","text":"122.2. Computing File Read Performance A disk rotates at a speed of 10000 RPM and has an average seek time of 4.2 ms. A track holds 256 sectors of 4096 bytes each. We are going to create a convenient definition of the word \"contiguous\" for this problem. It won't necessarily correspond exactly to your intuitive definition of \"contiguous\". Call a block contiguous if it is allocated on disk immediately after its logical predecessor in the file. (Note, by this definition, the first block of a file cannot be considered contiguous, nor can any block to which you must seek before accessing it.) Here is an illustration of conceptual layout of two similar files. These files show two different ways to have 12 blocks of which 6 are \"contiguous\" by our definition. The dark blue blocks are \"contiguous\"; our definition of \"contiguous\" implies the illustrated regions of physically adjacent blocks within the file. File A Pt PPt Pt P> adjacent adjacent adjacent adjacent adjacent adjacent File B - adjacent Consider a file of 62 4096-byte blocks, of which 25 are contiguous and the rest are randomly scattered across the disk. Assume that when blocks are adjacent by physical block number, they are on the same track. If we consider the time it takes to read this file sequentially, does it matter if the 25 contiguous blocks appear all together in the file or if each one follows a block that is non-contiguous? That is, will your sequential read performance be different for file A and file B? No Yes How long (in ms) will it take to read the entire file sequentially? Round your answer to 2 decimal places. Sequential read time= 162.27 ms @ How long will it take if we read the file randomly? Round your answer to 2 decimal digits. Random read time= 1 ms @","libVersion":"0.2.1","langs":"eng"}