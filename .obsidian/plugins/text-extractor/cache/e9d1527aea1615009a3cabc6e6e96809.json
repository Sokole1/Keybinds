{"path":".obsidian/plugins/text-extractor/cache/e9d1527aea1615009a3cabc6e6e96809.json","text":"The Master Theorem Here we’ll wrap up divide and conquer recurrences, and cover the Master Theorem. But ﬁrst some handy math. Geometric Sums. Here are useful formulas, when summing up runtimes over levels of a recurrence tree. A geometric sum has the form Pn i=0 xi, where x> 0. Note that when x =1, Pn i=0 xi = n. When x 6=1 we have that: nX i=0 xi = xn+1 \u0000 1 x \u0000 1 = 1 \u0000 xn+1 1 \u0000 x . Now, for x< 1,takethelimitas n !1 to get an expression for the inﬁnite sum: 1X i=0 xi = 1. Section 5.5 of the text describes an integer multiplication algorithm, where the inputs are n-bit numbers. The runtime of this algorithm is given by the recurrence: T (n)= ⇢ c, if n =1, 3T (n/2) + cn, otherwise. Draw out and label enough of the recurrence tree, so that you can express T (n) as a sum of the total work per level. 6 2. Apply the formula for geometric sums to simplify your expression for T (n). 3. More generally, suppose that the recursive part of a recurrence for some runtime T (n) has the form: T (n)= aT (n/b)+ cnk for n \u0000 n0, where a> 0,b > 1,c > 0,k > 0 are constants. What is the total work done at level 2 of the recurrence tree? What is the total work done at level i? Write a sum for the total runtime. Note that the tree has logb n levels. 7 4. Looking back over the runtime recurrences for problems you’ve seen so far, give examples where the recurrence has the form shown in part 3, and also satisﬁes the following constraints. Write down what a, b,and k are for these examples. • a>bk: • a = bk: • a<bk: 5. Here is a statement of the Master Theorem.Suppose that T : N ! R\u00000 satisﬁes T (n)= ⇢ c, for n< n0, aT (n/b)+ cnk, for n \u0000 n0, where a> 0, b> 1, c> 0,and k \u0000 0 are constants. • If a>bk, then T (n)= ⇥(nlogb a). • If a = bk, then T (n)= ⇥(nk log n). • If a<bk, then T (n)= ⇥(nk). Go back and verify that the results we obtained using recurrence trees for the problems you list in part 4 match those provided by the Master Theorem. Note: The Master Theorem is handy for analyzing runtime of algorithms where an instance of size n is solved by recursively solving one or more subproblems of size n/b for some b> 1 (plus some extra work to break the problem down and/or piece the solutions of subproblems back together). It is not as useful when the subproblems have diﬀerent sizes, or if subproblems have size n \u0000 b rather than n/b. 8 3 Bonus Problem Can you extend the analysis of Quicksort to show that if the pivot is chosen randomly and uniformly from among the elements, then the expected running time is ⇥(n log n)? Note that we cannot assume that a randomly chosen pivot is always in the range between d n 4 e and b 3n 4 c. 9","libVersion":"0.2.1","langs":""}