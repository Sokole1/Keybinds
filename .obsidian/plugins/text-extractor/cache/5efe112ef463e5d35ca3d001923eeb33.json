{"path":".obsidian/plugins/text-extractor/cache/5efe112ef463e5d35ca3d001923eeb33.json","text":"S ingleton (and Dependency Injection) [https : //refactor ing.gur u/] Topics CP S C 310: Introduction to S oftware E ngineer ing • Identify when to us e the S ingleton patter n. • Identify an e x ample of when it is being us ed by looking for its main features (pr iv ate cons tr uctor, s tatic ins tance ﬁ eld + acces s method). • B e able to apply the S ingleton patter n to an e x is ting clas s , or create one from s cratch. • E x plain how to acces s the S ingleton ins tance by calling g etInsta nce ins tead of calling the cons tr uctor. • E x plain how s ingleton relates to des ign pr inciples (good and bad). • E x plain the diﬀ erence between S ingleton and Dependency Injection on a high-lev el. E xaminab le skills S ingleton CP S C 310: Introduction to S oftware E ngineer ing S cenario Y ou are creating an is s ue track er application where diﬀ erent components need to acces s a databas e. Y ou need to ens ure there is only one DB connection at any point in time. CP S C 310: Introduction to S oftware E ngineer ing S cenario: P rob lem F ormulat ion ● Ins tance needs to be pas s ed to all cons tr uctor s (pos s ibly duplicate code, long parameter lis t, s hotgun s urger y s mells , and tight coupling). ● No means to ens ure that only one s ingle ins tance is created → would we check ev er y where if the ins tance has been ins tantiated (pos s ible SRP v iolation ). A s s ume we want only s ingle ins tance of this ty pe CP S C 310: Introduction to S oftware E ngineer ing ● Global v ar iable that is not encaps ulated in any way. ● W e s till cannot ens ure that no fur ther ins tances are created. ● I ntent 1: W ant to ens ure that only one ins tance is ins tantiated. ● I ntent 2: W ant to prov ide a s ingle way to get this ins tance. wi n d o w .DB: Dat ab as eAc c es s o r = n ew Dat ab as eAc c es s o r (...); S cenario: First ap p roach CP S C 310: Introduction to S oftware E ngineer ing cla ss Da ta b a seAccessor { p riv ate s tatic insta nce: Da ta b a seAccessor ; p r iv a te insta nce: Da ta b a seAccessor = null; p riv ate c on s truc tor( ) { } p ub lic s tatic getIn s tan c e(): Da ta b a seAccessor { if (th is.insta nce = = null) { th is.insta nce = new Da ta b a seAccessor (); } retur n th is.insta nce; } } ● Hides the cons tr uctor, s o only the s ingleton clas s can call it. S cenario: S ingleton I mp lement at ion CP S C 310: Introduction to S oftware E ngineer ing cla ss Da ta b a seAccessor { p r iv a te insta nce: Da ta b a seAccessor = null; p riv ate c on s truc tor( ) { } p ub lic s tatic getIn s tan c e(): Da ta b a seAccessor { retur n new Da ta b a seAccessor (); th is.insta nce = new Da ta b a seAccessor ( retur n th is.insta nce; } } ● Hides the cons tr uctor, s o only the s ingleton clas s can call it. ● S tatically prov ides acces s to that ins tance. S cenario: S ingleton I mp lement at ion CP S C 310: Introduction to S oftware E ngineer ing cla ss Da ta b a seAccessor { p riv ate s tatic insta nce: Da ta b a seAccessor = null; p riv ate c on s truc tor( ) { } p ub lic s tatic getIn s tan c e(): Da ta b a seAccessor { if (th is.insta nce = = null) { th is.insta nce = new Da ta b a seAccessor (); } retur n th is.insta nce; } } ● Hides the cons tr uctor, s o only the s ingleton clas s can call it. ● S tatically prov ides acces s to that ins tance. ● S av es an ins tance of the clas s to a s tatic v ar iable. ● Only creating ins tance if needed (= laz y ins tantiation). S cenario: S ingleton I mp lement at ion CP S C 310: Introduction to S oftware E ngineer ing cla ss C om m entS er viceIm p l im p lem ents C om m entS er vice { p ub lic g etC om m entById (id : num b er ): v oid { const d b = D atab as eA c c es s or.getIn s tan c e( ); } } cla ss IssueS er viceIm p l im p lem ents IssueS er vice { p ub lic g etIssueById (id : num b er ): v oid { const d b = D atab as eA c c es s or.getIn s tan c e( ); } } cla ss IssueS er viceIm p l im p lem ents IssueS er vice { p ub lic g etIssueById (id : num b er ): v oid { const d b = D atab as eA c c es s or.getIn s tan c e( ); } } [https : //refactor ing.gur u/] S cenario: Client I mp lement at ion CP S C 310: Introduction to S oftware E ngineer ing P rob lems w it h S ingleton: ● R equires s pecial treatment in multi-threaded env ironments (where multiple threads need to acces s the s ingle ins tance). ● Introduces a new global method with dependencies s pread throughout the codebas e (pos s ibly s hotgun s urger y required!). ● V iolates S RP: Two res pons ibilities for S ingleton clas s (two intents with one clas s ). ● V iolates DI P: B oth client and s ingleton its elf are tied to s ingleton clas s . ● V iolates O CP: P r iv ate cons tr uctor → not open for e x tens ion (als o v er y diﬃcult to mock in unit tes ts ). The singleton p at tern is a des ign patter n that rest rict s t he inst ant iat ion of a clas s to one object. This is us eful when e x actly one object is needed to coordinate actions acros s the s y s tem. S ingleton P at tern CP S C 310: Introduction to S oftware E ngineer ing Dep end ency inject ion prov ides a better approach for ins tantiation as it decouples acces s control and object implementation: ● R ather than giv ing the res pons ibility for creating an object to a S ingleton clas s , we let a framewor k create thes e ins tance for us . ● Ty pically implemented with annotations (lik e @ injectable) wor king in concer t with a librar y. O ften Rep laced b y Dep end ency I nject ion CP S C 310: Introduction to S oftware E ngineer ing Dep end ency inject ion prov ides a better approach for ins tantiation as it decouples acces s control and object implementation: ● R ather than giv ing the res pons ibility for creating an object to a S ingleton clas s , we let a framewor k create thes e ins tance for us . ● Ty pically implemented with annotations (lik e @ injectable) wor king in concer t with a librar y. O ften Rep laced b y Dep end ency I nject ion @ Se r vic e() c l as s D atabas e M an ag e r { … } @ Se r vic e() c l as s C l ie n tC l as s { @ In je c t() in s tan c e : D atabas e M an ag e r ; } S trategy [https : //refactor ing.gur u/] Topics CP S C 310: Introduction to S oftware E ngineer ing • B e able to e x plain how delegation and compos ition are us ed in the S trategy des ign patter n. • B e able to e x plain the abs traction, concretis ation, and poly mor phis m inv olv ed in the patter n. • B e able to relate the S trategy patter n to des ign pr inciples . • B e able to e x plain and implement a s imple v er s ion of the patter n and for a giv en clas s diagram. • B e able to e x plain how and why S trategy can us e the F actor y patter n. E xaminab le skills S t rategy CP S C 310: Introduction to S oftware E ngineer ing S cenar io Y ou are creating an app for ﬁ le compres s ion and y ou want to s uppor t diﬀ er ent compr es s ion algor ithms depending on the client’ s operating s y s tem. CP S C 310: Introduction to S oftware E ngineer ing p ub lic com p ress(ﬁle: F ile): F ile { if (th is.isUnix()) { retur n th is.com p ressWith T a r (ﬁle); } else { retur n th is.com p ressWith Zip (ﬁle); } } S cenario: First A p p roach CP S C 310: Introduction to S oftware E ngineer ing P roblems (s election): ● O CP V iolat ion: Not open for new algor ithms . ● E ach additional algor ithm mak es the code in this clas s more comple x (div ergent changes s mell). ● S RP V iolat ion: Multiple algor ithms implemented in one clas s . ● Obv ious s witch-on-ty pe s mell. S cenario: First A p p roach CP S C 310: Introduction to S oftware E ngineer ing S cenario: A p p lying S t rategy I ntent : V ar y behav iour in our s y s tem (i.e. algor ithms ) without knowing all pos s ible algor ithms in adv ance. A llow new algor ithms to be added (open for e x tens ion) without impacting clients . E x pos e e x plicit inter faces for which we can prov ide new algor ithms as new requirements are added. CP S C 310: Introduction to S oftware E ngineer ing P otential DIP v iolation p ub lic C om p ressionS er vice() { if (th is.isUnix()) { th is.stra teg y = new T a r C om p ressionS tra teg y(); } else { th is.stra teg y = new Zip C om p ressionS tra teg y(); } } S cenario: S t rategy I mp lement at ion CP S C 310: Introduction to S oftware E ngineer ing ● E nhanced DIP : S er v ice does not depend on concrete S trategies . ● E nhanced OCP : new S trategies can be added and S er v ice is obliv ious . ● R es pons ibility of knowing about concrete s trategies mov ed to F actor y. S cenario: A d vanced S t rategy ( w / F actor y) CP S C 310: Introduction to S oftware E ngineer ing ● Clas s ic application of the Open/Clos ed pr inciple (OCP ). ● E ach s trategy encaps ulates s ingle algor ithm (S R P ). ● Conte x t delegates behav iour to S trategy. C anonical S t rategy CP S C 310: Introduction to S oftware E ngineer ing 1) Find the pr inciples violat ion : a) OCP v iolation: implementation not open for new algor ithms . b) S R P v iolation: multiple algor ithms implemented in one clas s . c) Mos t obv ious s mells : div ergent changes and s witch-on-ty pe. 2) Find the ab st ract ion (which clas s or clas s es are added at the top of the hierarchy ): a) The S trategy inter face (in our cas e Compres s ionS trategy ) b) P os s ibly : mov e s trategy cr eation to F actor y . 3) Find the p olymorp hism (which method is pres ent in that clas s , and how mus t it be ov er r idden in the s ubclas s es ?) : a) The method implementing the algor ithm (in our cas e compres s ()). b) P os s ibly : s trategy cr eation if F actor y is us ed. 4) Figure out w hen the poly mor phic method(s ) is /are called : a) When the algor ithm is inv ok ed (in our cas e compres s ()). b) P os s ibly : when the s trategy is cr eated if F actor y is us ed. S t rategy A nalysis S tate [https : //refactor ing.gur u/] Topics CP S C 310: Introduction to S oftware E ngineer ing ● B e able to e x plain how delegation and compos ition are us ed in the S tate des ign patter n. ● B e able to e x plain the abs traction, concretis ation, and poly mor phis m inv olv ed, as well as how and when the ov er r idden method is inv ok ed. ● B e able to relate the S tate patter n to code s mells and des ign pr inciples . ● B e able to e x plain and implement the s imple v er s ion of the patter n and the s tate machine v er s ion of the patter n. ● B e able to e x plain how it relates to S trategy. E xaminab le skills S t ate CP S C 310: Introduction to S oftware E ngineer ing S cenar io Y ou are wor king on a phone operating s y s tem and y ou want to implement the trans itions for the Home and P ower buttons . O ff L o cked Read y CP S C 310: Introduction to S oftware E ngineer ing S cenario: S t ate Machine CP S C 310: Introduction to S oftware E ngineer ing p ub lic p ressHom e() { s witc h (sta te) { c as e OF F: tur nO n(); setS ta te(L O C KED); b rea k ; c as e L OCK E D : unlock (); h om e(); setS ta te(READ Y ); b rea k ; c as e R E A D Y: setS ta te(READ Y ); b rea k ; d ef a ult: // ERRO R } } p r iv a te setS ta te(sta te: str ing ) { th is.sta te = sta te; } • P hone manages its trans itions . • pres s Home() and pres s P ower () methods mus t sw it ch depending on the s tate S cenario: First A p p roach CP S C 310: Introduction to S oftware E ngineer ing P roblems : ● Code becomes v er y diﬃcult to maintain as more s tates are added (many methods to change). ● S witch-on-ty pe and div ergent changes s mells in a large clas s with duplicate code. ● Hard to add new s tates (OCP ). ● Large clas s has many res pons ibilities (SRP ). ● R ely ing on concrete implementation and not abs traction (DIP ). I nit ial imp lement at ion ( 2)S cenario: First A p p roach CP S C 310: Introduction to S oftware E ngineer ing StateLocked created by - StateOff StateReady created y - StateLocked StateOff created by - Phone - StateLocked - StateReady <<creates>> S cenario: E ncap sulate S t ates in O b ject s S tates become objects . E v ents become methods . CP S C 310: Introduction to S oftware E ngineer ing StateLocked created by - StateOff StateReady created by - StateLocked StateOff created by - Phone - StateLocked - StateReady <<creates>> S cenario: E ncap sulate S t ates in O b ject s Intent: let an object alter its behav ior when its inter nal s tate changes . L et it appear as if the object changed its clas s . CP S C 310: Introduction to S oftware E ngineer ing a b stra ct cla ss S ta te { p rotected p h one: P h one; constr uctor (p h one: P h one ) { th is.p h one = p h one; } a b stra ct p r es s P ower(): v oid ; a b stra ct p r es s Home(): v oid ; } cla ss S ta teRea d y { p ub lic p r es s P ower(): v oid { p h one.tur nO f f (); p h one.s etS tate(new S ta teO f f (p h one)); } p ub lic p r es s Home(): v oid { // ... p h one.s etS tate(new S ta teRea d y(p h one)); } } S cenario: Up d ate S t ate on E vent s CP S C 310: Introduction to S oftware E ngineer ing ● Often us ed for problems that are natural to deﬁ ne us ing s tate machines . ● Create a hierarchy of pos s ible s tates . ● S tore a reference to one of the s tate objects repres enting the cur rent s tate in a conte x t. ● Delegate the s tate-related wor k to s tate objects . ● To trans ition the conte x t to another s tate, rep lace the cur rent s tate object (Conte x t is compos ed of s tates ). S t ate P at tern CP S C 310: Introduction to S oftware E ngineer ing 1) Find the pr inciples v iolation: a) OCP v iolation: not open for new s tates . b) S R P v iolation: one clas s embodies multiple s tates . c) Mos t obv ious s mells : div ergent changes and s witch-on-ty pe. 2) Find the abs traction (which clas s or clas s es are added at the top of the hierarchy ): a) A bs tract S tate clas s (can hav e diﬀ erent name). 3) Find the poly mor phis m (which method is pres ent in that clas s , and how mus t it be ov er r idden in the s ubclas s es ?): a) A ny methods deﬁ ned in the S tate clas s that require the aﬀ ected behav iour (in our cas e p ressHom e() and p ressP ower () ). 4) Figure out when the poly mor phic method(s ) is /are called: a) When the s y s tem trans itions from one s tate to the other (in our cas e by calling p ressHom e() or p ressP ower () ). S t ate A nalysis CP S C 310: Introduction to S oftware E ngineer ing ● S tate ≈ e x tens ion of S trategy – both us e compos ition and delegation. ● S trategies are unaware/independent of each other – S tates nor mally know about each other. ● S trategies are diﬀ erent implementations to achiev e a s imilar goal – S tates can encaps ulate entirely diﬀ erent behav iour s . ● S trategies us ually remain ﬁ x ed dur ing r untime (not a requirement though) – S tates are us ually replaced dur ing r untime. S t ate vs S t rategy","libVersion":"0.2.1","langs":""}