{"path":".obsidian/plugins/text-extractor/cache/a80cfe4dd6f3ef05be74c11bce90f0a9.json","text":"CPSC 320: Memoization and Dynamic Programming II ∗ 1 Memoization: If I Had a Nickel for Every Time I Computed That Here you’ll use a technique called memoization to improve the runtime of the recursive brute force algorithm for making change. Memoization avoids making a recursive call on any subproblem more than once, by using an array to store solutions to subproblems when they are ﬁrst computed. Subsequent recursive calls are then avoided by instead looking up the solution in the array. Memoization is useful when the total number of diﬀerent subproblems is polynomial in the input size. 1. Rewrite Brute-Force-Change, this time storing—which we call \"memoizing\", as in \"take a memo about that\"—each solution as you compute it so that you never compute any solution more than once. function Memo-Change(n) create a new array Soln of length n // using 1-based indexing for i from 1 to n do: Soln[i] ← return Memo-Change-Helper(n) function Memo-Change-Helper(i) if i < 0 then return inﬁnity else if i = 0 then return else if i > 0 then if Soln[i] == −1 then ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1 2. We want to analyze the runtime of Memo-Change. In what follows, we’ll refer back to this illustra- tion of two levels of recursive calls for Memo-Change-Helper. How much time is needed by a call to Memo-Change-Helper, not counting the time for recursive calls? That is, how much time is needed at each node of a recursion tree such as the one above? (Note: this is similar to the analysis we did of QuickSort’s recursion tree where we labelled the cost of a node (call) without counting the cost of subtrees (recursive calls). Here, however, we won’t sum the work per level.) 3. Which nodes at level two of the above recursion tree are leaves, that is, have no children (corresponding to further recursive calls) at level three? Assume that we draw recursion trees with the ﬁrst recursive call on the left. 4. Give an upper bound on the number of internal nodes of the recursion tree on input n. 5. Give a big-O upper bound on the number of leaves of the recursion tree on input n. 6. Using the work done so far, give a big-O bound on the run-time of algorithm Memo-Change(n). 2 2 Dynamic programming: Growing from the leaves The recursive technique from the previous part is called memoization. Turning it into dynamic programming requires avoiding recursion by changing the order in which we consider the subproblems. Here again is the recurrence for the smallest number of coins needed to make n cents in change, renamed to Soln: Soln[i] = inﬁnity, for i < 0 Soln[0] = 0, Soln[i] = 1 + min{Soln[i − 25], Soln[i − 10], Soln[i − 1]} otherwise. 1. Which entries of the Soln array need to be ﬁlled in before we’re ready to compute the value for Soln[i]? 2. Give a simple order in which we could compute the entries of Soln so that all previous entries needed are already computed by the time we want to compute a new entry’s value. 3. Take advantage of this ordering to rewrite Brute-Force-Change without using recursion: function Soln’(i) ▷ Note: It would be handy if Soln had 0 and negative entries. ▷ We use this function Soln’ to simulate this. if i < 0 then return inﬁnity else if i = 0 then return else return Soln[i] function DP-Change(n) if n ≤ 0 then return Soln’(n) else ▷ Assumes n > 0; otherwise, just run Soln’ create a new array Soln[1..n] for do Soln[i] ← the return Soln[n] 3 4. Assume that you have already run algorithm Memo-Change(n) or DP-Change(n) to compute the array Soln[1..n], and also have access to the Soln’ function above. Write an algorithm that uses the values in the Soln array to return the number of coins of each type that are needed to make change with the minimum number of coins. 5. Both Memo-Change and DP-Change run in the same asymptotic time. Asymptotically in terms of n, how much memory do these algorithms use? 6. Imagine that you only want the number of coins returned from Brute-Force-Change, and don’t need to actually calculate change. For the DP-Change algorithm, how much of the Soln array do you really need at one time? If you take advantage of this, how much memory does the algorithm use, asymptotically? 4 3 Challenge: Foreign Change Design a new version of DP-Change that handles foreign currencies more generally. An instance of the problem is a target amount n and an array of coin values c[1, ..k]. Assume that the penny is always available and is not included in the array. So, for pennies, dimes, and quarters, the array would look like [10, 25]. Analyse the runtime of your algorithm in terms of n and k. TAKE IT STEP BY STEP! That means to write trivial and small examples, describe the input and output, design an ineﬃcient recursive version, memoize it, and ﬁnally transform that into a dynamic programming solution. 4 More Challenge 1. How would you alter your algorithm for the \"foreign change\" problem if pennies were not guaranteed to be available? What unusual cases could arise in solutions? 2. Modify the dynamic programming solution to return both the number of coins used and the solution while using only constant memory. Hint: it helps when storing partial solutions that you don’t care what order you give the coins out in. 3. Count the number of diﬀerent ways to make n cents in change using quarters, dimes, nickels, and pennies (again, using memoization and/or dynamic programming). (a) First, assume that order matters (i.e., giving a penny and then a nickel is diﬀerent from giving a nickel and then a penny). (b) Then, assume that order does not matter. 4. Solve the \"minimum number of coins\" change problem if you do not have an inﬁnite supply and instead are given the available number of each coin as a parameter [num_quarters, num_dimes, num_nickels]. (Assume an inﬁnite number of pennies.) 5. Prove that you can take at least one greedy step if the foreign change algorithm takes only two distinct coin values [c1, c2], and n is at least as large as the least common multiple of c1 and c2. 6. Extend this \"least common multiple\" observation to more coins. 5","libVersion":"0.2.1","langs":""}