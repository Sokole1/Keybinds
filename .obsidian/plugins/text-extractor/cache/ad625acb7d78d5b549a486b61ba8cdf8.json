{"path":".obsidian/plugins/text-extractor/cache/ad625acb7d78d5b549a486b61ba8cdf8.json","text":"1. [0 marks] I hereby pledge that I have read and will abide by the rules, regulations, and expectations set out in the Academic Calendar, with particular attention paid to: ‹ The Student Declaration ‹ The Academic Honesty and Standards ‹ The Student Conduct During Examinations ‹ And any special rules for conduct as set out by the examiner. I a˚rm that I will not give or receive any unauthorized help on this examination, that all work will be my own, and that I will abide by any special rules for conduct set out by the examiner. True False 2. [8 marks] Suppose the UBC co-op o˚ce decided to use the Gale-Shapley algorithm, as presented in our worksheets, to match up n employers with n student applicants. (We will use the version where the employers are doing the asking, exactly as in the lectures/worksheets/assignment/tutorials.) However, suppose that in addition to the n real employers and applicants, there is one additional fake \"troll\" employer et and one additional fake troll applicant at. No one knows who the trolls are, so all employers will rank the troll applicant somewhere in their rankings, and all applicants will rank the troll employer somewhere in their rankings. The co-op o˚ce will then run the normal Gale-Shapley algorithm. At that point, though, the troll reveals itself and says \"Haha! I pranked the UBC co-op o˚ce!\" and the fake employer and applicant disappear. In the lucky scenario, the Gale-Shapley algorithm might have matched (et, at), and no harm is done. However, it's very likely that the Gale-Shapley algorithm matched the troll employer et with some other applicant av, and matched some employer ev with the troll applicant at. (The subscript v stands for \u0010victim\u0011.) In this case, to avoid disturbing all the other matchings, suppose the co-op o˚ce simply \u0010patches up\u0011 the matching by pairing up (ev, av), and keeping everyone else matched as they were by the Gale-Shapley algorithm. For this problem, provide an instance of the Stable Matching Problem where performing the patched-up Gale-Shapley algorithm as described above yields an unstable matching. To make the problem markable, your instance must contain exactly two real employers e1 and e2, and exactly two real applicants a1 and a2, as well as the troll employer et and troll applicant at. For your answer, give complete preference lists for each employer and applicant, and brie˛y justify your answer by explaining what matching the Gale-Shapley algorithm will produce, what the patched-up matching will be, and why the patched-up matching is unstable . 1 3. [3 marks] Show how to construct an instance of the stable matching problem with n employers and n applicants in which an employer is guaranteed to be matched with the applicant it ranked last. 2 4. Runtime and Measures of Progress The following code is a small function written in Python: def rewrite( str ): while \"Alan\" in str: str = str.replace(\"Alan\",\"Patrice\",1) print str return; The loop condition checks whether the substring \u0010Alan\u0011 occurs in the string str , and the assignment statement replaces the ˝rst occurence of the substring \u0010Alan\u0011 with the substring \u0010Patrice\u0011. For example, if the function is called on: rewrite(\"I like Alan more than Alan.\") it will print the following output: I like Patrice more than Alan. I like Patrice more than Patrice. 5. [3 marks] De˝ne a progress measure for the while loop and use it to prove that the loop always terminates. (Hint: This is very short.) 6. [3 marks] Let n be the original length of the string str that is passed to the function. Give a tight big- Θ bound on the worst-case number of times that the loop body executes, in terms of n. Brie˛y justify your answer. (Hint: This is also very short.) 3 7. [4 marks] Express the best case and worst case running time of the following algorithm as a function of n, where n is the length of a 0-indexed array A. function mystery1(A, n) for i = 0 to n - 3 do for j = i + 1 to n - 2 do for k = j + 1 to n - 1 do if A[i] + A[j] == A[k] then return True return False 4","libVersion":"0.2.1","langs":""}