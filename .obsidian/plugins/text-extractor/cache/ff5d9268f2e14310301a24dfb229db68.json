{"path":".obsidian/plugins/text-extractor/cache/ff5d9268f2e14310301a24dfb229db68.json","text":"Question 1.24 (a) The formula is _1(1_ Yn-1= 0\\n Yn ) This is then used as a backward recursion in n. 2 (b) Since 0 < z < 1, we have for any positive integer n that 2\" < 2™, and therefore 0<yn SYn1 <o <o For an arbitrarily given n, denote an approximation for y,, by #,, and let e,, = y,, — ¥, denote the error in this approximation. We proceed by setting ,, = 0 for a certain choice n; > 0, obtaining the error bound |en, | = [Yn, = ¥n,| = ¥n, < yo = In(11) — In(10). It follows that leal = |ens1]/10 = -+ = 10\" |e,, | < 10\" (In(11) — In(10)). For a given error tolerance & > 0 we therefore choose n; large enough such that 10~ ™ (In(11) — In(10)) < &. (c) The algorithm is stable because the factor by which previous roundoff errors are multiplied at the current iteration is now 1/10 = 0.1, and 0.1 < 1 (whereas in Example 1.11 the factor is 10 > 1). (d) Setting & = 1075 above leads to the choice ny > ng — logyo (m) This can be implemented using the one MATLAB line n1 = no0 + ceil(abs(logl0(1.e-5/(Llog(11)-1og(10))))); Then we set y,,, = 0 and apply the formula backward, for n =n, : —1: 2. e","libVersion":"0.2.1","langs":"eng"}