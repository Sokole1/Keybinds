{"path":".obsidian/plugins/text-extractor/cache/9cbf3ed97da6d66fa9b4841698fd1927.json","text":"CPSC 320: What’s in a Reduction? ∗ We often use reductions to solve new problems based on problems we can already solve. For example, in an earlier worksheet, we saw a reduction from the Shortest Paths Problem to Breadth First Search: But. . . there’s another way to use reductions. A more sinister way.1 We’ll illustrate this using a famous problem from logic: Satisﬁability. 1 Boolean Satisﬁability Boolean satisﬁability (SAT) is—as far as Computer Scientists know—a hard problem, in the sense that no-one knows of an algorithm to solve SAT that has worst-case polynomial runtime. In the version of SAT that we discuss here, you’re given a propositional logic expression like: (x1 ∨ x2 ∨ x3 ∨ x4) ∧ (x5) ∧ (x1) ∧ (x2 ∨ x3 ∨ x5) ∧ (x2 ∨ x3). You must determine whether any assignment of truth values to variables (the xi’s) makes the expression true, which we call satisfying the expression. Formally, an instance of SAT is a logical statement that is a conjunction (an \"and\" denoted by ∧) of c clauses. Each clause is a disjunction (an \"or\" denoted by ∨) of one or more literals, and each literal is either a variable xi or its negation xi. For convenience, we’ll insist on using the variables x1, x2, . . . xn for some n, without skipping any. Given an instance I of SAT, we want to know: is the instance I satisﬁable or not? The answer is either Yes or No, so we call this a decision problem. 1. Is the example SAT instance above satisﬁable? If not, explain why not. If so, prove it by giving an assignment that makes the statement true. ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1Well, OK. Just another way. 1 2. For a SAT instance I, a truth assignment is a potential solution, and the truth assignment is a good solution if it satisﬁes instance I. Suppose in addition to instance I you were given a truth assignment, say represented as an array T [1..n] where T [i] is true if and only if xi is set to true. How long would it take to certify that a truth assignment is good? 3. A brute force algorithm could make a list of the variables x1, . . . , xn in the problem, try every assign- ment of truth values to these variables, and return YES if any satisﬁes the expression or NO otherwise. Asymptotically, how many truth assignments might this algorithm try (in terms of n)? 2 3-SAT and SAT The 3-SAT problem is just like SAT, except that every clause must be exactly of length 3. Let’s build a reduction from SAT to 3-SAT (so we’re solving SAT in terms of 3-SAT). We’ll map an instance I of SAT to an instance I ′ of 3-SAT, working on one clause at a time. Importantly, for our reduction to work, I should be satisﬁable if and only if I ′ is satisﬁable. 1. Suppose that I has a clause with one literal, say (x5). To obtain I ′ from I, we want to replace this clause by one or more clauses, while ensuring that I is satisﬁable if and only if I ′ is. How can we do this? Hint: one variable can appear multiple times in a clause. 2. What if I has a clause with two literals, say (x2 ∨ x3)? 2 3. Now suppose that I has a clause with four literals, say (x1 ∨ x2 ∨ x3 ∨ x4). What 3-SAT clauses will you put in I ′ to replace this clause, so that I ′ is satisﬁable if and only if I is? Hints: Break the clause up somehow. Don’t try using de Morgan’s laws. Instead, create a brand new variable, say xn+1, and integrate that into your new clauses. 4. For your construction of part 3, show that if I is satisﬁable then I ′ must also be satisﬁable (and modify your construction if needed to ensure this). 5. Also for your construction of part 3, show that if I ′ is satisﬁable then I must also be satisﬁable. 3 6. Extend your 4-literal clause plan above to a 5-literal clause like (x1 ∨ x2 ∨ x3 ∨ x4 ∨ x5). Since new variable xn+1 is already \"used up\" in part 2, index any new variables that you create starting at xn+2. 7. Show, by ﬁlling in the blanks below, how you would transform a clause with k > 3 literals (l1 ∨ l2 ∨ . . . ∨ lk) into clauses with three literals (keeping in mind overall reduction correctness). You can use new variables that have not already been \"used up\", starting with xi+1 (where i ≥ n). How many clauses do you get? What would be the runtime of an algorithm to do this, as a function of k? (l1 ∨ l2 ∨ xi+1) ∧ (¯xi+1 ∨ l3 ∨ ) ∧ (¯xi+2 ∨ l4 ∨ xi+3) ∧ . . . . . . ∧ (xi+(j−2) ∨ lj ∨ xi+(j−1)) ∧ . . . ∧ (¯xi+(k−4) ∨ lk−2 ∨ ) ∧ (¯xi+(k−3) ∨ lk−1 ∨ ). 4 8. Let’s use the name Transform-Clause to refer to the algorithm for transforming a clause, as described in part 7. Suppose that I ′ is obtained from I by transforming clause (l1 ∨ l2 . . . ∨ lk) using algorithm Transform-Clause. Explain why I is satisﬁable if and only if I ′ is satisﬁable. 5 9. Give a reduction from SAT to 3-SAT. Recall that a reduction consists of two algorithms that \"connect\" one problem to another, as in this diagram: Transform instance algorithm: Transform solution algorithm: 10. Why is the reduction correct? 6 3 What does a reduction tell us? Here, consider a reduction from problem A to problem B, as illustrated in the ﬁgure of part 9. 1. SCENARIO #1 (how we’ve used reductions prior to this worksheet): Say our reduction’s two algorithms take O(f (n)) time and the black box solver for B also takes O(f (n)) time. What can we say about the running time to solve problem A? 2. SCENARIO #2 (what we usually think of NP-completeness as meaning): Say our reduc- tion’s two algorithms take O(g(n)) time and we know that there is no algorithm for problem A that runs in O(g(n)) time. What do we know about the the running time for problem B? Why? 3. SCENARIO #3 (what NP-completeness technically means): Say that we know (which we do) that if SAT can be solved in polynomial time, then any problem in the large set called \"NP\" can also be solved in polynomial time. What does our reduction from SAT to 3-SAT tell us? Why? 7","libVersion":"0.2.1","langs":""}