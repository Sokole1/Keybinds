{"path":".obsidian/plugins/text-extractor/cache/0570129771a8d25f776487581672f321.json","text":"Q2 Longest Common Subsequence 7 Points This algorithm is verbatim from the Longest Common Subsequence (LCS) worksheet. It reconstructs a LCS for two strings A[1..n] and B[1..m], using a Soln array that has already been filled in. procedure EXPLAIN-LCS(A[L..n}, B[1..m], Soln) > Note: Soln]0..n][0..m] is a filled-in LLCS memoization table for A and B if n == 0 or m == 0 then > base case return ”” else if A[n] == B[m] then > the final letters match, so, we add a letter to the LCS return EXPLAIN-LCS(A[L..n — 1], B[1.m — 1], Soln) +A[n] else > which recursive call yielded the max? if Soln[n — 1][m] > Soln[n|[m — 1] then > we don’t use the last letter of A in the solution return EXPLAIN-LCS(A[L..n — 1], B[1..m], Soln) else > we don’t use the last letter of B in the solution return EXPLAIN-LCS(A[1..n], B[1..m — 1], Soln) Q2.1 1 Point What is the running time of Explain-LCS, as a function of the input lengths n and m? Choose one. O(n+m) O((n+m)?) O((n + m)log(n +m)) O((n +m)?log(n +m))","libVersion":"0.2.1","langs":"eng"}