{"path":".obsidian/plugins/text-extractor/cache/944f5b5bb9a2cb74f7aeb852d6507296.json","text":"CPSC 320: Divide and Conquer Solutions ∗ Invented by Tony Hoare in the late 1950’s, the Quicksort algorithm was a breakthrough in sorting methods. Variants of Hoare’s original algorithm are still a sorting method of choice today. Here you’ll gain experience with the divide and conquer algorithmic design approach, as well as recurrence analysis, that led Hoare to this breakthrough, and see an application also to ﬁnding the median. Here is a basic version of Quicksort, when the array A[1..n] to be sorted has n distinct elements: function Quicksort(A[1..n]) ▷ returns the sorted array A of n distinct numbers if n > 1 then ▷ Θ(1) Choose pivot element p = A[1] ▷ Θ(1) Let Lesser be an array of all elements from A less than p ▷ Θ(n) Let Greater be an array of all elements from A greater than p ▷ Θ(n) LesserSorted ← QuickSort(Lesser) ▷ TQ(⌈ n 4 ⌉ − 1) GreaterSorted ← QuickSort(Greater) ▷ TQ(⌊ 3n 4 ⌋) return the concatenation of LesserSorted, [p], and GreaterSorted ▷ O(1) else return A ▷ Θ(1) 1 Quicksort Runtime Analysis 1. Suppose that QuickSort happens to always select the ⌈ n 4 ⌉-th largest element as its pivot. Give a recurrence relation for the runtime of QuickSort. SOLUTION: Let TQ(n) be the runtime (number of steps) of QuickSort on an array of length n. For these solutions, we’ve annotated the code above with the runtime of each step. This leads us to the following recurrence. It’s convenient in recurrences to replace big-O or Θ terms with some constant, and it’s ok to use the same constant everywhere. TQ(n) = { c, if n = 0 or n = 1 TQ(⌈ n 4 ⌉ − 1) + TQ(⌊ 3n 4 ⌋) + cn, otherwise. Ignoring ﬂoors, ceilings, and constants we get a slightly simpler recurrence: TQ(n) = { c, if n = 0 or n = 1 TQ( n 4 ) + TQ( 3n 4 ) + cn, otherwise. ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1","libVersion":"0.2.1","langs":""}