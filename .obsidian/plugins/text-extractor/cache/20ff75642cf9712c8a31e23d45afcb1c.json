{"path":".obsidian/plugins/text-extractor/cache/20ff75642cf9712c8a31e23d45afcb1c.json","text":"CPSC 320 2023W1: Tutorial 2 1 Asymptotic Notation: Pattern Matching Algorithms that ﬁnd occurrences of a pattern in a text are used in myriad applications, including text processing as well as detecting interesting motifs (patterns) in genomes (texts). Let P [1..k] and T [1..n] be strings, called the pattern and text, respectively. We say that P occurs at oﬀset o in T if P [1..k] = T [1 + o..k + o]. The following algorithm ﬁnds the oﬀsets of all occurrences of a pattern in a text: Algorithm Find-Pattern (P [1..k], T [1..n]) // Output the list of all oﬀsets of occurrences of pattern P in text T Oﬀset-List ← null // initially the list of oﬀsets is empty For o from 0 to n − k // Does P occur at oﬀset o of T ? #Matches = 0 For j from 0 to k − 1 If T [1 + o + j] == P [1 + j] #Matches++ If #Matches = k Add o to Oﬀset-List Return Oﬀset-List To analyze the running time of this algorithm, we’ll extend big-O notation to functions with two parameters. Speciﬁcally, let T (n, k) be the worst-case running time of a given algorithm whose input size is described using a pair (n, k) of nonnegative integers. We say that T (n, k) is big-O of function f (n, k) and write T (n, k) = O(f (n, k)) if there are nonnegative integers c, n0, and k0 such that for all inputs of size (n, k) with n ≥ n0 and k ≥ k0, T (n, k) ≤ cf (n, k). As a function of n and k, what terms below describe the worst-case running time of Algorithm Find- Pattern? Check all answers that apply. (Make sure to write down a brief justiﬁcation for your choices, and don’t forget to do that also in future problems and in the assignment.) Θ(k2) Θ((n − k + 1)2) Θ((n − k + 1)k) Θ(nk) 1 2 Faster or Slower For this problem, consult the accompanying handout on little-o notation. Suppose that some algorithm A has running time f (n) and that algorithm B has running time g(n), on all inputs of size n. Assume that f and g are functions N → N+, and that limn→∞ f (n) and limn→∞ g(n) are both inﬁnity. (Here, N is the set of nonnegative integers and N+ is the set of positive integers.) We say that algorithm A is eventually faster than B if on all suﬃciently large inputs, the running time of A is less than the running time of B. That is, f (n) < g(n) for all suﬃciently large n. Explain whether each of the following statements is true or false. 1. For some choice of g such that g(n) ∈ o(f (n) log n), A is eventually faster than B. 2. For some choice of g such that g(n) ∈ o(f (n) log n), B is eventually faster than A. 2 3 Algorithms on Numbers Let x and y be two nonnegative integers, represented in binary. Assume for concreteness that there are no trailing zero’s in the binary representation; for example the number three is represented as 11 and not as 00011. Assume furthermore for this problem that the lengths of x and y are exactly the same. (If you prefer, you can assume that the numbers are represented in decimal and answer the problem for for decimal addition and division operations, it won’t change the answer.) Here’s an algorithm for computing max{x, y}: Algorithm Find-Max(x, y): Repeatedly compare two bits of x and y, from high-order bits to low-order bits, until one of the following occurs: (a) The two compared bits diﬀer. If the bit of x is 1 and that of y is 0, output x, otherwise output y. (b) The end of both numbers is reached, and all compared pairs are the same. In this case, x must equal y, and so output either x or y. 1. Give a tight big-O bound on the running time of the Find-Max algorithm, as a function of x and y. Hint: What is the length of the binary representation of x? Make sure to distinguish between the inputs x and y and the input sizes, which in this case is the length of their binary representations. 2. Describe an inﬁnite set of pairs (x, y) for which the running time of Find-Max is O(1). 3. Which categories does the running time of the Find-Max algorithm belong to? (Choose as many as apply.) O(xy) O(x + y) O(log x log y) O(log x + log y) Ω(xy) Ω(x + y) Ω(log x log y) Ω(log x + log y) Θ(xy) Θ(x + y) Θ(log x log y) Θ(log x + log y) o(xy) o(x + y) o(log x log y) o(log x + log y) 3","libVersion":"0.2.1","langs":""}