{"path":".obsidian/plugins/text-extractor/cache/b831858b5032e2aa5987dd54594eb5f5.json","text":"CPSC 320: Asymptotic Runtime Analysis Solutions Questions that you’ll face throughout this course are: How can I ﬁgure out the runtime of an algorithm? Is one runtime faster than another? In this worksheet you’ll review some basics of algorithm runtime analysis, and touch also on algorithm correctness. We’ll usually focus on worst-case runtime, as a function of the input size, say n. Asymptotic analysis helps us understand the runtime for large n. 1 Asymptotic notation This table summarizes the asymptotic notation we’ll use to compare algorithm runtimes. Here we use statements such as “f = O(g)”, which is often also written as “f ∈ O(g)”. Statement Formal Deﬁnition Intuition f = O(g) ∃c > 0, ∃n0 ∈ N such that f (n) ≤ cg(n) for all n ≥ n0 f ≤ g f = o(g) ∀c > 0, ∃n0 ∈ N such that f (n) < cg(n) for all n ≥ n0 f < g or limn→∞ f (n)/g(n) = 0 f = Ω(g) ∃c > 0, ∃n0 ∈ N such that f (n) ≥ cg(n) for all n ≥ n0 g ≤ f g = O(f ) f = ω(g) g = o(f ) f > g f = Θ(g) f = O(g) and g = O(f ) f = g 1 2 Comparing function growth part 1 Arrange these functions by increasing order of growth, and give a good Θ bound for each. Notation that we use here and throughout the course: lg n = log2 n, ln n = loge n, and log n = log10 n. SOLUTION: Original function Good Θ bound Notes ln n Θ(lg n) log n, lg n, and ln n diﬀer by a constant factor n log n Θ( n lg n ) 55n + 4 Θ(n) 1.5n lg n Θ(n lg n) 2n log(n2) = 4n log n Θ(n lg n) (same \"rank\" as previous line) n + n2 Θ(n2) (n lg n)(n + 1) = n2 lg n + n lg n Θ(n2 lg n) √n√n = (n 1 2 ) √n Θ(n √n 2 ) (challenge problem; what’s the \"best\" form?) 2n Θ(2n) 1.62n = (1.62)n = 2.56n Θ(2.56n) n! Θ(n!) (n + 1)! Θ((n + 1)!) = Θ(n × n!) For the challenge problem comparison of n √n 2 and 2n, one approach is to make them look more similar. Using the fact that f (x) = 2lg f (x), we have n √n 2 = (2 lg n) √n 2 = 2 √ n 2 lg n. Now, if we take the ratio of these two functions: 2n 2 √ n 2 lg n = 2 n− √n 2 lg n. Also, n − √n 2 lg n ∈ Θ(n). So, 2 n− √n 2 lg n goes to inﬁnity but is dominated by 2n. Notation Review and Handy Math: • Logs: lg n = log2 n, ln n = loge n, and log n = log10 n. Also, we use both logc n and (log n)c to denote log n to the power c. • Handy identities: logb a = logc a logc b for b, c > 1 cacb = ca+b a = clogc a ca cb = ca−b (ca)b = cab 2 3 Comparing function growth part 2 Here are good rules of thumb when comparing how functions grow: • Logarithmic functions of n grow much more slowly than functions that are n to some constant power: For every b > 1 and every x > 0, we have logb n = o(nx). • Functions that are powers of n grow much more slowly than functions with n in the exponent. A weak form of this rule of thumb is stated in the textbook (2.9, page 42): For every c > 1 and every x > 0, we have nx = o(cn). 1. Show that for every b > 1 and every x > 0, logb n = o(nx). You can use the following weaker fact, stated in the textbook (2.8, page 41): For every b > 1 and every x > 0, we have logb n = O(nx). SOLUTION: Fix b and x. Using the fact, it must be the case that logb n = O(nx/2). So, ∃c > 0∃n0 ∈ N such that logb n ≤ cn x/2. As a result, lim n→∞ logb n nx ≤ lim cnx/2 nx = lim c nx/2 = 0. 2. Show that √n = o(n/ log3 n). SOLUTION: lim n→∞ √n (n/ log3 n) = lim n→∞ log3 n √n = lim n→∞ log3 n n1/2 . Recall that we interpret log n as log10 n. From part 1 above, choosing b = 10 and x = 1/6, we have that limn→∞ log n n1/6 = 0. So it is also the case that lim n→∞ ( log n n1/6 )3 = lim n→∞ log3 n n1/2 = 0. 3 4 Oscillating functions: These types of functions don’t usually arise in algorithms analysis, but studying them can sharpen your understanding of big-O notation. 1. Let f (n) = { n, if n is even, 1, if n is odd and let g(n) = n. (a) Is f = O(g)? SOLUTION: Yes, since f (n) ≤ g(n) for all n ≥ 1. (b) Is f = Ω(g)? SOLUTION: No, because no matter how small of constant value of c we choose, we can’t make f (n) ≥ cg(n) for all n ≥ n0. For example, if we pick c = 0.001, then when n > 1/c = 1000, we will be comparing f (n) versus cg(n) = (0.001)n > 1, so for all odd values of n that are greater than 1000, the inequality will fail. (c) Is f = Θ(g)? SOLUTION: No, this follows directly from the previous part. 4 5 Polynomial time 1. Sometimes you might see the statement “f (n) = nO(1)”. Write down a deﬁnition of what you think that means. SOLUTION: Deﬁnition of f (n) = nO(1): For some c > 0 and some n0 ≥ 0, f (n) ≤ nc for all n ≥ n0. Informally, a function f is nO(1) if f (n) is upper bounded by some polynomial in n, for all suﬃciently large n. Which of the following functions f (n) satisﬁes f (n) = nO(1), according to your deﬁnition? • f (n) = n3. SOLUTION: Yes, with c = 3 and n0 = 1. • f (n) = n4 log n. SOLUTION: Yes, with c = 5 and n0 = 1. • f (n) = 2n. SOLUTION: No, since for any c, limn→∞ nc/2n = 0, so it cannot be the case that 2n ≤ nc for large n. • f (n) = n2 + 3n + 5. SOLUTION: Yes, with c = 3 and n0 = 3. 5 6 Worst-case algorithm runtime Find a good Θ bound on the worst-case running time of each of the following algorithm. Justify your bound. function CountInversions(A[1..n]) ▷ A[1..n] is an array of numbers inversions ← 0 for i from 1 to n do for j from i + 1 to n do if a[i] > a[j] then inversions ← inversions + 1 return inversions SOLUTION: The inner loop takes constant time per iteration. The outer loop executes n times, and on the ith iteration the inner loop executes n − i times. This is a common pattern, and the overall running time is Θ(n2). In more detail, the total number of iterations of the code inside the inner loop is: n∑ i=1 n∑ j=i+1 1 = n∑ i=1(n − i) = ( n∑ i=1 n) − ( n∑ i=1 i) = n2 − n(n + 1) 2 = n2 − n2 + n 2 = n2/2 − n/2 = Θ(n2) Note that this is true no matter what the order of elements in the input array is. (Note also that when the array is sorted in decreasing order, inversions is incremented Θ(n2) times. So there can be Θ(n2) inversions in an array of length n.) 6 7 Challenge Problem 1. Give the best Θ bound you can ﬁnd for √n√n and then arrange it with respect to the other functions from Section 2. 7","libVersion":"0.2.1","langs":""}