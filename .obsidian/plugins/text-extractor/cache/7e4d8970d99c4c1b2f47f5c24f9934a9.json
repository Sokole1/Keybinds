{"path":".obsidian/plugins/text-extractor/cache/7e4d8970d99c4c1b2f47f5c24f9934a9.json","text":"[V R R ST GRS C1 CRVETL TR (Tl Consider the Domain Name System protocol. It is implemented in two different servers: « Authoritative Servers that hold resource records associated with names « Local Servers that resolve names on behalf of clients using iterative resolution On a piece of paper draw the finite state machine for these two DNS servers. Note that local DNS servers send requests only to authoriative servers, and that authoritative servers only reply to requests and never send requests on their own. To simplify your FSM, you should assume that the local DNS server works on one client request at a time. You should, however, remember that both a DNS request and a DNS reply might never be delivered because the underlying network is unreliable. In class we have been considering corrupt messages, but in \"real life\" messages that are corrupted are usually silently discarded by the layer of the protocol stack that detects the corruption. So corrupt messages turn into lost messages. Once you have completed the FSM, answer the following questions about your FSM. How many states do you have for the Local Server? integer o How many states do you have for the Authoritative Server? integer [~ For the Local Server, how many transitions are there that go from one state to a different state? integer o For the Local Server, how many transitions are there that go from one state to the same state? integer o For the Authoritative Server, how many transitions are there that go from one state to a different state? integer (-] For the Authoritative Server, how many transitions are there that go from one state to the same state? integer Q","libVersion":"0.2.1","langs":"eng"}