{"path":".obsidian/plugins/text-extractor/cache/633dbc839c994a9df344d8edfcbb6c17.json","text":"Approximate Inference 9.520 Class 19 Ruslan Salakhutdinov BCS and CSAIL, MIT 1 Plan 1. Introduction/Notation. 2. Examples of successful Bayesian models. 3. Laplace and Variational Inference. 4. Basic Sampling Algorithms. 5. Markov chain Monte Carlo algorithms. 2 References/Acknowledgements • Chris Bishop’s book: Pattern Recognition and Machine Learning, chapter 11 (many ﬁgures are borrowed from this book). • David MacKay’s book: Information Theory, Inference, and Learning Algorithms, chapters 29-32. • Radford Neals’s technical report on Probabilistic Inference Using Markov Chain Monte Carlo Methods. • Zoubin Ghahramani’s ICML tutorial on Bayesian Machine Learning: http://www.gatsby.ucl.ac.uk/∼zoubin/ICML04-tutorial.html • Ian Murray’s tutorial on Sampling Methods: http://www.cs.toronto.edu/∼murray/teaching/ 3 Basic Notation P (x) probability of x P (x|θ) conditional probability of x given θ P (x, θ) joint probability of x and θ Bayes Rule: P (θ|x) = P (x|θ)P (θ) P (x) where P (x) = ∫ P (x, θ)dθ Marginalization I will use probability distribution and probability density interchangeably. It should be obvious from the context. 4 Inference Problem Given a dataset D = {x1, ..., xn}: Bayes Rule: P (θ|D) = P (D|θ)P (θ) P (D) P (D|θ) Likelihood function of θ P (θ) Prior probability of θ P (θ|D) Posterior distribution over θ Computing posterior distribution is known as the inference problem. But: P (D) = ∫ P (D, θ)dθ This integral can be very high-dimensional and diﬃcult to compute. 5 Prediction P (θ|D) = P (D|θ)P (θ) P (D) P (D|θ) Likelihood function of θ P (θ) Prior probability of θ P (θ|D) Posterior distribution over θ Prediction: Given D, computing conditional probability of x∗ requires computing the following integral: P (x∗|D) = ∫ P (x∗|θ, D)P (θ|D)dθ = EP (θ|D)[P (x∗|θ, D)] which is sometimes called predictive distribution. Computing predictive distribution requires posterior P (θ|D). 6 Model Selection Compare model classes, e.g. M1 and M2. Need to compute posterior probabilities given D: P (M|D) = P (D|M)P (M) P (D) where P (D|M) = ∫ P (D|θ, M)P (θ|M)dθ is known as the marginal likelihood or evidence. 7 Computational Challenges • Computing marginal likelihoods often requires computing very high- dimensional integrals. • Computing posterior distributions (and hence predictive distributions) is often analytically intractable. • In this class, we will concentrate on Markov Chain Monte Carlo (MCMC) methods for performing approximate inference. • First, let us look at some speciﬁc examples: – Bayesian Probabilistic Matrix Factorization – Bayesian Neural Networks – Dirichlet Process Mixtures (last class) 8 Bayesian PMF 1 1 2 3 4 5 6 7 ... ~R U V User Features Features Movie We have N users, M movies, and integer rating values from 1 to K. Let rij be the rating of user i for movie j, and U ∈ RD×N, V ∈ RD×M be latent user and movie feature matrices: R ≈ U ⊤V Goal: Predict missing ratings. 9 Bayesian PMF UVj i Rij j=1,...,M i=1,...,N σ ΘV UΘ ααV U Probabilistic linear model with Gaussian observation noise. Likelihood: p(rij|ui, vj, σ2) = N (rij|u ⊤ i vj, σ2) Gaussian Priors over parameters: p(U |µU, ΛU) = N∏ i=1 N (ui|µu, Σu), p(V |µV , ΛV ) = M∏ i=1 N (vi|µv, Σv). Conjugate Gaussian-inverse-Wishart priors on the user and movie hyperparameters ΘU = {µu, Σu} and ΘV = {µv, Σv}. Hierarchical Prior. 10 Bayesian PMF Predictive distribution: Consider predicting a rating r∗ ij for user i and query movie j: p(r∗ ij|R) = ∫ ∫ p(r∗ ij|ui, vj)p(U, V, ΘU, ΘV |R)| {z } Posterior over parameters and hyperparameters d{U, V }d{ΘU, ΘV } Exact evaluation of this predictive distribution is analytically intractable. Posterior distribution p(U, V, ΘU, ΘV |R) is complicated and does not have a closed form expression. Need to approximate. 11 Bayesian Neural Nets Regression problem: Given a set of i.i.d observations X = {xn} N n=1 with corresponding targets D = {tn} N n=1. Likelihood: p(D|X, w) = N∏ n=1 N (t n|y(x n, w), β2) The mean is given by the output of the neural network: yk(x, w) = M∑ j=0 w2 kjσ( D∑ i=0 w1 jixi) where σ(x) is the sigmoid function. Gaussian prior over the network parameters: p(w) = N (0, α2I). 12 Bayesian Neural Nets Likelihood: p(D|X, w) = N∏ n=1 N (t n|y(x n, w), β2) Gaussian prior over parameters: p(w) = N (0, α2I) Posterior is analytically intractable: p(w|D, X) = p(D|w, X)p(w) ∫ p(D|w, X)p(w)dw Remark: Under certain conditions, Radford Neal (1994) showed, as the number of hidden units go to inﬁnity, a Gaussian prior over parameters results in a Gaussian process prior for functions. 13 Undirected Models x is a binary random vector with xi ∈ {+1, −1}: p(x) = 1 Z exp ( ∑ (i,j)∈E θijxixj + ∑ i∈V θixi). where Z is known as partition function: Z = ∑ x exp ( ∑ (i,j)∈E θijxixj + ∑ i∈V θixi). If x is 100-dimensional, need to sum over 2100 terms. The sum might decompose (e.g. junction tree). Otherwise we need to approximate. Remark: Compare to marginal likelihood. 14 Inference For most situations we will be interested in evaluating the expectation: E[f ] = ∫ f (z)p(z)dz We will use the following notation: p(z) = ˜p(z) Z . We can evaluate ˜p(z) pointwise, but cannot evaluate Z. • Posterior distribution: P (θ|D) = 1 P (D)P (D|θ)P (θ) • Markov random ﬁelds: P (z) = 1 Z exp(−E(z)) 15 Laplace Approximation −2 −1 0 1 2 3 4 0 0.2 0.4 0.6 0.8 Consider: p(z) = ˜p(z) Z (1) Goal: Find a Gaussian approximation q(z) which is centered on a mode of the distribution p(z). At a stationary point z0 the gradient ▽˜p(z) vanishes. Consider a Taylor expansion of ln ˜p(z): ln ˜p(z) ≈ ln ˜p(z0) − 1 2(z − z0) T A(z − z0) where A is a Hessian matrix: A = − ▽ ▽ ln ˜p(z)|z=z0 16 Laplace Approximation −2 −1 0 1 2 3 4 0 0.2 0.4 0.6 0.8 Consider: p(z) = ˜p(z) Z (2) Goal: Find a Gaussian approximation q(z) which is centered on a mode of the distribution p(z). Exponentiating both sides: ˜p(z) ≈ ˜p(z0) exp ( − 1 2(z − z0)T A(z − z0) ) We get a multivariate Gaussian approximation: q(z) = |A| 1/2 (2π)D/2 exp ( − 1 2(z − z0)T A(z − z0) ) 17 Laplace Approximation Remember p(z) = ˜p(z) Z , where we approximate: Z = ∫ ˜p(z)dz ≈ ˜p(z0) ∫ exp ( − 1 2(z − z0)T A(z − z0) ) = ˜p(z0)(2π) D/2 |A|1/2 Bayesian Inference: P (θ|D) = 1 P (D)P (D|θ)P (θ). Identify: ˜p(θ) = P (D|θ)P (θ) and Z = P (D): • The posterior is approximately Gaussian around the MAP estimate θM AP p(θ|D) ≈ |A| 1/2 (2π)D/2 exp ( − 1 2(θ − θM AP )T A(θ − θM AP ) ) 18 Laplace Approximation Remember p(z) = ˜p(z) Z , where we approximate: Z = ∫ ˜p(z)dz ≈ ˜p(z0) ∫ exp ( − 1 2(z − z0)T A(z − z0) ) = ˜p(z0)(2π) D/2 |A|1/2 Bayesian Inference: P (θ|D) = 1 P (D)P (D|θ)P (θ). Identify: ˜p(θ) = P (D|θ)P (θ) and Z = P (D): • Can approximate Model Evidence: P (D) = ∫ P (D|θ)P (θ)dθ • Using Laplace approximation ln P (D) ≈ ln P (D|θM AP ) + ln P (θM AP ) + D 2 ln 2π − 1 2 ln |A| | {z } Occam factor: penalize model complexity 19 Bayesian Information Criterion BIC can be obtained from the Laplace approximation: ln P (D) ≈ ln P (D|θM AP ) + ln P (θM AP ) + D 2 ln 2π − 1 2 ln |A| by taking the large sample limit (N → ∞) where N is the number of data points: ln P (D) ≈ P (D|θM AP ) − 1 2D ln N • Quick, easy, does not depend on the prior. • Can use maximum likelihood estimate of θ instead of the MAP estimate • D denotes the number of “well-determined parameters” • Danger: Counting parameters can be tricky (e.g. inﬁnite models) 20 Variational Inference Key Idea: Approximate intractable distribution p(θ|D) with simpler, tractable distribution q(θ). We can lower bound the marginal likelihood using Jensen’s inequality: ln p(D) = ln ∫ p(D, θ)dθ = ln ∫ q(θ)P (D, θ) q(θ) dθ ≥ ∫ q(θ) ln p(D, θ) q(θ) dθ = ∫ q(θ) ln p(D, θ)dθ + ∫ q(θ) ln 1 q(θ)dθ | {z } Entropy functional | {z } Variational Lower-Bound = ln p(D) − KL(q(θ)||p(θ|D)) = L(q) where KL(q||p) is a Kullback–Leibler divergence. It is a non-symmetric measure of the diﬀerence between two probability distributions q and p. The goal of variational inference is to maximize the variational lower-bound w.r.t. approximate q distribution, or minimize KL(q||p). 21 Variational Inference Key Idea: Approximate intractable distribution p(θ|D) with simpler, tractable distribution q(θ) by minimizing KL(q(θ)||p(θ|D)). We can choose a fully factorized distribution: q(θ) = ∏D i=1 qi(θi), also known as a mean-ﬁeld approximation. The variational lower-bound takes form: L(q) = ∫ q(θ) ln p(D, θ)dθ + ∫ q(θ) ln 1 q(θ)dθ = ∫ qj(θj)[ ln p(D, θ) ∏ i̸=j qi(θi)dθi ] | {z } Ei̸=j[ln p(D, θ)] dθj + ∑ i ∫ qi(θi) ln 1 q(θi)dθi Suppose we keep {qi̸=j} ﬁxed and maximize L(q) w.r.t. all possible forms for the distribution qj(θj). 22 Variational Approximation −2 −1 0 1 2 3 4 0 0.2 0.4 0.6 0.8 1 The plot shows the original distribution (yellow), along with the Laplace (red) and variational (green) approximations. By maximizing L(q) w.r.t. all possible forms for the distribution qj(θj) we obtain a general expression: q∗ j (θj) = exp(Ei̸=j[ln p(D, θ)]) ∫ exp(Ei̸=j[ln p(D, θ)])dθj Iterative Procedure: Initialize all qj and then iterate through the factors replacing each in turn with a revised estimate. Convergence is guaranteed as the bound is convex w.r.t. each of the factors qj (see Bishop, chapter 10). 23 Inference: Recap For most situations we will be interested in evaluating the expectation: E[f ] = ∫ f (z)p(z)dz We will use the following notation: p(z) = ˜p(z) Z . We can evaluate ˜p(z) pointwise, but cannot evaluate Z. • Posterior distribution: P (θ|D) = 1 P (D)P (D|θ)P (θ) • Markov random ﬁelds: P (z) = 1 Z exp(−E(z)) 24 Simple Monte Carlo General Idea: Draw independent samples {z1, ..., zn} from distribution p(z) to approximate expectation: E[f ] = ∫ f (z)p(z)dz ≈ 1 N N∑ n=1 f (zn) = ˆf Note that E[f ] = E[ ˆf ], so the estimator ˆf has correct mean (unbiased). The variance: var[ ˆf ] = 1 N E [ (f − E[f ]) 2] Remark: The accuracy of the estimator does not depend on dimensionality of z. 25 Simple Monte Carlo In general: ∫ f (z)p(z)dz ≈ 1 N N∑ n=1 f (zn), zn ∼ p(z) Predictive distribution: P (x∗|D) = ∫ P (x∗|θ, D)P (θ|D)dθ ≈ 1 N N∑ n=1 P (x∗|θn, D), θn ∼ p(θ|D) Problem: It is hard to draw exact samples from p(z). 26 Basic Sampling Algorithm How to generate samples from simple non-uniform distributions assuming we can generate samples from uniform distribution. Deﬁne: h(y) = ∫ y −∞ p(ˆy)dˆy Sample: z ∼ U [0, 1]. Then: y = h −1(z) is a sample from p(y). Problem: Computing cumulative h(y) is just as hard! 27 Rejection Sampling Sampling from target distribution p(z) = ˜p(z)/Zp is diﬃcult. Suppose we have an easy-to-sample proposal distribution q(z), such that kq(z) ≥ ˜p(z), ∀z. Sample z0 from q(z). Sample u0 from Uniform[0, kq(z0)] The pair (z0, u0) has uniform distribution under the curve of kq(z). If u0 > ˜p(z0), the sample is rejected. 28 Rejection Sampling Probability that a sample is accepted is: p(accept) = ∫ ˜p(z) kq(z)q(z)dz = 1 k ∫ ˜p(z)dz The fraction of accepted samples depends on the ratio of the area under ˜p(z) and kq(z). Hard to ﬁnd appropriate q(z) with optimal k. Useful technique in one or two dimensions. Typically applied as a subroutine in more advanced algorithms. 29 Importance Sampling Suppose we have an easy-to-sample proposal distribution q(z), such that q(z) > 0 if p(z) > 0. E[f ] = ∫ f (z)p(z)dz = ∫ f (z)p(z) q(z)q(z)dz ≈ 1 N ∑ n p(zn) q(zn)f (zn), zn ∼ q(z) The quantities wn = p(zn)/q(zn) are known as importance weights. Unlike rejection sampling, all samples are retained. But wait: we cannot compute p(z), only ˜p(z). 30 Importance Sampling Let our proposal be of the form q(z) = ˜q(z)/Zq: E[f ] = ∫ f (z)p(z)dz = ∫ f (z)p(z) q(z)q(z)dz = Zq Zp ∫ f (z) ˜p(z) ˜q(z)q(z)dz ≈ Zq Zp 1 N ∑ n ˜p(zn) ˜q(zn)f (zn) = Zq Zp 1 N ∑ n wnf (zn), zn ∼ q(z) But we can use the same importance weights to approximate Zp Zq: Zp Zq = 1 Zq ∫ ˜p(z)dz = ∫ ˜p(z) ˜q(z)q(z)dz ≈ 1 N ∑ n ˜p(zn) ˜q(zn) = 1 N ∑ n wn Hence: E[f ] ≈ 1 N ∑ n wn ∑ n wnf (zn) Consistent but biased. 31 Problems If our proposal distribution q(z) poorly matches our target distribution p(z) then: • Rejection Sampling: almost always rejects • Importance Sampling: has large, possibly inﬁnite, variance (unreliable estimator). For high-dimensional problems, ﬁnding good proposal distributions is very hard. What can we do? Markov Chain Monte Carlo. 32 Markov Chains A ﬁrst-order Markov chain: a series of random variables {z1, ..., zN} such that the following conditional independence property holds for n ∈ {z1, ..., zN −1}: p(zn+1|z1, ..., zn) = p(zn+1|zn) We can specify Markov chain: • probability distribution for initial state p(z1). • conditional probability for subsequent states in the form of transition probabilities T (zn+1 ← zn) ≡ p(zn+1|zn). Remark: T (zn+1 ← zn) is sometimes called a transition kernel. 33 Markov Chains A marginal probability of a particular state can be computed as: p(zn+1) = ∑ zn T (zn+1 ← zn)p(zn) A distribution π(z) is said to be invariant or stationary with respect to a Markov chain if each step in the chain leaves π(z) invariant: π(z) = ∑ z′ T (z ← z′)π(z′) A given Markov chain may have many stationary distributions. For example: T (z ← z′) = I{z = z′} is the identity transformation. Then any distribution is invariant. 34 Detailed Balance A suﬃcient (but not necessary) condition for ensuring that π(z) is invariant is to choose a transition kernel that satisﬁes a detailed balance property: π(z′)T (z ← z′) = π(z)T (z′ ← z) A transition kernel that satisﬁes detailed balance will leave that distribution invariant: ∑ z′ π(z′)T (z ← z′) = ∑ z′ π(z)T (z′ ← z) = π(z) ∑ z′ T (z′ ← z) = π(z) A Markov chain that satisﬁes detailed balance is said to be reversible. 35 Recap We want to sample from target distribution π(z) = ˜π(z)/Z (e.g. posterior distribution). Obtaining independent samples is diﬃcult. • Set up a Markov chain with transition kernel T (z′ ← z) that leaves our target distribution π(z) invariant. • If the chain is ergodic, i.e. it is possible to go from every state to any other state (not necessarily in one move), then the chain will converge to this unique invariant distribution π(z). • We obtain dependent samples drawn approximately from π(z) by simulating a Markov chain for some time. Ergodicity: There exists K, for any starting z, T K(z′ ← z) > 0 for all π(z′) > 0. 36 Metropolis-Hasting Algorithm A Markov chain transition operator from current state z to a new state z′ is deﬁned as follows: • A new ’candidate’ state z∗ is proposed according to some proposal distribution q(z∗|z), e.g. N (z, σ2). • A candidate state x∗ is accepted with probability: min (1, ˜π(z∗) ˜π(z) q(z|z∗) q(z∗|z) ) • If accepted, set z′ = z∗. Otherwise z′ = z, or the next state is the copy of the current state. Note: no need to know normalizing constant Z. 37 Metropolis-Hasting Algorithm We can show that M-H transition kernel leaves π(z) invariant by showing that it satisﬁes detailed balance: π(z)T (z′ ← z) = π(z)q(z′|z) min (1, π(z′) π(z) q(z|z′) q(z′|z) ) = min (π(z)q(z′|z), π(z′)q(z|z′)) = π(z′) min ( π(z) π(z′) )q(z′|z) q(z|z′) , 1 ) = π(z′)T (z ← z′) Note that whether the chain is ergodic will depend on the particulars of π and proposal distribution q. 38 Metropolis-Hasting Algorithm 0 0.5 1 1.5 2 2.5 3 0 0.5 1 1.5 2 2.5 3 Using Metropolis algorithm to sample from Gaussian distribution with proposal q(z′|z) = N (z, 0.04). accepted (green), rejected (red). 39 Choice of Proposal Proposal distribution: q(z′|z) = N (z, ρ 2). ρ large - many rejections ρ small - chain moves too slowly The speciﬁc choice of proposal can greatly aﬀect the performance of the algorithm. 40 Gibbs Sampler Consider sampling from p(z1, ..., zN). Initialize zi, i = 1, ..., N For t=1,...,T Sample zt+1 1 ∼ p(z1|zt 2, ..., zt N) Sample zt+1 2 ∼ p(z2|zt+1 1 , x t 3, ..., zt N) · · · Sample zt+1 N ∼ p(zN|zt+1 1 , ..., zt+1 N −1) Gibbs sampler is a particular instance of M-H algorithm with proposals p(zn|zi̸=n) → accept with probability 1. Apply a series (component- wise) of these operators. 41 Gibbs Sampler Applicability of the Gibbs sampler depends on how easy it is to sample from conditional probabilities p(zn|zi̸=n). • For discrete random variables with a few discrete settings: p(zn|zi̸=n) = p(zn, zi̸=n) ∑ zn p(zn, zi̸=n) The sum can be computed analytically. • For continuous random variables: p(zn|zi̸=n) = p(zn, zi̸=n) ∫ p(zn, zi̸=n)dzn The integral is univariate and is often analytically tractable or amenable to standard sampling methods. 42 Bayesian PMF Remember predictive distribution?: Consider predicting a rating r∗ ij for user i and query movie j: p(r∗ ij|R) = ∫ ∫ p(r∗ ij|ui, vj)p(U, V, ΘU, ΘV |R)| {z } Posterior over parameters and hyperparameters d{U, V }d{ΘU, ΘV } Use Monte Carlo approximation: p(r∗ ij|R) ≈ 1 N N∑ n=1 p(r∗ ij|u (n) i , v(n) j ). The samples (u n i , vn j ) are generated by running a Gibbs sampler, whose stationary distribution is the posterior distribution of interest. 43 Bayesian PMF Monte Carlo approximation: p(r∗ ij|R) ≈ 1 N N∑ n=1 p(r∗ ij|u (n) i , v(n) j ). The conditional distributions over the user and movie feature vectors are Gaussians → easy to sample from: p(ui|R, V, ΘU, α) = N (ui|µ∗ i , Σ ∗ i ) p(vj|R, U, ΘU, α) = N (vj|µ∗ j, Σ∗ j) The conditional distributions over hyperparameters also have closed form distributions → easy to sample from. Netﬂix dataset – Bayesian PMF can handle over 100 million ratings. 44 MCMC: Main Problems Main problems of MCMC: • Hard to diagnose convergence (burning in). • Sampling from isolated modes. More advanced MCMC methods for sampling in distributions with isolated modes: • Parallel tempering • Simulated tempering • Tempered transitions Hamiltonian Monte Carlo methods (make use of gradient information). Nested Sampling, Coupling from the Past, many others. 45","libVersion":"0.2.1","langs":""}