{"path":".obsidian/plugins/text-extractor/cache/9ec54b0574736722017c6eb936756600.json","text":"CPSC 320: Divide and Conquer ∗ Invented by Tony Hoare in the late 1950’s, the Quicksort algorithm was a breakthrough in sorting methods. Variants of Hoare’s original algorithm are still a sorting method of choice today. Here you’ll gain experience with the divide and conquer algorithmic design approach, as well as recurrence analysis, that led Hoare to this breakthrough, and see an application also to ﬁnding the median. Here is a basic version of Quicksort, when the array A[1..n] to be sorted has n distinct elements: function Quicksort(A[1..n]) ▷ returns the sorted array A of n distinct numbers if n > 1 then Choose pivot element p = A[1] Let Lesser be an array of all elements from A less than p Let Greater be an array of all elements from A greater than p LesserSorted ← QuickSort(Lesser) GreaterSorted ← QuickSort(Greater) return the concatenation of LesserSorted, [p], and GreaterSorted else return A 1 Quicksort Runtime Analysis 1. Suppose that QuickSort happens to always select the ⌈ n 4 ⌉-th largest element as its pivot. Give a recurrence relation for the runtime of QuickSort. ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1 2. Using the recurrence, draw a recursion tree for QuickSort. Label each node by the number of elements in the array at that node’s call (the root is labeled n) and the amount of time taken by that node but not its children. Also, label the total work (time) for each \"level\" of calls. Show the root at level 0 and the next two levels below the root, and also the node at the leftmost and rightmost branches of level i. 3. Find the following two quantities. (a) The number of levels in the tree down to the shallowest leaf. Hint: Is the shallowest leaf on the leftmost side of the tree, the rightmost side, or somewhere else? If you’ve already described the problem size of the leftmost and rightmost nodes at level i as a function of i, then set that equal to the problem size you expect at the leaves and solve for i. (b) The number of levels in the tree down to the deepest leaf. 2 4. Use the work from the previous parts to ﬁnd asymptotic upper and lower bounds for the solution of your recurrence. 5. Now, we’ll relax our assumption that the algorithm always selects the ⌈ n 4 ⌉-th largest element as its pivot. Instead, consider a weaker assumption that the rank of the pivot is always in the range between ⌈ n 4 ⌉ and ⌊ 3n 4 ⌋. The rank of an element is k if the element is the kth largest in the array. What can you say about the runtime of Quicksort in this case? 6. Draw the recursion tree generated by QuickSort([10, 3, 5, 18, 1000, 2, 100, 11, 14]). As- sume that QuickSort: (1) selects the ﬁrst element as pivot and (2) maintains elements’ relative order when producing Lesser and Greater. 3 2 An Algorithm for Finding the Median Suppose that you want to ﬁnd the median number in an array of length n. The algorithm below can be generalized to ﬁnd the element of rank k, i.e., the kth largest element in an array, for any 1 ≤ k ≤ n. (Note: the lower the rank, the larger the element.) The median is the element of rank ⌈n/2⌉. For example, the median in the array [10, 3, 5, 18, 1000, 2, 100, 11, 14] is the element of rank 5 (or 5th largest element), namely 11. 1. In your speciﬁc recursion tree above, mark the nodes in which the median (11) appears. (The ﬁrst of these is the root.) 2. Look at the second recursive call you marked—the one below the root. 11 is not the median of the array in that recursive call! (a) In this array, what is the median? (b) In this array, what is the rank of the median? (c) In this array, what is the rank of 11? (d) How does the rank of 11 in this array relate to the rank of 11 in the original array (at the root)? Why does this relationship hold? 3. Look at the third recursive call you marked. What is the rank of 11 in this array? How does this relate to 11’s rank in the second recursive call, and why? 4. If you’re looking for the element of rank 42 (i.e., the 42nd largest element) in an array of 100 elements, and Greater has 41 elements, where is the element you’re looking for? 5. How could you determine before making QuickSort’s recursive calls whether the element of rank k is the pivot or appears in Lesser or Greater? 4 6. Modify the QuickSort algorithm so that it ﬁnds the element of rank k. Just cross out or change parts of the code below as you see ﬁt. Change the function’s name! Add a parameter! Feel the power! function Quicksort(A[1..n]) // returns the sorted array A of n distinct numbers if n > 1 then Choose pivot element p = A[1] Let Lesser be an array of all elements from A less than p Let Greater be an array of all elements from A greater than p Let LesserSorted = QuickSort(Lesser) Let GreaterSorted = QuickSort(Greater) return the concatenation of LesserSorted, [p], and GreaterSorted else return A 7. Once again, suppose that the rank of the pivot in your median-ﬁnding algorithm on a problem of size n is always in the range between ⌈ n 4 ⌉ and ⌊ 3n 4 ⌋. Draw the recursion tree that corresponds to the worst-case running time of the algorithm, and give a tight big-O bound in the algorithm’s running time. Also, provide an asymptotic lower bound on the algorithm’s running time. 5 The Master Theorem Here we’ll wrap up divide and conquer recurrences, and cover the Master Theorem. But ﬁrst some handy math. Geometric Sums. Here are useful formulas, when summing up runtimes over levels of a recurrence tree. A geometric sum has the form ∑n i=0 xi, where x > 0. Note that when x = 1, ∑n i=0 xi = n. When x ̸= 1 we have that: n∑ i=0 xi = xn+1 − 1 x − 1 = 1 − xn+1 1 − x . Now, for x < 1, take the limit as n → ∞ to get an expression for the inﬁnite sum: ∞∑ i=0 xi = 1. Section 5.5 of the text describes an integer multiplication algorithm, where the inputs are n-bit numbers. The runtime of this algorithm is given by the recurrence: T (n) = { c, if n = 1, 3T (n/2) + cn, otherwise. Draw out and label enough of the recurrence tree, so that you can express T (n) as a sum of the total work per level. 6 2. Apply the formula for geometric sums to simplify your expression for T (n). 3. More generally, suppose that the recursive part of a recurrence for some runtime T (n) has the form: T (n) = aT (n/b) + cn k for n ≥ n0, where a > 0, b > 1, c > 0, k > 0 are constants. What is the total work done at level 2 of the recurrence tree? What is the total work done at level i? Write a sum for the total runtime. Note that the tree has logb n levels. 7 4. Looking back over the runtime recurrences for problems you’ve seen so far, give examples where the recurrence has the form shown in part 3, and also satisﬁes the following constraints. Write down what a, b, and k are for these examples. • a > bk: • a = bk: • a < bk: 5. Here is a statement of the Master Theorem. Suppose that T : N → R≥0 satisﬁes T (n) = { c, for n < n0, aT (n/b) + cnk, for n ≥ n0, where a > 0, b > 1, c > 0, and k ≥ 0 are constants. • If a > bk, then T (n) = Θ(nlogb a). • If a = bk, then T (n) = Θ(nk log n). • If a < bk, then T (n) = Θ(nk). Go back and verify that the results we obtained using recurrence trees for the problems you list in part 4 match those provided by the Master Theorem. Note: The Master Theorem is handy for analyzing runtime of algorithms where an instance of size n is solved by recursively solving one or more subproblems of size n/b for some b > 1 (plus some extra work to break the problem down and/or piece the solutions of subproblems back together). It is not as useful when the subproblems have diﬀerent sizes, or if subproblems have size n − b rather than n/b. 8 3 Bonus Problem Can you extend the analysis of Quicksort to show that if the pivot is chosen randomly and uniformly from among the elements, then the expected running time is Θ(n log n)? Note that we cannot assume that a randomly chosen pivot is always in the range between ⌈ n 4 ⌉ and ⌊ 3n 4 ⌋. 9","libVersion":"0.2.1","langs":""}