{"path":".obsidian/plugins/text-extractor/cache/1129b06d28306edc082846db5d3fccc3.json","text":"S 4. You’d also like to show that your algorithm produces a good i.e., optimal, solution that minimizes the number of guards. We can use an exchange argument (described in Chapter 4 of K&T) for this purpose: If G* is an optimal solution for instance (X[1..n],d) of our problem, we transform G* into the solution, say G, found by our greedy algorithm on the same instance, while keeping it optimal. It follows that G is also optimal. 1 Show the first step of the exchange argument. Depending on the details of your algorithm, this might involve the following. Let p} and p; be the positions of the first (leftmost) guard in G* and G, respectively. Show that G* — {p}} + {p1} is an optimal solution for instance (X[1..n],d). 5. Prove by induction on n, the number of objects, that your algorithm is correct.","libVersion":"0.2.1","langs":"eng"}