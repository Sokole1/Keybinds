{"path":".obsidian/plugins/text-extractor/cache/719ef597500deb2a2f89653d0e60f42e.json","text":"5 A Number Sieve The following NUMBER-SIEVE algorithm repeatedly scans an array containing the numbers 1,2, ..., n in order. On the first iteration of the while loop, the algorithm removes every second number, by replacing the number with —1. On subsequent iterations every third number from the remaining set of numbers (not counting the —1’s) is removed; then every fourth number and so on. The algorithm terminates once no number is removed on some iteration. We’ll call the numbers that are never removed the lucky numbers. The first few lucky numbers in a sufficiently long array are 1, 3, 7, 13, 19. 1: function NUMBER-SIEVE(p[1..n]) 2 > p[1..n] initially contains the numbers 1,2,...,n in this order 3: done « false 4 k=1 5 while not done do 6: k=k+1 7: j«<0 8: done « true 9: for i from 1 to n do > Remove every kth of the remaining positive numbers in p 10: if p[i] # —1 then 11: jeji+1 12: if j ==k then 13: pli] + —1 14: j«<0 15: done ¢ false 16: return the list of positive numbers remaining in p 1. (4 points) One nice feature of big-O analysis of algorithm runtime is that we can often ignore annoying floors and ceilings. Show that if we ignore these, then for k£ > 1 there are n/k positive numbers remaining in the array at the start of the kth iteration of the while loop (assuming that the algorithm has not already terminated). 2. (3 points) What is the runtime of NUMBER-SIEVE, as a function of n?","libVersion":"0.2.1","langs":"eng"}