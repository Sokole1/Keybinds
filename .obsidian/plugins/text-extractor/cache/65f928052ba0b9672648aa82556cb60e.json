{"path":".obsidian/plugins/text-extractor/cache/65f928052ba0b9672648aa82556cb60e.json","text":"6 Sort-of Quicker Sort Recurrence When sorting data in real life, there’s often a bound on the range of values to be sorted. For example, UBC student ID numbers are integers between 0 and 99999999. We can use this fact to design sorting algorithms that sometimes work faster than the usual ones we have studied. The input is an array A[l.m] of integer numbers, plus two integers low and high such that all numbers in A are in the range [low...high where low < high. Here is a recursive sorting algorithm: o In the base cases, A has size at most 1 or low = high, and the algorithm returns A. o Otherwise the algorithm works as follows: Calculate the integer at the middle of the possible value range (rounding up if needed, e.g., 50000000 for UBC Student IDs). Call this value the pivot. Then, partition the array, putting all the values lower than the pivot into one array, called Lesser, with range [low..pivot-1], and all the values at least as large as the pivot into another array, called Greater, with range [pivot..high]. Recursively sort the arrays Lesser and Greater, and then concatenate them together. In what follows, we'll let 7a = high — low +1 be the size of the range [low, high], and assume throughout that n > 0 and that m > 1. 1. (2 marks) This part of the question considers a worst-case scenario. Let T'(n, m) be the runtime of the algorithm as a function of n and m, when the items in A always get put entirely in Lesser, with no items going into Greater. (This could happen, e.g., if all the numbers being sorted are 0, in which case the size of the range keeps halving until the base case \"low = high\" is reached.) Write a recurrence relation for T'(n,m). You can ignore floors and ceilings and do not need to solve the recurrence. 2. (4 marks) Let T\"(n,m) be the runtime of the algorithm when the sizes of the two lists resulting from the partition always happen to be n/3 and 2n/3. Here is the recurrence relation for T'(n, m) (ignoring floors and ceilings) Tnymy={ & ifn<lorm=1, 2™ = T'(n/3,m/2) + T'(2n/3,m/2) + cn, ifn>1andm> 1. Solve this recurrence relation to show that 7\"(n, m) = ©(nmin(log m, log n)). 3. (2 marks) If we consider m to be a constant (e.g., for UBC Student IDs, m = 1000000000), then what would be the big-© bound for the quantity 7\"(n,m) of part 27","libVersion":"0.2.1","langs":"eng"}