{"path":".obsidian/plugins/text-extractor/cache/1c340b0e1be3dd27d26af80619968329.json","text":"CPSC 320: Steps in Algorithm Design and Analysis Part b Solutions ∗ Step 5: Design a better algorithm. 1. Brainstorm some ideas, then sketch out an algorithm. Try out your algorithm on some examples. You may have lots of ideas. For example, you might have noticed that if a employer and a applicant both most-prefer each other, we must match them; that might form the kernel of some kind of algorithm. For our algorithm, we’ll work with the Gale-Shapley algorithm, also in textbook and on part b of this worksheet. 1: function Gale-Shapley(n, PE, PA) 2: ▷ n ≥ 1 is the number of employers and also the number of applicants 3: ▷ PE is the collection of complete preference lists (>e) of the employers 4: ▷ PA is the collection of complete preference lists (>a) of the applicants 5: ▷ return a stable matching M for the stable matching instance (n, PE, PA) 6: 7: M ← ∅ ▷ matching M is initially empty 8: while some employer is unmatched and has not considered every applicant do 9: choose any such employer e 10: let a be the highest-ranked applicant in e’s list that e has not yet considered 11: ▷ e now considers a (i.e., \"makes an oﬀer\" to a) as follows: 12: if a is unmatched then 13: add match (e, a) to M ▷ a accepts e’s oﬀer 14: else ▷ a is matched 15: let a be currently matched to e′ 16: if e >a e′ then ▷ a prefers e to e′ 17: remove match (e′, a) from M ▷ a rejects e′’s oﬀer 18: add match (e, a) to M ▷ a accepts e’s oﬀer 19: else ▷ a prefers e′ to e, in which case M does not change 20: return M ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1 2. Analyze the running time of your algorithm. Using big-O notation, can you bound the number of iterations of the while loop? How much time does each iteration take? SOLUTION: To bound the number of iterations of the while loop, note that the algorithm terminates if the condition of the loop eventually becomes false—that is, when all employers are matched or when all employers have considered all applicants, whichever comes ﬁrst. On each iteration of the loop, some employer e considers some applicant a that e has not considered in previous iterations. There are n2 employer-applicant pairs, so the condition of the while loop must become false within n2 iterations, and the algorithm terminates. There are a constant number of steps at each iteration of the while loop. We can generalize the data structures of our IsStable algorithm so that each of these steps takes O(1) time. The IsStable algorithm uses array Applicant-Matches[1..n], whose ath entry is the applicant matched with a. We can generalize this array so that the entry has value 0 if a is unmatched. To implement line 7, all entries of the array are initialized to 0, which is a one-time cost of O(n). To remove match (e′, a) from M (line 17), we need to set entry Applicant-Matches[a] to 0. This takes O(1) time. Adding a match (line 18) is similar. For lines 10-11, we can use a ranked list of e’s preferences. We remove a, the highest-ranked applicant from this list in line 11. To test whether the condition of the while loop is true or false, we can maintain a list L of employers which are unmatched and have not yet considered all applicants. This list is empty if and only if the condition of the while loop is true, and checking if a list is empty can be done in O(1) time. Initially all employers are on the list, which is a one-time cost of O(n) time. In line 9, we can set the employer e to be the employer at the head of list L. We remove this employer from the list when e becomes matched (lines 13, 18). If an employer e′ becomes unmatched (line 17), we can put e′ at the end of the list, if e′ preference list of applicants is not empty. So, maintaining list L takes O(1) time. We can use a 2D array as in the IsStable algorithm to check whether e >a e′ in line 16. Further details are in the textbook. In summary, each iteration of the Gale-Shapley algorithm takes O(1) time, and since there are O(n2) iterations, the algorithm runs in time O(n2) total. 2 3. Is your bound of part 2 tight in the worst case? SOLUTION: To show that this bound is tight, we need to ﬁnd instances on which the G-S algorithm takes Θ(n2) time. Let’s try the following ranking for employers: e1: a1, a2, ..., an e2: a1, a2, ..., an ei: a1, a2, ..., an In this case, each ei can ﬁrst consider a1. This takes n iterations of the while loop, and just one employer is matched to a1. Then, each of the n − 1 unmatched ei’s consider a2. This takes n − 1 iterations and results in one additional match, to a2. Continuing on, in the jth round, each of the n − j + 1 unmatched ei’s consider aj, with one being matched to aj at the end. This takes n − j + 1 iterations. Finally, the last remaining unmatched employer considers, and is matched to, an. The total number of iterations is n + (n − 1) + . . . + 2 + 1, which is n(n + 1)/2. Although this might not be the worst possible instance of size n, it is suﬃcient to show that the algorithm requires Θ(n2) iterations of the while loop in the worst case. 3 4. Show that your algorithm is correct. It’s always good to start by writing down what it means for the algorithm to be correct. For the SMP problem, it means that the algorithm outputs a perfect matching with no instabilities. • Show that the output is a perfect matching. We’ll break this down further: – Every applicant has been considered at least once upon termination. SOLUTION: This is easy to see by examining the condition of the While loop, which is false when the algorithm terminates. When the condition is false, one of two things must be true. Either all employers have considered all applicants, in which case certainly every applicant has been considered at least once. Otherwise, all employers must be matched, and so all applicants must be also matched since no applicant is matched with two employers (see lines 12, 13 and 17, 18 of the code). But an applicant can only be matched if it has been considered, and again the statement must be true. – Every applicant is matched upon termination. SOLUTION: To see why, note that if an applicant a is unmatched when a is considered, then a becomes matched (line 13). If a is already matched, say to employer e′ and is considered again, say by e, then a is either rematched with e (line 18) or remains matched with e′. Either way, a remains matched by the end of the iteration. We’ve already shown above that every applicant is considered at least once by the algorithm and so all applicants must be matched when the algorithm terminates. – Every employer is matched upon termination. SOLUTION: No employer can be matched to more than one applicant, because the con- dition of the while loop ensures that only unmatched employers are matched within the while loop. So, if all applicants are matched, all employers must be matched too. 4 • Show that the output has no instabilities. Recall that a pair (e, a′) is an instability if (e, a) and (e′, a′) are distinct pairs in M , and also e prefers a′ to a, and a′ prefers e to e′. That is, e and a′ would prefer to be matched with each other than with their matches in M . One natural approach is to show that the (partial) matching constructed after each iteration of the While loop avoids instabilities. Let Mk be the matching at the end of iteration k ≥ 0 of the While loop, and let Ek and Ak be the set of employers and the set of applicants, respectively, that are matched in Mk. Show by induction that there is no instability in Ek × Ak with respect to Mk. Claim: There is no instability in Ek × Ak with respect to Mk. Base case: SOLUTION: k = 0. Then Mk is empty, and so there are no instabilities. Inductive step: SOLUTION: We show that at the end of some iteration k ≥ 1, there are no instabilities in Ek × Ak with respect to Mk, given the induction hypothesis that there are no instabilities in Ek−1 × Ak−1 with respect to Mk−1. Suppose that at iteration k, e considers (makes an oﬀer to) a. There can be no instabilities that involve neither e nor a, since such instabilities would also have arisen in Mk−1, which is stable by the induction hypothesis. There are three cases (corresponding to the cases of the if statement inside the while loop): Case 1. a is unmatched and accepts e’s oﬀer. No instability can involve a, because the other employers that are matched in Mk have not yet considered a and so prefer their own matches to a. No instability can involve e, since if e prefers a′ to a, then a′ has already been matched with an employer that a′ prefers to e. Case 2. a is already matched, say to e′, and accepts e’s oﬀer, rejecting e′. In this case no instability can involve a, since a prefers e to its match in Mk−1. No instability can involve e for the same reason as in Case 1. Employer e′ is now unmatched and so not in Ek, so e′ does not concern us. Case 3. a is already matched, say to e′, and prefers e′ to e. In this case Mk = Mk−1, which has no instabilities by the induction hypothesis. This completes the inductive proof. Choosing k to be the last iteration of the While loop, we have that M = Mk, E = Ek and A = Ak. Therefore there are no instabilities in E × A with respect to M . Note: Proof by induction is often a nice way to show that properties are preserved throughout successive iterations of a While loop. It’s natural that the cases in the proof will follow the structure of If statements in the While loop. The proof by contradiction in the textbook is more streamlined than the proof presented here, and you should read that too. But inductive reasoning about While loops can be a more structured and fool-proof approach when gaining experience with proofs. 5","libVersion":"0.2.1","langs":""}