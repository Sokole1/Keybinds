{"path":".obsidian/plugins/text-extractor/cache/f61508545145dc5d2245a8b93c8de3c2.json","text":"CPSC 320: Graph Play Solutions∗ 1 Graph Diameter The diameter of a connected, undirected, unweighted graph is the largest possible value of the following quantity: the smallest number of edges on any path between two nodes. In other words, it’s the largest number of steps required to get between two nodes in the graph. Your task is to design an eﬃcient algorithm to ﬁnd the diameter. Step 1: Build intuition through examples. What is the diameter of the following graphs? SOLUTION: 1. The diameter of the left graph is 4. The shortest path between nodes g and h (via d, b, and one of e or f) is 4 steps long. This actually only shows a lower bound on the diameter, but if you try all the other pairs of nodes, you’ll ﬁnd the shortest paths between them are all shorter. 2. The diameter of the right graph is 3, between c and f. A fun way to double-check this: ignoring c, every other pair of nodes is on a single cycle of length 5; so, there will certainly be a 2-step path between them (the shorter \"side\" of the cycle). Step 2: Develop a formal problem speciﬁcation Develop notation for describing a problem instance, a potential solution, a good solution. SOLUTION: • A problem instance is an unweighted, connected undirected graph G = (V, E), where V is the set of nodes and E is the set of edges. We’ll let n and m denote the number of nodes and edges of the graph, respectively, and let V = {1, 2, . . . , n}. We’ll assume that n ≥ 2, in which case the diameter is at least 1 (a graph with one node is trivial, having diameter 0). ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1 4 edges, so diameter = 4 3 edges, so not diameter 3 edges, so diameter = 3 • In some sense, a potential solution is simply a non-negative integer, representing the diameter. How- ever, at least one pair of nodes u, v ∈ V will deﬁne the diameter, which is the distance (number of edges on the shortest path) from u to v. We’ll denote this distance by d(u, v). It seems reasonable that the pair (u, v) would be provided as part of the solution also, along with d(u, v). Going even further, we may want a solution to provide a path between nodes u and v. • A (potential) solution (k, u, v) is good if k = d(u, v) and k is the graph diameter. It will be helpful to write a precise expression for the graph diameter, e.g., when we need to reason about algorithm correctness, so we write: diameter(V, E) = max 1≤i,j≤n d(i, j). (1) 2 Step 3: Identify similar problems. What are the similarities? SOLUTION: Breadth ﬁrst search seems similar, since it ﬁnds the shortest path between a node s and other nodes of an unweighted connected graph. Step 4: Evaluate brute force. SOLUTION: A brute force approach could be to enumerate all pairs (u, v), determine the shortest path between them, and keep track of the maximum found: function DIAM-Brute-Force(G = (V, E)) ▷ returns (k, u, v) where k is the graph diameter and d(u, v) = k k ← 0 for each pair of nodes (i, j) (i.e., potential solution) do Find d(i, j), the length of the shortest path between i and j (e.g., using breadth ﬁrst search from i) if d(i, j) > k then k ← d(i, j) (u, v) ← (i, j) return (k, u, v) Now, let’s ﬁgure out the worst-case runtime of DIAM-Brute-Force. The for loop iterates through all pairs (u, v), and for each runs breadth ﬁrst search, which takes time Θ(n + m). There are n2 pairs (u, v), so the algorithm takes Θ(n2(n + m)) time. 3 We did not discuss this in class. For more info, see textbook, section 3.3, especially theorem 3.11 on page 91. Here we have a connected graph, so m ≥ n-1: O(n+m) = O(2m) = O(m) Also, for a fully connected graph with all node pairs connected: m = n(n-1)/2, so m = O(n²): O(n+m) = O(m) = O(n²) Θ(n²) Θ(n + m) Θ(1) Step 5: Design a better algorithm. 1. Brainstorm some ideas, then sketch out an algorithm. Try out your algorithm on some examples. SOLUTION: Using BFS on every pair of nodes seems like overkill. After all, BFS already computes the shortest path to every node in the graph from a given node. Why not grab the longest of those and use that as a lower-bound on diameter? function DIAM-BFS(G = (V, E)) ▷ returns (k, u, v) where k is the graph diameter and d(u, v) = k k ← 0 for each node i do run BFS(i); let j be a node at the deepest level of the bfs tree if d(i, j) > k then k ← d(i, j) (u, v) ← (i, j) return (k, u, v) 2. Show that your algorithm is correct. SOLUTION: Here, by correct we mean that (i) k = d(u, v) and k is the graph diameter, as deﬁned in equation 1 above. Our reasoning is straightforward, following the iterative structure of the algorithm. Suppose that kl denotes the value of k after l iterations of the outer for loop. We claim that the value of kl is kl = max 1≤i≤l,1≤j≤n d(i, j). This follows using a straightforward induction, since the updates within the inner for loop on iteration l + 1 ensures that kl+1 = max{kl, max 1≤j≤n d(l + 1, j)} = max 1≤i≤l+1,1≤j≤n d(i, j). and so after all n iterations, k is exactly the diameter of the graph. 3. Analyze the running time of your algorithm. SOLUTION: The algorithm has n iterations of the outer for loop, and each iteration takes time Θ(n + m) for breadth ﬁrst search. So the total runtime is Θ(n(n + m)), a factor of n better than brute force. 4 This is definition of diameter when l==n Θ(n) Θ(n + m) Θ(1) Inductive Proof for this: 2 Weighted Shortest Paths (WSP) Now we’ll turn to weighted undirected graphs. Finding shortest paths in such graphs has numerous appli- cations, such as ﬁnding the cheapest airfare between two cities, or ﬁnding the shortest route from where we are to where we want to get to in a maze of hiking trails. Step 1: Build intuition through examples. SOLUTION: In the example on the right above, the shortest path from s to q goes through t, and has a cost of 6. It’s reasonable to assume that the input graph has at least two nodes, otherwise the graph has no paths. Step 2: Develop a formal problem speciﬁcation SOLUTION: We could deﬁne the problem in terms of ﬁnding a shortest (simple) path between two speciﬁc nodes, say s and t, in a weighted, connected graph. However, looping back after step 3, we can observe that shortest paths from a designated source node s actually form a tree! So we’ll go with the following speciﬁcation: An instance of the Weighted Shortest Paths (WSP) problem consists of • an undirected, connected graph G = (V, E), together with • a weight function w, where w(u, v) is the weight of edge (u, v) ∈ E, and w(u, v) > 0, and • a start node s. So, the input to an algorithm is (G, s, w). A good solution is a shortest path tree rooted at s: the path from s to every node v in the tree should be a path of minimum cost. Step 3: Identify similar problems. What are the similarities? SOLUTION: Constructing a bfs tree is similar, since it solves the problem for unweighted graphs. 5 Step 4: Evaluate simple algorithmic approaches. Here we’ll explore a way to solve WSP by “reducing” it to BFS. For this, we’ll assume that each weight is a positive integer. 1. How can we transform (i.e., “reduce”) our WSP example instance into an unweighted bfs input, while preserving distances? Fill in the corresponding bfs instance on the right. SOLUTION: Here is a transformed instance that works: 2. Now, describe the more general “Transform instance algorithm” and “Transform solution algorithm” in the picture below, for arbitrary instances of WSP. SOLUTION: Transform instance algorithm: for each edge e = (u, v) of G with weight w = w(u, v) do add w − 1 intermediate nodes, say ie,1, ie,2, . . . , ie,w−1 remove edge (u, v) add edges (u, ie,1), (ie,1, ie,2), . . . , (ie,w−1, ie,w−1), (ie,w−1, v) return the resulting graph G′ = (V ′, E′), and also s Transform solution algorithm: Let the BFS solution be the tree T ′ = (V ′, p′[1..n′]) (with p[s] = null). while T ′ = (V ′, p′) has intermediate nodes do let i be some intermediate node, with child j remove i, by setting p′[j] = p′[i] let p[1..n] be the entries of the parent array p′ for the nodes of V return the tree T = (V, p[1..n]) 6 3. Explain why the reduction algorithm is correct. SOLUTION: Important note: A correctness argument should refer explicitly to both the transform instance and the transform solution algorithms. Here we can say that: (i) The instance transformation algorithm preserves path costs between nodes of V . That is, for any pair of nodes u, v ∈ V , there is a path of total cost C between u and v in G if and only if there is a path of cost C between u and v in G′. To see the \"only if\" direction, for each edge e = (x, y) along the cost-C path from u to v in G, the path in G′ simply follows the corresponding edges x, ie,1, . . . , ie,w−1, y which have total cost w(x, y). To see the \"if\" direction, note that any (simple) path in G′ between two nodes x, y of G that only contains intermediate notes must go through exactly the nodes x, ie,1, . . . , ie,w−1, y in that order, with cost w(x, y), and so the total cost of a path in G′ is exactly the same as the cost of the corresponding path in G with the intermediate nodes removed. (ii) The solution transformation algorithm also preserves path costs between nodes of V . That is, for any pair of nodes u, v ∈ V , there is a path of total cost C between u and v in T ′ if and only if there is a path of cost C between u and v in T . The reasoning here is exactly the same as in part (i). So if the shortest path from s to v in G has cost Cv, then by (i), the shortest path from s to v in G′ has cost Cv. By correctness of bfs, the shortest path from s to v in T ′ has cost Cv, and then by (ii) the shortest path from s to v in T has cost Cv. So the overall reduction algorithm is correct. 4. What can you say about the running time of the reduction algorithm? (a) How many nodes does the graph G′ have, for the following WSP instance? SOLUTION: 140,000,000 nodes! (b) More generally, how many nodes does the graph G′ have? See if you can bound it as a function of n, the number of nodes of G, and the max edge weight W = max(u,v)∈E w(u, v). SOLUTION: The worst-case number of nodes in G′ is Θ(n2W ). This is because the worst-case number of edges in G is n(n − 1)/2 ∈ Θ(n2). And in the worst case, each edge might have the max edge weight W , which would add W − 1 new nodes to G′ for each edge. So, the total number of nodes would be the original n nodes, plus (W − 1)n(n − 1)/2, which is Θ(n2W ). In the best case, there’d be only one edge in G with weight W , and all the other edges (if any) would have weight 1. So, in the best case, G′ will have the original n nodes, plus W − 1 new nodes for that one edge in G with weight W . So, this is n + W − 1 ∈ Θ(n + W ). In either case, for large edge weights, this graph will be insanely big! 7","libVersion":"0.2.1","langs":""}