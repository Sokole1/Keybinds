{"path":".obsidian/plugins/text-extractor/cache/07fdd5725c43a80fca7a9fc4ad8fe367.json","text":"(124 I IS) 1ol g el () CIAVEM S R el T Consider the following code snippet: struct myStruct { int16_t *i@; int64_t i1; uintl6_t *i2; int64_t *i3; Y void func(struct myStruct p@, int64_t pl, int8_t *p2, struct myStruct *p3) { uint64_t arr[4]; // stop here Â¥ Assume: We paused a program just as it reached the comment // stop here , and we use 8-byte pointers. Below you indicate where to find various items. If the item is in a register, select that register and leave the offset blank. If it is on the stack, give the appropriate register and hexadecimal offset to find that item. If the offset needs to be negative, write it with a negative sign, e.g., -0x1. Offsets must be in the range -0x100000 to 0x100000. Hint: Start by drawing a stack diagram for each scenario! y86 reference sheet may be helpful. If we do not use a base pointer and we offset from the stack pointer, how would we access the following? m Offset (in hexadecimal) integer in base 16 (blank if no offset) (-] integer in base 16 (blank if no offset) (-] integer in base 16 (blank if no offset) (-] Under this same scenario and assuming that the value of the stack pointer is 0xd360, give the memory address in hexadecimal where the return address is located. Address = integer in base 16 (-]","libVersion":"0.2.1","langs":"eng"}