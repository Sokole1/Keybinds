{"path":".obsidian/plugins/text-extractor/cache/6e0a76bfd3a74b7f5542a64ed3788e3a.json","text":"CPSC 320: Graph Play Solutions∗ Here you’ll gain experience with design and analysis of graph algorithms, starting with graph search algorithms and then moving on to ﬁnding the diameter of a graph. 1 Graph Search Algorithms We use G = (V, E) to denote a graph, where V is a ﬁnite set of nodes and E is a set of edges. Often we use n to denote the number of nodes, and assume that V = {1, 2, . . . , n}. Edges are pairs (u, v) of adjacent nodes. In this worksheet, edges are undirected: there is no implied ordering (“arrow”) from u to v. Usually we assume that u ̸= v, in which case the graph is simple. G may or may not be connected. For this worksheet, all edges are unweighted. A handy data structure for describing the edges of a graph is adjacency lists: there is one list per node, and the list for node u includes exactly those nodes v that are “neighbours” of u, that is, such that (u, v) ∈ E. 1. Illustrate the notation deﬁned above, for a graph with node set V = {1, 2, 3, 4}. Draw a graph using your favourite representation. Write the set of edges E using set notation. Draw an adjacency list representation of the edges. SOLUTION: Here is a sample graph with E = {(1, 4), (2, 4), (3, 4)}, and its adjacency list representation: 2. More generally, for any subset A ⊆ V , let N (A) = { neighbours of A} = {v ̸∈ A | v is adjacent to some u ∈ A}. Write down N ({2, 3}) for your graph above. SOLUTION: N ({2, 3}) = {4}. 3. Here’s a graph, derived from the London Underground, where nodes represent stations, edges are be- tween stations that are adjacent stops of a train (trains go in both directions so edges are undirected). The node marked s represents the Picadilly Circus station. Mark the set N (N ({s})). SOLUTION: ∗Copyright Notice: UBC retains the rights to this document. You may not distribute this document without permission. 1 Mystery Deﬁnition 1. Here’s a mystery inductive deﬁnition, pertaining to a connected graph G = (V, E) and a node s of V . L0 ← {s} d ← 1 while L<d ̸= V do ▷ L<d is deﬁned as ∪0≤i<dLi Ld ← N (Ld−1) − L<d d ← d + 1 Trace through the deﬁnition by annotating the following graphs. SOLUTION: 4. Can you describe the set Ld in a diﬀerent way, using plain English? SOLUTION: Ld is the set of nodes of distance exactly d from s. That is, the shortest path from s to a node in Ld has length d. 2 5. Prove that your English deﬁnition is equivalent to the inductive deﬁnition above. SOLUTION: Since the deﬁnition starts with d = 0 and iterates with d = 1, 2, . . ., induction is a reasonable approach. We want to show: Claim: Ld is the set of nodes of distance d from s. The base case is when d = 0. L0 is simply the set {s}, and indeed s is the only node of distance 0 from s, so the claim holds in this case. Let d ≥ 1. Our inductive hypothesis supposes that Ld′ is the set of nodes of distance d′ from s, for all d′, 0 ≤ d′ < d. Our inductive step is to show that Ld is the set of nodes of distance d from s. We’ll let Sd be the set of nodes of distance d from s. When showing that two sets are equal, it’s natural to have two cases: • First we show that Sd ⊆ Ld. Let v ∈ Sd. This means that v is adjacent to some u ∈ Sd−1, i.e., v ∈ N (Sd−1). By the inductive hypothesis we have that Sd−1 = Ld−1, and so v ∈ N (Ld−1). Also by the inductive hypothesis, v ̸∈ ∪1≤i≤d−1Li, since otherwise v would have distance < d from s, which is not true. Therefore v ∈ N (Ld−1) − ∪1≤i≤d−1Li = Ld (by deﬁnition). • Second we show that Ld ⊆ Sd. See if you can do this direction yourself. 3 6. Here is a pseudocode implementation of the mystery deﬁnition, that constructs the sets Ld. procedure Construct-Level-Sets(s) for each v ∈ [1..n] do explored[v] ← false ▷ v is not yet in a level set L0 ← {s}; explored[s] ← true; d ← 1 while L<d ̸= V do Ld ← ∅ for each u ∈ Ld−1 do for each v adjacent to u do if explored[v] == false then add v to Ld; explored[v] ← true d ← d + 1 To establish that this is a correct implementation, each of the following statements attempt to relate the implementation code to the sets Sd. Recall that Sd is the set of nodes of distance d from s. If the statement is not true modify it slightly so that it is true. • At the start of iteration d ≥ 1 of the while loop, for any node v, explored[v] is true if and only if v ∈ Sd. SOLUTION: FALSE. The key insight is that the explored array is just a representation of the set S<d (or equivalently L<d, as we proved earlier). Therefore, we can modify the statement: replace Sd with S<d. • Within iteration d of the while loop, for any v, the body of the if statement is executed if and only if v ∈ N (Sd−1). SOLUTION: FALSE. The body of the if statement is executed if and only if v ∈ N (Sd−1) − S<d. • When the algorithm completes, all nodes in V are explored. SOLUTION: TRUE. Assuming that the algorithm completes, all nodes are in some set Ld′ for some d′ < d, and any time a node v is added to one of these sets, explored[v] is set to true. (To show that the algorithm terminates, we rely on our assumption that G is connected.) A proof of correctness of this pseudocode implementation can be adapted slightly from the inductive proof of correctness in part 5, integrating in these statements. 4 7. We’ll make one small change to the Construct-Level-Sets algorithm, to record the parent u of each node v once explored[v] becomes true: procedure Construct-Level-Sets′(s) for each v ∈ [1..n] do explored[v] ← false ▷ v is not yet in a level set L0 ← {s}; explored[s] ← true; d ← 1 while L<d ̸= V do Ld ← ∅ for each u ∈ Ld−1 do for each v adjacent to u do if explored[v] == false then add v to Ld; explored[v] ← true p[v] ← u ▷ this is the new line of code! d ← d + 1 8. Let P be the set containing the undirected edges (v, p[v]), for all v ∈ V . • Explain brieﬂy why the graph (V, P ) is connected. SOLUTION: When a node v is added to some Ld, an edge is added between v and some node u that is already connected to s. • How many edges are in the graph (V, P )? SOLUTION: There is one edge for every v in V , where v ̸= s. So n − 1 edges in total. • A beautiful theorem, stated in Tardos and Kleinberg (page 78, (3.2)) is that if G is an undirected graph on n nodes, then any two of the following statements implies the third. (i) G is connected. (ii) G is acyclic, i.e., is a tree. (iii) G has n − 1 edges. Use this theorem, plus the previous two facts to show that (Vs, P ) is a tree. This is the breadth ﬁrst search tree! SOLUTION: By the previous two parts (i) and (iii) hold, so (ii) holds also. 5 9. We’ll make one ﬁnal change to our algorithm, so that we compute the shortest path distance ds[v] of each node v from s. A nice side-eﬀect is that we can use this distance array instead of the “explored” array to keep track of explored nodes. Fill in the missing condition of the if statement. SOLUTION: procedure BFS(s) for each v ∈ [1..n] do ds[v] ← ∞ L0 ← {s}; ds[s] ← 0; d ← 1 while L<d ̸= V do Ld ← ∅ for each u ∈ Ld−1 do for each v adjacent to u do if ds[v] == ∞ then ▷ the missing condition is here. add v to Ld; ds[v] ← d p[v] ← u d ← d + 1 10. Suppose you want to ﬁnd the route with the fewest stops from Picadilly Circus Station to every other station of the London Underground. How could you do it? SOLUTION: Note that this question is phrased poorly, so we clariﬁed it in lecture. The question is intended to ask you to ﬁnd, for each other station in the London Underground individually, the route with the fewest stops from Picadilly Circus Station to that station. However, a very natural reading of the question as written is to ﬁnd a single route that goes from Picadilly Circus Station to every other station along the way. That’s actually a variant of the famous Traveling Salesperson Problem, which we might discuss when we get to NP-completeness, late in this course. Once we have clariﬁed what’s being asked, the problem is easy, given that we have just been studying BFS: Run bfs on the graph whose nodes are stations and edges are direct connections, and with s being Picadilly Circus. The BFS tree gives you a shortest route to each station. 11. Draw the tree BFS(a) for each of the following graphs. Then, for each edge (u, v) that is not in the tree, connect u and v with a dashed edge. SOLUTION: Sample bfs trees, with dashed edges added: 67 12. Here is an algorithm to construct a depth-ﬁrst search tree of G = (V, E), starting from node s. procedure DFS(s) for each i ∈ [1..n] do explored[v] ← false Helper-DFS(s) procedure Helper-DFS(u) explored[u] ← true for each v adjacent to u do if explored[v] is false then p[v] ← u Helper-DFS(v) Draw sample trees that could be produced by DFS(a) for each of the graphs of part 11. Again, for each edge (u, v) that is not in the tree, connect u and v with a dashed edge. SOLUTION: Sample dfs trees: 13. More generally (i.e., not just for the examples above), consider the level of a node in the trees bfs(s) or dfs(s) as the distance of the node from s. • Could a bfs tree rooted at s have a dashed edge from node s to a node at level 3? SOLUTION: No. All nodes that are neighbours of s must be at level 1. • Could a dfs tree have dashed edges between nodes at the same level of the dfs tree? SOLUTION: No. Suppose that u and v are both the same distance from node s in the DFS tree. Let’s consider two cases. Case 1: If there is no edge between u and v in the original graph, then there is no edge (dashed or not) between u and v when we draw the DFS tree. Case 2: If there is an edge between u and v in the original graph, assume without loss of generality that u is visited before v by the DFS. In that case, u must be an ancestor of v in the DFS tree (because the DFS will either go straight from u to v along the edge that connects them, or it might ﬁnd a diﬀerent route through other vertices from u eventually to v, but in either case, the DFS must get to v before the DFS returns to u’s parent). This contradicts the assumption that u and v are the same distance in the DFS tree from the root s, since u is closer to the root than v is. Therefore, in both cases, there is no way to have a dashed edge between “siblings” when drawing the DFS tree. 8","libVersion":"0.2.1","langs":""}