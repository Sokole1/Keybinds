{"path":".obsidian/plugins/text-extractor/cache/57b135114d82f61ae2aac99bcbc0d375.json","text":"Name: Student #: Midterm Exam 1, CPSC 302, Fall 2012 Oct. 10, 2012 Instructions : ‹ Make sure this exam has six pages, printed two-sided, on three stapled sheets of paper. ‹ Write down your name and student number in the designated spot on the top of this page. ‹ Time: 45 minutes. ‹ Total three questions and 15 marks, 5 for each question. Marks for question parts are speciﬁed in square brackets on the right. ‹ No material is allowed other than your pen/pencil and this exam. ‹ Read the questions carefully. ‹ Show your work only if asked. Most answers are required to be very short. ‹ G O O D L U C K !! 1 1. [Total 5 marks for this question] The IEEE 754 ﬂoating system with double precision uses base β = 2 and has 52 bits in its mantissa, plus one more leading bit which is not explicitly stored. This system allows us to represent numbers with approximately 16 correct decimal digits. The largest ﬁnite positive number that can be represented on the system is approximately 1.8 × 10 308. We are required to compute expressions of the form f (x) = √x2 + 0.01 − √x2 − 0.01 on this system, where x is large in absolute value. (a) Suppose we need to compute f (x) for a thousand numbers, given in a vector x, and we store the results in a vector f. A short Matlab script that does it is: for i=1:1000 f(i)=sqrt(x(i)^2+0.01)-sqrt(x(i)^2-0.01); end Rewrite this script in a vectorized fashion, using a single Matlab command. Make sure to write the command, particularly the operators that are involved, in the clearest possible way, large and clear, without any ambiguities. [1 mark] Proceed to part (b) on next page 2 (b) Consider the computation of the same function as in (a), namely f (x) = √x2 + 0.01 − √ x2 − 0.01, for the following three numbers on the same IEEE 754 double precision system: ‹ x1 = −10 5; that is, we are computing f (−10 5) ‹ x2 = 10 10; that is, we are computing f (10 10) ‹ x3 = 10 200; that is, we are computing f (10 200) For the following questions, there is no need to justify your answer. i. Write down the number or numbers xi (if there are any) for which overﬂow will occur. [1 mark] ii. Write down the number(s) xi (if there are any) for which no overﬂow will occur but a cancellation error will occur which causes the resulting computation to be zero. [1 mark] iii. Rewrite the formula for f (x) in a way that makes it more suit- able for numerical computations and avoids some situations of overﬂow and cancellation errors. [2 marks] 3 2. [Total 5 marks for this question] The function f (x) = x · (x − 1)2 has two zeros, x∗(1) = 0 and x∗(2) = 1. (a) Suppose bisection is applied on an IEEE double precision ﬂoating point system, starting from an initial interval [a, b], where a < 0 and b > 1. i. Explain brieﬂy why this initial interval is a valid choice for the bisection algorithm. [1 mark] ii. Suppose the speciﬁc choice [a, b] = [−1, 2] is made for the initial interval. To which of the two points will bisection con- verge? A. it will converge to x∗(1) = 0 B. it will converge to x∗(2) = 1 C. it will converge randomly to one of x∗(1) = 0 or x∗(2) = 1, depending on roundoﬀ errors D. none of the above answers is correct Justify your answer brieﬂy. (No marks for a circled answer without a correct justiﬁcation.) [1 mark] Proceed to part (b) on next page 4 (b) Suppose Newton’s method is applied to the same function as in part (a), f (x) = x · (x − 1) 2, once with an initial guess x0 = 0.1 and once with x0 = 1.1. The iterations converge in those two cases to x∗(1) = 0 and to x∗(2) = 1, respectively. A student has computed for x0 = 0.1 the values of e (1) k = |xk − x∗(1)| = |xk − 0| = |xk|, and for x0 = 1.1 the values of e (2) k = |xk − x∗(2)| = |xk − 1|. These errors for the initial guess and the ﬁrst four iterations have been recorded in Tables 1 and 2 below, but there has been a mixup and the student does not remember which table represents the convergence to which root, because he/she forgot to write for each ek whether it is e (1) k or e(2) k . Table 1: k 0 1 2 3 4 ek 0.1 0.0286 0.0015 4.5023 × 10 −6 4.0540 × 10 −11 Table 2: k 0 1 2 3 4 ek 0.1 0.0522 0.0267 0.0135 0.0068 In the questions below, there is no need to provide a justiﬁcation. i. Determine which of Table 1 and 2 refers to e (1) k and which one refers to e (2) k , by circling the correct answers: ‹ ek in Table 1 refers to e(1) k /e(2) k (← CIRCLE ONE) and ek in Table 2 refers to e(1) k /e (2) k (← CIRCLE ONE) [1 mark] ii. Determine the speed of convergence (either linear or quadratic) for each of the roots, by circling the correct answers: ‹ Convergence to the root x∗(1) = 0 is linear / quadratic (CIRCLE ONE) [1 mark] ‹ Convergence to the root x∗(2) = 1 is linear / quadratic (CIRCLE ONE) [1 mark] 5 3. [Total 5 marks for this question] Consider the function f (x) = e √x − a, where a is a positive real number. The derivative of f (x) is given by f ′(x) = e √x 2 √ x . This function has a unique positive root, 0 < x ∗ < ∞, (there is no need to show it), and suppose we are using Newton’s method to ﬁnd it. (a) Write down Newton’s method without simplifying it. [1 1 2 marks] (b) Simplify the formula, avoiding redundant operations, to make it suitable for an eﬃcient numerical computation. [1 1 2 marks] (c) When you run Newton’s method, Matlab calls the built-in exp and sqrt functions. Assuming your code is as eﬃcient as possible, what is the number of built-in function calls per iteration (no need to justify): i. of the exponential function exp; [1 mark] ii. of the square root function sqrt. [1 mark] 6","libVersion":"0.2.1","langs":""}