{"path":".obsidian/plugins/text-extractor/cache/0621e86ab432b9e2c5f3d127b1e52c4c.json","text":"CPSC 320 Midterm Examination October 20th, 2020, 19:00 to 20:30 \u0015 You have 75 minutes to write the 4 questions on this examination. A total of 40 marks are available. \u0015 Justify all of your answers. \u0015 You are allowed to access the course web site, Canvas, your notes, the textbook and (only to ask a question if you believe you have found an error on the exam) private posts on Piazza, but not other web sites. You are not allowed to contact people other than the course sta˙. \u0015 Keep your answers short. If you run out of space for a question, you have written too much. \u0015 The number in square brackets to the left of the question number indicates the number of marks allocated for that question. Use these to help you determine how much time you should spend on each question. \u0015 Use the back of the pages for your rough work. \u0015 Good luck! UNIVERSITY REGULATIONS: \u0015 Each candidate should be prepared to produce, upon request, his/her UBC card. \u0015 CAUTION: candidates guilty of any of the following, or similar, dishonest practices shall be immediately dismissed from the examination and shall be liable to disciplinary action. 1. Having at the place of writing, or making use of, any books, papers or memoranda, electronic equipment, or other memory aid or communication devices, other than those authorised by the examiners. 2. Speaking or communicating with other candidates. page 2 out of 8 1 An hopefully easy beginning a. [4 marks] Express the best-case and worst case running time of the following algorithm as a function of n, where n is the length of a 0-indexed array A. Justify your answers brie˛y. function mystery2(A, n) step ← n/2 // integer division while step > 0 do for i ← 0 to step - 1 do if i + step < n then if A[i] < A[i + step] then swap A[i] and A[i+step] // End of the for loop. step = step / 2 // integer division return A[0] Solution : This algorithm's best case and worst case running times will be the same, because there is no way to break out of the while loop early. Observe that ‹ During the ˝rst iteration of the while loop, the for iterates ⌊n/2⌋ times, each iteration taking constant time. ‹ During the second iteration of the while loop, the for iterates ⌊n/4⌋ times, each iteration taking constant time (we've divided step by 2). ‹ During the third iteration of the while loop, the for iterates ⌊n/8⌋ times, each iteration taking constant time (we've divided step by 2 again). ‹ . . . Hence the total number of iterations of the body of the for loop is ⌊n/2⌋ + ⌊n/4⌋ + ⌊n/8⌋ + ⌊n/16⌋ + · · · which is in Θ(n) (this is a geometric series). b. [6 marks] Show that in any execution of the Gale-Shapley algorithm, with employers making the job o˙ers, at most one employer may be matched with the applicant it ranked last. Hints: ‹ Look at the ˝rst time in the execution of the algorithm that an employer makes an o˙er to its last ranked applicant. ‹ What do we know about an applicant that has received an o˙er? ‹ The proof is three or four sentences long. Solution : Consider an arbitrary execution of the Gale-Shapley algorithm, with employers making the job o˙ers. Suppose that at some point in this execution, employer e makes an o˙er to the applicant a this employer has ranked last, and this is the ˝rst time such an o˙er to a least-preferred applicant is made. This means e has already made a job o˙er to every other applicant on its list. So at that point every other applicant is matched to a company, which means that every other employer is matched. Consequently the algorithm will terminate with e's o˙er, and no other employer will make an o˙er to the applicant they rank last. page 3 out of 8 2 A Greedy continuation For this problem, imagine that you are writing the software for a robot that is supposed to ˝ght ˝res in hazardous environments, like a nuclear reactor or chemical plant. We consider the environment to be laid out in a rectangular grid that is w squares wide and h squares high. Your software should make the robot move from square to square until it reaches the square with the ˝re, whereupon the robot releases its ˝re extinguisher. For example (and this is only an example \u0016 your code should work in an arbitrary layout), consider this layout: R F This grid is 7 squares wide and 5 squares high. The very light dotted lines mark the boundaries of the squares. The dark solid black lines are walls, which the robot cannot move through. (The walls also block smoke and chemicals from the ˝re. More on this in a moment.) The orange dashed line shows a path that the robot could take to get to the ˝re: this path entails moving up for 3 squares, then right for 1 square, then down for 3 squares, then right for 4 squares, then up for 2 squares, then left for 1 square, for a total of length of 14 squares ( 14 = 3 + 1 + 3 + 4 + 2 + 1). A better path for the robot would be the dash-dotted green path, which has a total length of only 10 squares, and for this example, that's the shortest path from the robot to the ˝re. To control the robot, the software relies on an API with only these 4 functions: sense() This function makes the robot use its chemical sensors to measure the presence of combustion products coming from the ˝re. It returns a positive real number that gets larger the closer the robot is to the ˝re. Note that \u0010closer\u0011 is de˝ned by the length of the shortest path to the ˝re, without going through walls (since the walls block the combustion products). Other than that, we don't know anything about the numbers returned by the function. For example, for the layout above, this diagrams shows numbers that might be returned by sense() if called in each square: 8.68.3 8.3 8.2 8.0 7.5 7.5 7.4 7.4 7.4 7.0 7.0 7.0 6.5 6.5 6.5 6.0 6.0 6.0 5.0 5.0 5.0 4.0 4.0 4.04.0 3.0 3.0 3.03.0 2.0 2.0 2.0 1.0 0.3 move(direction) This causes the robot to move 1 square in the indicated direction. The legal directions are \u0010up\u0011, \u0010down\u0011, \u0010left\u0011, and \u0010right\u0011. The robot is ˝reproof and can move through the square with the ˝re without harm. However, if the robot tries to move through a wall, it crashes and fails. page 4 out of 8 scan() This function helps you avoid crashing into walls. The function makes the robot use its laser range˝nder to determine which directions the robot can move (for one square) without hitting a wall. It returns a set of legal directions to move. For example, in the ˝gure above, if the robot called sense() in the position marked R, the call would return the set {up , down }. extinguish() This function causes the robot to spray all of its ˝re extinguishing chemicals into the square where it currently is, and then the robot stops executing any further commands. a. [8 marks] Devise an algorithm to direct the robot to the ˝re and then extinguish it, using worst-case O(p) API calls, where p is the length of the shortest path from the robot's initial position to the ˝re. (E.g., in the example above, p = 10. But remember that you are solving this problem in general , not just for the example above!) Write your algorithm in pseudocode that uses the above API; your pseudocode must be detailed enough to use the API directly, e.g., making individual sense() and move() calls, and not having statements like \u0010Call sense() in all adjacent squares\u0011 or \u0010Move right until reaching a wall\u0011. You may assume that there is always a path from any square to the square with the ˝re. Note that excessively complex solutions will be penalized. Write your pseudocode here: (Hint: This problems's title is \u0010Greedy Algorithms\u0011, so you'll want to make a greedy algorithm. But you have to be careful not to be too greedy. How can the robot ˝gure out a good direction to travel without taking too much time?) Solution : To streamline the solution, we'll de˝ne a function opposite , so that opposite(up)=down , opposite(down)=up , opposite(left)=right , and opposite(right)=left . This function obviously takes O(1) time. Our solution works by checking the (up to) four directions the robot can go. We'll always go whichever direction takes us closest to the ˝re. From there, we repeat. If no direction takes us closer to the ˝re, then we know we're at the ˝re, so we spray the ˝re extinguisher. 1: while true do 2: Let bestdirection = none 3: Let bestsense = sense() 4: Let directions = scan() 5: for d ∈ directions do ▷ Try all legal directions 6: move( d) 7: if sense() >bestsense then 8: bestsense=sense() 9: bestdirection = d 10: end if 11: move(opposite( d)) 12: end for 13: if bestdirection == none then 14: extinguish() ▷ Must be at the ˝re. 15: end if 16: move(bestdirection) 17: end while b. [4 marks] Brie˛y justify why your algorithm correctly ˝nds the ˝re and extinguishes it, and why it makes worst-case O(p) API calls. Your answer doesn't have to be a fully formal proof, but it must be clear and logically correct. Solution : We are given that there is always a path from any square to the ˝re, which means that there is always a shortest path. Because sense() is always higher from any square that is closer to the page 5 out of 8 ˝re, then by chosing the adjacent square with the highest value of sense(), it guarantees that we make a move along a shortest path to the ˝re (since that's the move that takes us as much closer to the ˝re as possible). Therefore, the number of iterations of the outer while loop is equal to p, and the algorithm extinguishes the ˝re when moving in any direction reduces the value of sense(), which means that it sprays the extinguisher when in the square with the ˝re. The number of API calls is O(p) because we make p iterations of the outer loop, and in each loop iteration, we make at most a constant number (19, if I count correctly) of API calls. 3 Runtime and Measures of Progress The following code is a small function written in Python: def rewrite( str ): while \"10\" in str: str = str.replace(\"10\",\"01\",1) print str return The loop condition checks whether the substring \u001010\u0011 occurs in the string str , and the assignment statement replaces the ˝rst occurence of the substring \u001010\u0011 with the substring \u001001\u0011. For example, if the function is called on: rewrite(\"0101\") it will print the following output: 0011 a. [2 marks] On the time-limited \u0010test\u0011 you wrote a couple weeks ago, there was a very similar-looking problem, where the while loop replaced instances of \u0010Alan\u0011 with \u0010Patrice\u0011. For that problem, a simple progress measure was the number of copies of \u0010Alan\u0011 in the string. For this problem, it might therefore be tempting to try to use the number of copies of \u001010\u0011 in the string as a progress measure. Give an example string for which this attempted progress measure doesn't work correctly, and brie˛y explain why this is not a good progress measure for this while loop. Solution : Consider a string like \u0010100000\u0011. (An in˝nite number of other examples exist and would be full credit solutions.) When the loop body replaces the 10 with 01, we get 010000. But note that we still have the same number of copies of \u001010\u0011 in the string! So, by this attempted progress measure, the loop didn't make any progress, so this isn't a good progress measure. b. [3 marks] De˝ne a progress measure for the while loop that does work, and use it to prove that the loop always terminates. If you wish, you may assume the string str consists of only 0s and 1s (mixed up in any order). (Hint: You might think about progress measures that work for sorting.) Solution : Many di˙erent progress measures could work, but following the hint, de˝ne an inversion as any instance of a 1 appearing anywhere in the string before any instance of a 0. For example, the string 1100 has 4 inversions. The number of inversions can't go negative, and every time the loop body runs, it decreases the number of inversions by 1, so the loop has to terminate. Here's another measure of progress that would work: add up the positions of every 1 in the string. Each time the loop executes, it increases this quantity by 1. But the quantity can't possibly exceed n(n − 1)/2 (which would happen if the entire string were 1s), so the loop has to terminate. page 6 out of 8 c. [3 marks] Let n be the original length of the string str that is passed to the function. Give a tight big- Θ bound on the worst-case number of times that the loop body executes, in terms of n. Brie˛y justify your answer. Solution : Θ(n2). Both progress measures in the preceding part gave us O(n2) bounds. To see that this is tight in the worst case, consider a string like \u00101111...11111100000...00000\u0011, which consists of n/2 1s, followed by n/2 0s. The loop will spend n/2 iterations to bubble the ˝rst 0 to the front of the list, then another n/2 iterations to bubble the next 0 to the second position of the list, etc., for a total of (n/2)2 iterations, which is Ω(n2). 4 And a reduction to ˝nish things o˙ In this question, we will revisit reductions to the ISGM problem you encountered in assignment 2. Recall that this problem is de˝ned by: Given an undirected graph G = (V, E) with vertices V and edges E, an integer (positive, zero, or negative) weight hv for each v ∈ V , and an integer (positive, zero, or negative) weight Ju,v for each edge {u, v} ∈ E, ˝nd an assignment of +1 or −1 to the variables xv for each v ∈ V that minimizes the objective function: (∑ v∈V hvxv ) +   ∑ (u,v)∈E Ju,vxuxv   We will consider a reduction from the Vertex Cover problem, de˝ned as follows: Given an undirected graph G = (V, E) with vertices V and edges E, and an integer k, ˝nd a vertex cover of G: a subset V ′ of V with k elements such that every edge in E has at least one endpoint in V ′. Given the graph G, we construct an instance I of ISGM as follows: ‹ Every vertex u of G will be a vertex uI of I with weight 1. ‹ For each edge {u, v} of G, we add the following subgraph to I: h1 = −4 h2 = 2 h3 = 2huI = 1 hvI = 1 h4 = −3 J1,4 = −2 J 1 , 2 = − 4 J 1 , 3 = − 4 J2,3 = 2JuI ,2 = −2 J3,vI = −2 This is essentially the graph used for an OR gate in the assignment, except that we have doubled all of the weights and added an \u0010output\u0011 node (the one on the right on the top row). Recall that the values assigned to the vertices of the triangle will contribute a value of −6 if that triangle behaves like a proper OR gate, and of at least +2 if it does not (this is twice the corresponding values from assignment 2 since we doubled all of the edge weights). page 7 out of 8 a. [5 marks] Based on the ISGM solution, how/when can you conclude that there is a vertex cover of V with at most k vertices? Brie˛y justify your answer. (Once again, your answers should be fairly short). Solution : First, please note that this explanation is a lot more detailed than what we expected you to write on the exam. For simplicity, we will talk about assigning values to vertices of the ISGM instance instead of the variables corresponding to these vertices, and we will also refer to the vertices by their weights (so h4 will refer to the top vertex of the triangle in the ˝gure). Given a vertex cover with k vertices, we can assign the following values to the variables corresponding to the vertices of the ISGM instance ‹ We assign +1 to each vertex of the ISGM instance that corresponds to an element of the vertex cover of G. ‹ We assign −1 to each vertex of the ISGM instance that corresponds to an element of V that is not in the vertex cover of G. ‹ We assign to the vertices h2 and h3 of each OR-gate subgraph the same value as those assigned to the neighbouring vertex of G. ‹ We assign +1 to each vertex h4 of each OR-gate subgraph and to each\u0010output\u0011 node of the ISGM instance. Because we started from a vertex cover of G, at least one of h2, h3 in each OR-gate subgraph will be assigned the value +1, and so the contributions to the objective function of the 4 new vertices and 6 edges of the ISGM instance that correspond to an edge of G will be ‹ −6 for each OR-gate subgraph; ‹ −4 for the two edges connecting it to two vertices of G; ‹ −2 for the connection to the \u0010output\u0011 node; ‹ and −3 for the output node itself; for a total of −15. Each vertex of G will contribute +1 to the objective function if it's in the vertex cover, and −1 if it's not. So the value of the objective function will be −15|E|+k−(|V |−k) = −15|E|−|V |+2k. We thus conclude that if there is a vertex cover of G with at most k vertices then the value of the minimum objective function is ≤ −15|E| − |V | + 2k. We will claim there is a vector cover of G with at most k vertices when the value of the ISGM solution is ≤ −15|E| − |V | + 2k (the proof that this is correct is in the answer to part (b)). b. [5 marks] If the ISGM solution does indicate that there is a vertex cover of G with at most k vertices, explain how to extract that vertex cover of G from the ISGM solution. Brie˛y justify your answer, speci˝cally why this will be a vertex cover of G with at most k vertices. Solution : Suppose the value f (G) of the minimum objective function is ≤ −15|E| − |V | + 2k. We make the following observations: ‹ Every OR-gate subgraph must behave like an OR-gate in the ISGM solution, because if it didn't we could make f (G) smaller by switching the value of h1 to the correct output for an OR gate ( f (G) goes down by at least 8), and switching the value of h4 to the same thing ( f (G) would go up by at most 6). page 8 out of 8 ‹ Every \u0010output\u0011 node must be assigned the value +1: if not, it must be that both h2 or h3 of the corresponding OR-gate subgraph were assigned −1. We can then make f (G) smaller by assigning +1 to one of h2 or h3 ( f (G) goes up by at most 4), assigning +1 to the \u0010output\u0011 node ( f (G) goes down by 6) and then making sure the OR-gate subgraph behaves like an OR-gate. ‹ Each vertex v of G connected to the node h2 or h3 in the OR subgraph must have the same value as that node, as otherwise \u0015 If the value of v is +1 then we can switch the value of h2 or h3 to +1 ( f (G) goes down by 4) and then adjusting the OR-gate subgraph and the \u0010output\u0011 node (which will remain at +1). \u0015 If the value of v is −1 then we can switch it to +1; f (G) increases by 2 for that, but then decreases by 4 because the endpoints of the edge now have the same value. It follows from these three observations that at least one endpoint of each edge must be assigned the value +1. We use these vertices as our vertex cover. There can be at most k of them because every edge brings a cost ≤ −15|E| to the objective function, and so the vertices account for ≤ −|V | + 2k of the value, meaning there are at most k of them.","libVersion":"0.2.1","langs":""}