{"path":".obsidian/plugins/text-extractor/cache/02e69aa25a3a15e7eed8dfd512012fb7.json","text":"Nick Bradley & Katharine K err F or personal use only, please do not distribute on non-UBC domains. Module 4: Construction CPSC 310 CPSC 310: Introduction to Software Engineering Details about the ﬁrst project journal have been posted online. ● Due: F riday Jan 17th at 6pm ● Check Course W ebsite for Submission and Grading Details: To receive full marks for your journal: 1. You must F ormat and Submit the Journal as per the speciﬁcation 2. Your journal must be organiz ed and easy to read. 3. You must attend your lab. P roject journal CPSC 310: Introduction to Software Engineering L earning areas All course content can be attributed to six k ey learning areas: 1. Construction & Refactoring 2. Testing 3. P rocess & Requirements 4. E thics & Security 5. High-L evel Design 6. L ow-L evel Design CPSC 310: Introduction to Software Engineering L ecture L earning Outcomes By the end of this lecture, you will be able to answer: ● Why do we need asynchronous programming? What are the challenges it brings? ● How does Javascript suppor t asynchronous tasks? ● How static and dynamic types diﬀer? ● What is a linter and why are linters impor tant tools? Languages CPSC 310: Introduction to Software Engineering Examinable skills: ● Explain why diﬀerent languages e xist. ● Diﬀerentiate syntax and semantics. ● Describe how static and dynamic typing are diﬀerent. ● Understand how static analysis works. ● Explain how linting is used to improve the quality of most software systems. ● Describe why async functions e xist. ● Describe how async functions e x ecute in Node/browser. ● Be able to write and understand straightfor ward functions using async/await, promises, and callbacks. Languages Async img: Annie Ying CPSC 310: Introduction to Software EngineeringCPSC 310: Introduction to Software Engineering Concurrency • What is concurrency? • Ex ecuting multiple program par ts at the same time. • Actual ordering is indeterminate. • Why is it hard? • Shared state! W before R diﬀ than R before W • Deadlock / live lock / resource star vation • Why would we ever want to run code concurrently? • Computation gains driven by cores; avoids blocking CPSC 310: Introduction to Software Engineering Why is blocking a problem? http://rb y ers.github .io/scroll-latency.html CPSC 310: Introduction to Software Engineering Async is for long running processes Used in the project! ● setTimeout() ● File I/O ○ Reading a ﬁle from disk ○ W riting a ﬁle to disk ● Network Requests ○ Getting the permissions for a user ○ Uploading a video to youtube CPSC 310: Introduction to Software Engineering setT imeout(...) setTimeout ( function () { console . log ( \"Hello\" ); }, 1000 ); CPSC 310: Introduction to Software Engineering setT imeout(...) setTimeout ( function () { console . log ( \"Hello\" ); } , 1000 ); C allback function After 1000ms (1s), e x ecute the callback function . CPSC 310: Introduction to Software Engineering Why would we do this? function makeItSo () { … setTimeout ( function () { // do the long thing }, 0 ); … } CPSC 310: Introduction to Software Engineering Anatomy of a callback const onComplete = function () { // function assigned to a var! }; setTimeout ( onComplete , 100 ); C allback function CPSC 310: Introduction to Software Engineering Error-ﬁrst callback idiom foo. action (msg, function ( err , data ){ if (err) { // handle return ; } else { // worked, use data } }); function start () { doIt (); } function doIt () { console . log ( \"start\" ); setTimeout ( function () { console . log ( \"done\" ); }, 2000 ); console . log ( \"end\" ); } start (); What will the output be? CPSC 310: Introduction to Software Engineering Non-trivial e xample Read ﬁrst ﬁle in a director y. CPSC 310: Introduction to Software Engineering Non-trivial e xample const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } Read ﬁrst ﬁle in a director y. CPSC 310: Introduction to Software Engineering Non-trivial e xample const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } Read ﬁrst ﬁle in a director y. Remember! File I/O is Asynchonous CPSC 310: Introduction to Software Engineering Non-trivial e xample const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } Read ﬁrst ﬁle in a director y. W e need to handle these methods CPSC 310: Introduction to Software Engineering W e can handle async… I pr omise callbacks pr omises async & await P re-2015(ish) 2009-2015 2017 CPSC 310: Introduction to Software Engineering W e can handle async… I pr omise callbacks pr omises P re-2015(ish) setTimeout ( function () { console . log ( \"Hello\" ); } , 1000 ); C allback function fs . readdir ( source , function (err, files) { Read ﬁrst ﬁle in a director y. // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } callbacks fs . readdir ( source , function (err, files) { if (err) { // handle } else { See if it work ed callbacks // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } fs . readdir ( source , function (err, files) { if (err) { // handle } else { fs . stat (files[ 0 ], function (err, stat) { if (err) { // handle } else { Check if it’s a ﬁle callbacks // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } fs . readdir ( source , function (err, files) { if (err) { // handle } else { fs . stat (files[ 0 ], function (err, stat) { if (err) { // handle } else { if (stat. isFile ()) { fs . readFile (files[ 0 ], function (err, data) { if (err) { // handle } else { // process data } Read the ﬁle callbacks // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } fs . readdir ( source , function (err, files) { if (err) { // handle } else { fs . stat (files[ 0 ], function (err, stat) { if (err) { // handle } else { if (stat. isFile ()) { fs . readFile (files[ 0 ], function (err, data) { if (err) { // handle } else { // process data } }); } } }); } }); Add many braces callbacks // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } fs . readdir ( source , function(err, files) { if (err) { // handle } else { fs . stat (files[ 0 ], function(err, stat) { if (err) { // handle } else { if (stat. isFile ()) { fs . readFile (files[ 0 ], function(err, data) { if (err) { // handle } else { // process data } }); } } }); } }); Add many braces callbacks // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } CPSC 310: Introduction to Software Engineering Classy Team P rovisioning • P rovisioning the projects: • 1) Get the Classy data [getCourse(name, cb)] • 2) In a huge loop: • a) Create a repo [createRepo(name, cb)] • b) Impor t the base repo [importRepo(repo, import, cb)] • c) Create the team [createTeam(name, cb)] • d) F or each team member: • Add member to the team [addMember(team, name, cb)] • e) P ut the team on the repo [addTeam(repo, team, cb)] • f ) Find the staﬀ team [findTeam(name, cb)] • g) P ut the staﬀ team on the repo [addTeam(repo, team, cb)] CPSC 310: Introduction to Software EngineeringCPSC 310: Introduction to Software Engineering P romise e x ecution states FULFILLED REJECTED SETTLED PENDING then (args:<T>) catch (reason:any) CPSC 310: Introduction to Software Engineering P romises (simpliﬁed) interface Promise < T > { then (result: < T >): Promise < T >; catch (reason: any ): Promise < T >; } CPSC 310: Introduction to Software Engineering Comparing to callbacks fs . readdir ( source , function (err, files) { if (err) { // handle error } else { // handle success } } callbacks pr omises fs . readdir ( source ) CPSC 310: Introduction to Software Engineering Comparing to callbacks fs . readdir ( source , function (err, files) { if (err) { // handle error } else { // handle success } } callbacks pr omises fs . readdir ( source ) . then ((files) => { // handle success }); CPSC 310: Introduction to Software Engineering Comparing to callbacks fs . readdir ( source , function (err, files) { if (err) { // handle error } else { // handle success } } callbacks pr omises fs . readdir ( source ) . then ((files) => { // handle success }). catch ((err) => { // handle error }); CPSC 310: Introduction to Software Engineering let file ; fs. readdir ( source ) Read ﬁrst ﬁle in a director y. Revisiting reading ﬁle // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } pr omises CPSC 310: Introduction to Software Engineering let file ; fs. readdir ( source ). then ( function (files) { file = files[ 0 ]; return fs. stat ( file ); }) Check if it’s a ﬁle Revisiting reading ﬁle // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } pr omises CPSC 310: Introduction to Software Engineering let file ; fs. readdir ( source ). then ( function (files) { file = files[ 0 ]; return fs. stat ( file ); }). then ( function (fileStat) { if (fileStat. isFile ()) return fs. readFile ( file ); }) Read the ﬁle Revisiting reading ﬁle // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } pr omises CPSC 310: Introduction to Software Engineering let file ; fs. readdir ( source ). then ( function (files) { file = files[ 0 ]; return fs. stat ( file ); }). then ( function (fileStat) { if (fileStat. isFile ()) return fs. readFile ( file ); }). then ( function (fileData) { // process data }) P rocess data Revisiting reading ﬁle // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } pr omises CPSC 310: Introduction to Software Engineering let file ; fs. readdir ( source ). then ( function (files) { file = files[ 0 ]; return fs. stat ( file ); }). then ( function (fileStat) { if (fileStat. isFile ()) return fs. readFile ( file ); }). then ( function (fileData) { // process data }). catch ( function (err) { // handle errors }); Handle errors Revisiting reading ﬁle // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } pr omises CPSC 310: Introduction to Software Engineering let file ; fs. readdir ( source ). then ( function (files) { file = files[ 0 ]; return fs. stat ( file ); }). then ( function (fileStat) { if (fileStat. isFile ()) return fs. readFile ( file ); }). then ( function (fileData) { // process data }). catch ( function (err) { // handle errors }); Handle errors // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } pr omisesRevisiting reading ﬁle CPSC 310: Introduction to Software Engineering async // declare that a result will eventually be returned await // tell the code to suspend execution until result exists • S yntactic sugar, T S compiles these to promises: async & await CPSC 310: Introduction to Software Engineering const files = await fs . readdir ( source ); Read ﬁrst ﬁle in a director y // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } async/awaitRevisiting reading ﬁle CPSC 310: Introduction to Software Engineering const files = await fs . readdir ( source ); const file = files [ 0 ]; Read ﬁrst ﬁle in a director y // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } async/awaitRevisiting reading ﬁle CPSC 310: Introduction to Software Engineering const files = await fs . readdir ( source ); const file = files [ 0 ]; const fileStat = await fs . stat ( file ); Revisiting reading ﬁle Check if it’s a ﬁle // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } async/await CPSC 310: Introduction to Software Engineering const files = await fs . readdir ( source ); const file = files [ 0 ]; const fileStat = await fs . stat ( file ); if ( fileStat . isFile ()){ Revisiting reading ﬁle Check if it’s a ﬁle // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } async/await CPSC 310: Introduction to Software Engineering const files = await fs . readdir ( source ); const file = files [ 0 ]; const fileStat = await fs . stat ( file ); if ( fileStat . isFile ()){ const fileData = await fs . readFile ( file ); // process data } Revisiting reading ﬁle P rocess Data // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } async/await CPSC 310: Introduction to Software Engineering try { const files = await fs . readdir ( source ); const file = files [ 0 ]; const fileStat = await fs . stat ( file ); if ( fileStat . isFile ()){ const fileData = await fs . readFile ( file ); // process data } } catch (err) { // handle errors } Revisiting reading ﬁle Handle Errors // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } async/await CPSC 310: Introduction to Software Engineering try { const files = await fs . readdir ( source ); const file = files [ 0 ]; const fileStat = await fs . stat ( file ); if ( fileStat . isFile ()){ const fileData = await fs . readFile ( file ); // process data } } catch (err) { // handle errors } Revisiting reading ﬁle Handle Errors // if this were synchronous const files = fs . readdir ( source ); if ( fs . stat ( files [ 0 ]). isFile ()) { const data = fs . readFile ( files [ 0 ]); // process data } async/await CPSC 310: Introduction to Software Engineering What about async ? async function readDirectory () { try { let file ; const files = await fs . readdir ( source ); const file = files [ 0 ]; const fileStat = await fs . stat ( file ); … } The function returns a promise CPSC 310: Introduction to Software Engineering fs.readdir(source, function (err, files) { if (err) { // handle errors } else { fs.stat(files[0], function (err, stat) { if (err) { // handle errors } else { if (stat.isFile()) { fs.readFile(files[0], function (err, data) { if (err) { // handle errors } else { // process data } })}}})}}); fs.readdir(source).then( function (files) { file = files[0]; return fs.stat(file); }).then( function (fileStat) { if (fileStat.isFile()) return fs.readFile(file); }).then( function (fileData) { // process data }).catch( function (err) { // handle errors });try { const files = await fs.readdir(source) ; const fileStat = await stat( files[0] ); if (fileStat.isFile()) c onst fileData = await fs.readFile(file); // process data } } catch(err) { // handle errors } CPSC 310: Introduction to Software Engineering P romises (simpliﬁed) // all must pass, else catch // best choice if complete success is required Promise . all (promiseList: < T >[]): Promise < T > // always then, but with status for each promise // best choice for large queues where retries are ok Promise . allSettled (promiseList: < T >[]): Promise < T > // first complete // rarely used, but sometimes handy Promise . race (promiseList: < T >[]): Promise< T > CPSC 310: Introduction to Software Engineering A wait/P romises and per formance/errors ● P romises: ○ P romisiﬁed code does not block main thread. ○ Rejected promises will fail silently if not caught. ○ Playground Example ● Async/await: ○ Async code is e x ecuted sequentially but does not block main thread. ○ Async errors will fail silently if not caught. ○ Async errors need to be caught in async functions ○ Playground Example Languages CPSC 310: Introduction to Software Engineering What does a programming language do? PL CPSC 310: Introduction to Software Engineering The process of tr ansforming a mental plan of desired actions for a computer int o a r epr esentation that can be underst ood by the comput er . — Jean-Michel Hoc and Anh Nguy en-Xuan http://www .d igibar n.com/collect ions/posters/tongues/ComputerLanguagesChart.pngCPSC 310: Introduction to Software Engineering What does this program do? CPSC 310: Introduction to Software Engineering What does this program do? CPSC 310: Introduction to Software Engineering L ow-level languages are hard! CPSC 310: Introduction to Software Engineeringz: number = x * y; Languages matter CPSC 310: Introduction to Software Engineering S tatic vs dynamic types Java : • int age; • Compiler enforces consistency: • age = 1; // ok • age = false; // !ok V ariables have types in statically typed languages. CPSC 310: Introduction to Software Engineering TypeScript : • let age: number; • Compiler enforces consistency: • age = 1; // ok • age = false; // !ok V ariables have types in statically typed languages. S tatic vs dynamic types CPSC 310: Introduction to Software Engineering TypeScript : • let age: number; • Compiler enforces consistency: • age = 1; // ok • age = false; // !ok V ariables have types in statically typed languages. V alues have types in dynamically typed languages. • JavaScript : • v ar age = 1; • age = 100; // number • age = false; // boolean • age = “CPSC”; // string S tatic vs dynamic types CPSC 310: Introduction to Software Engineering TypeScript : • let age: number; • Compiler enforces consistency: • age = 1; // ok • age = false; // !ok V ariables have types in statically typed languages. TypeScript is optionally statically typed. • TypeScript type Inference: • let age = 1; // number • age = 100; // ok • age = false; // !ok • age = “CPSC”; // !ok S tatic vs dynamic types CPSC 310: Introduction to Software Engineering Binding conte xt ● JavaScript syntax has evolved over many years. ○ E.g., callbacks -> promises -> async/await ● V ariable scoping issues led to ‘fat arrow’ notation:class DataProcessor { private data = 0; public compute() { console.log( this .data); setTimeout ( function() { this .data++; console.log( this .data); } , 0); console.log( this .data); } } class DataProcessor { private data = 0; public compute() { console.log( this .data); setTimeout ( () => { this .data++; console.log( this .data); } , 0); console.log( this .data); } } const proc = new DataProcessor(); proc. compute () function() {} vs. () => {} CPSC 310: Introduction to Software Engineering V alue comparison if ( x === y ) { console . log ( \"x and y are strictly equal\" ); } if ( x == y ) { console . log ( \"x and y are loosely equal\" ); } undefined == null ; // true undefined === null ; // false 1 == ‘1’ ; // true 1 === ‘1’ ; // false (== vs ===) S tatic Analysis CPSC 310: Introduction to Software Engineering S yntax & semantics • S yntax deﬁnes the set of valid tok ens that are allowed. • ‘if (token === token) ’ is syntactically valid. • Semantics deﬁne what the tok ens actually mean. • ‘if (token === token) ’ is semantically meaningless. • Compilers check for valid syntax (e.g., javac, tsc ). • Semantics will mostly be evaluated at runtime. • e.g. by using or testing the system. • Linters can detect some semantic issues before runtime. CPSC 310: Introduction to Software Engineering S tatic analysis: F ormatting & linting ● S tatic analyses are any programmatic analysis of a program that only inputs the program te xt itself and does not need to e x ecute the program. ● Dynamic analyses need to run the program, so also require inputs (often via test cases or fuzzing). ● S tatic analyses are per formed in compilation, but also during: ○ F ormatting : enforcing consistent code syntax ■ Tabs vs spaces, line length, whitespace, etc ■ Aids collaboration and readability ○ Linting : enforcing good semantics of code ■ No unused vars, no globals, no misused promises ■ P revents bugs CPSC 310: Introduction to Software Engineering Linting e xample const promise = Promise.resolve('value'); if (promise) { // do something } const val = promise ? 123 : 456; while (promise) { // do something } What is wrong with this code? CPSC 310: Introduction to Software Engineering Linting e xample const promise = Promise.resolve('value'); if (promise) { // do something } const val = promise ? 123 : 456; while (promise) { // do something } These are still promises (not values!) CPSC 310: Introduction to Software Engineering W e can catch this with lint! CPSC 310: Introduction to Software Engineering Move bugs to the left https://s amwho .de v/blo g/mov e- y our-bugs-to-the-left/CPSC 310: Introduction to Software Engineering Linters help developers: • A void some semantic errors • Ensure code consistency • Don’t need to think about representation • E.g., naming conventions: camelC ase vs P ascalC ase vs snak e_case • Improve code comprehension • Consistent code is easier for other developers (including future you) to understand • E.g., const vs let ; function return types • Improve design • Ease evolution • Reduce bloat CPSC 310: Introduction to Software Engineering Linting: Error avoidance It can be easy to write syntactically valid code that introduces subtle semantic errors. Example: avoid using await inside a for loop. const files = await fs.readdir(source); for (const file of files) { const content = await fs.readFile(file); } This code seems to run… a bit slow? CPSC 310: Introduction to Software Engineering Linting: Code consistency Conventions mak e it simpler for developers write code with less mental eﬀor t. Example: use a single naming convention. const userName; const Password; const display_name; What do I name the ne xt variable to hold an email address?CPSC 310: Introduction to Software Engineering Linting: Code comprehension Enforce code that is easy for other developers (including future you) to understand. // specify function return types async function getContent (name: string ){ const buffer = await fs. readFile (name); return buffer . toString ( \"base64\" ); } // prefer const . let PI = 3.14 ; Should the value for PI ever be reassigned? What do I get if I call getContent(..) ? CPSC 310: Introduction to Software Engineering ● Linters can also check for some security vulnerabilities. // @ no-eval public myAction(action: string) { eval(action); } myAction(“console.log(‘hi 310!’)”); // Linting: Security CPSC 310: Introduction to Software Engineering ● Linters can also check for some security vulnerabilities. // @ no-eval public myAction(action: string) { eval(action); } myAction(“console.log(‘hi 310!’)”); // myAction(“await fs.remove(‘/home/’” + “{ recursive: true, force: true } );”); Linting: Security CPSC 310: Introduction to Software Engineering ● Linters can also check for some security vulnerabilities. // @ no-eval public myAction(action: string) { eval(action); } myAction(“console.log(‘hi 310!’)”); // myAction(“await fs.remove(‘/home/’” + “{ recursive: true, force: true } );”); // @ security/detect-object-injection public handler(key:string, value:string) { this.authenticatedUser[key] = value; } handler(“isAuthenticated”,“true”); Linting: Security","libVersion":"0.2.1","langs":""}