{"path":".obsidian/plugins/text-extractor/cache/0ddb695d2d551555d38f799ea252037a.json","text":"CPSC 320 Midterm Examination March 2nd, 2021, 19:00 to 20:30 \u0015 You have 75 minutes to write the 4 questions on this examination. A total of 35 marks are available. \u0015 Justify all of your answers. \u0015 You are allowed to access the course web site, Canvas, your notes, the textbook and (only to ask a question if you believe you have found an error on the exam) private posts on Piazza, but not other web sites. You are not allowed to contact people other than the course sta˙. \u0015 Keep your answers short. If you run out of space for a question, you have written too much. \u0015 The number in square brackets to the left of the question number indicates the number of marks allocated for that question. Use these to help you determine how much time you should spend on each question. \u0015 Use the back of the pages for your rough work. \u0015 Good luck! UNIVERSITY REGULATIONS: \u0015 Each candidate should be prepared to produce, upon request, his/her UBC card. \u0015 CAUTION: candidates guilty of any of the following, or similar, dishonest practices shall be immediately dismissed from the examination and shall be liable to disciplinary action. 1. Having at the place of writing, or making use of, any books, papers or memoranda, electronic equipment, or other memory aid or communication devices, other than those authorised by the examiners. 2. Speaking or communicating with other candidates. page 2 out of 5 1 A strange sorting algorithm Even though it's not obvious, the following algorithm will correctly sort an array of input values in increasing order: Algorithm IncreasingSort(A, first, last) n = last - first + 1 if A[first] > A[last] then exchange A[first] and A[last] if first + 1 < last then third = ⌊n/3 ⌋ IncreasingSort(A, first, last - third) IncreasingSort(A, first + third, last) IncreasingSort(A, first, last - third) 1. [2 marks] What type of algorithm is algorithm IncreasingSort ? Divide and Conquer Greedy Prune and Search None of those 2. [4 marks] Write a recurrence relation that describes the running time T (n) of algorithm IncreasingSort as a function of n. Solution : T (n) = { 3T (2n/3) + Θ(1) if n ≥ 3 Θ(1) if n ≤ 2 3. [4 marks] You are given the choice of sorting an array A using either algorithm IncreasingSort or insertion sort. Which of the two algorithms would you pick? IncreasingSort insertion sort it doesn't matter Justify your answer here: Solution : We can use the Master Theorem to derive the time complexity of algorithm IncreasingSort : a = 3, b = 3/2 and so logb a = log3/2 3 ≈ 2.71. Since f (n) = n0, we are in case 1 of the Master theorem (pick any ε ≤ 2.7), and so the time complexity of algorithm IncreasingSort is in Θ(nlog3/2 3). It is therefore worse than insertion sort (or bubble sort, or selection sort)! 2 Greedily pairing up contestants A single-elimination tournament is one where players are paired up, and the winner of each game advances to the next round while the loser is eliminated. The n players are assigned slots numbered from 1 to n. In the ˝rst round, the player in slot 1 plays the player in slot 2, the player in slot 3 plays the player in slot 4, etc. The winner of the players in slots 1 and 2 will be assigned slot 1 for the next round, the winner of the players in slots 3 and 4 will be assigned slot 2 for the next round, etc. This is illustrated below: the players are named A through H, and the subscript represents the slot number for each round of the competition. page 3 out of 5 The organizers of the World Only-Relate championship want to make their tournament as exciting as possible and so are looking for a way to pair the contestants up to minimize the total \u0010boredom\u0011 of the games of the tournament. They decide to calculate \u0010boredom\u0011 as follows: ‹ They give each of players p1, p2, . . . pn a ranking r(pi) that denotes how good player pi is: r(pi) > r(pj) if player pi is better than player pj. ‹ Every time a player pi plays against a player pj, the game generates a boredom equal to the di˙erence between the players' rankings: |r(pi) − r(pj)|. ‹ The total boredom is the sum of the boredoms of the individual games. 1. [6 marks] Design a greedy algorithm that takes in a list of n players with their rankings, and assigns a slot to teach player so as minimize the sum of the boredom of the games of the tournament, assuming that whenever two players play each other, the best of the two always wins. Assume that n is a power of two. You do not need to prove the correctness of your algorithm formally, but you must state brie˛y (one sentence or two) why you believe it will minimize the sum of the boredom of the games of the tournament. Solution : First, note that we will give marks for any greedy algorithm that makes an attempt at minimizing the sum of the boredom of the games of the tournament, whether or not it actually minimizes the sum. One possible solution would be to sort the players by ranking (increasing or decreasing) and assign slots based on the players' positions on the sorted list. That is, the worst player gets slot 1, the 2nd worst player gets slot 2, etc. This approach ensures that players will play other players with similar rankings most of the time (de˝- nitely for the ˝rst round, and somewhat for the subsequent rounds), thus minimizing the boredom of at least the games in these rounds. 2. [3 marks] Explain what makes your algorithm greedy. Solution : It is greedy because it assigns slots based on a simple criterion (increasing ranking) without considering the impacts this criterion might have in the later rounds of the tournament. 3 More on kth smallest elements in trees As in assignment 2, suppose we have a collection of values that's dynamic : we will be inserting new values, and deleting old ones. In CPSC 221, you learned that we could store this data in a balanced binary search tree (such as an AVL tree) so every insertion and deletion operation takes in O(log n) time, where n is the size of the tree. So assume that we have a balanced binary search tree containing our data, and that in addition to the usual ˝elds each node also contains the size of its left subtree . 1. [6 marks] Describe an e˚cient algorithm that takes in such a tree T and a value x, and returns the rank of x in the tree T . The element x has rank k if the tree contains x, and there are k − 1 elements smaller than x. Your algorithm should return −1 if x is not an element of the tree. page 4 out of 5 Solution : The algorithm is a cross between BSTSearch and the BSTSelect algorthm from assign- ment 2: we search for the element, while keeping track of the number of elements that are smaller than the current node but not in its left subtree. Algorithm BSTComputeRank(T, x) return BSTComputeRankHelper(T, x, 0) Algorithm BSTComputeRankHelper(T, x, count) If T = null then return -1 If x = T.key then return count + T.size_of_left_subtree + 1 If x < T.key then return BSTComputeRankHelper(T.left, x, count) return BSTComputeRankHelper(T.right, x, count + T.size_of_left_subtree + 1) In the worst case, the algorithm needs to go from the root to the deepest leaf of the tree. Since we know that the height of an AVL tree is in O(log n), this means the worst case running time of the algorithm is in O(log n). 4 And a reduction to ˝nish things o˙ In this question, we consider once again the Independent Set problem from Tutorial 3. Recall that this problem is de˝ned as follows: Given a graph G = (V, E) and a positive integer K, is there a subset V ′ of V with at least K vertices such that no two vertices of V ′ are connected by an edge in G (that is, {u, v} /∈ E for all u, v ∈ V ′) ? Recall moreover that Boolean Satis˝ability (SAT) is de˝ned as follows: The input is a collection of m clauses over n boolean variables X1, X2, . . . Xn. Each clause is a disjunction of some of the variables or their complements. The problem consists in answering the question \u0010Is there a way to assign truth values to each variable that makes every clause of the instance True ? Complete the following reduction from Independent Set to Boolean Satis˝ability . You do not need to prove its correctness. 1. [5 marks] For each vertex vi of G, we de˝ne Solution : k variables Xi,1, Xi,2, . . . , Xi,K. Intuitively, an assignment of True to variable Xi,t means that Solution : vertex vi is the tth vertex in the independent set. page 5 out of 5 and we add the clause(s) Solution : X[i, t] ∨ X[i, t′] for every vertex vi of G and every two integers 1 ≤ t < t′ ≤ K. Intuitively, these clauses make sure that in the instance of SAT, a vertex of G can only ˝ll one \u0010slot\u0011 in the list of K vertices in the independent set. We also add the clause X[1, t] ∨ X[2, t] ∨ · · · ∨ X[n, t] for every integer 1 ≤ t ≤ K to ensure that at least one vertex is labeled as the tth vertex in the independent set. 2. [5 marks] For each edge {vi, vj} of G, we add the clause(s) Solution : X[i, t] ∨ X[j, t′] for every pair of integers 1 ≤ t ≤ K and 1 ≤ t′ ≤ K. These clauses' purpose is to make sure that Solution : at most one endpoint of the edge belongs to the independent set.","libVersion":"0.2.1","langs":""}