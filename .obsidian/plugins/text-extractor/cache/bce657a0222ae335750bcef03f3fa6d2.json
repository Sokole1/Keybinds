{"path":".obsidian/plugins/text-extractor/cache/bce657a0222ae335750bcef03f3fa6d2.json","text":"CPSC 320 2023W1: Assignment 4 Solutions 3 Lighting the Beacons An instance of the \"Lighting the Beacons\" problem from Tutorial 8 is speciﬁed by: (i) A sorted table D[1..n] of distances (in kilometers) from a source hill 1 to subsequent hills in a line that lead to a target hill n ≥ 1. All entries of D are distinct, and successive hills are at most 100km apart. (ii) A table P [1..n] of the probabilities that a beacon on each hill will successfully transmit the signal to a successor that is within 100km, with P [1] = 1. A valid solution to the problem is a chain of hills from the source but not including the target, with successive hills no more than 100km apart and the last hill in the chain no more than 100km from the target. An optimal solution is a valid solution such that if the source beacon is lit, the signal will be received at the target (hill n) with maximum probability. Note that the guards assigned to a beacon in a chain only light their beacon if they see the signal from the preceding beacon in the chain, even if an earlier beacon in the chain might be visible within 100km. As a result, the probability that a signal reaches the target along a valid chain is the product of the transmission probabilities of beacons in the chain. Let OP T (j) represent the maximum probability that a signal is transmitted from the source to beacon j. In the tutorial you developed the following recurrence relation for OP T (j): OP T (j) = { 1, if j = 1, maxi≤j′≤j−1{OP T (j′) × p(j′)}, if j > 1. Here, i is the index of the furthest hill preceding j that is still within 100km of hill j, so D[j] − D[i] ≤ 100, but D[j] − D[i − 1] > 100 or i = 1. 1. (4 marks) Using the recurrence relation, develop a memoized algorithm for computing OP T (n). Remember that a memoized algorithm always has a recursive helper function. SOLUTION: Algorithm 1 Memoized approach for computing OPT(n) procedure Memo-Beacon(D[1...n], P [1...n]) ▷ n ≥ 1 create a solution table S[1...n] with all entries initialized to −1 S[1] ← 1 return Memo-Beacon-Helper(D[1...n], P [1...n]) procedure Memo-Beacon-Helper(D[1...j], P [1...j]) ▷ j ≥ 1 if S[j] == −1 then S[j] ← 0 i ← j − 1 while (D[j] − D[i] ≤ 100) and (i ≥ 1) do S[j] ← max{S[j], P [i] × Memo-Beacon-Helper(D[1...i], P [1...i])} i ← i − 1 return S[j] 1 2. (5 marks) Using the recurrence relation, develop a dynamic programming algorithm for com- puting OP T (n). SOLUTION: Algorithm 2 Dynamic programming approach for computing OPT(n) procedure DP-Beacon(D[1...n], P [1...n]) create a solution table S[1...n] for j ← 2 to n do S[j] ← 0 i ← j − 1 while (D[j] − D[i] ≤ 100) and (i ≥ 1) do S[j] ← max{S[j], P [i] × S[i]} i ← i − 1 return S[n] 3. (2 marks) Suppose that the distinct entries in array D are all integers. In this case, if i is the index of the furthest hill preceding j that is still within 100km of hill j, there are at most 100 possible hills between i and j (including i and j themselves). We consider 100 to be a constant, i.e., 100 = O(1). Give a big-O-bound on the runtime of your dynamic programming algorithm from part 2 in this case, and brieﬂy justify your bound. SOLUTION: There are at most n iterations of the for loop. The while loop has at most 100 = O(1) iterations, given the stated assumptions. So each iteration of the for loop takes O(1) time, and the total time is O(n). 2 4 Edge Loads Revisited Recall the edge load problem from Assignment 2. An instance is an undirected, unweighted, con- nected, graph G = (V, E), with n nodes and m edges. For two nodes x and y let the (x, y)-edge load of an edge e in the graph, which we’ll denote by load(x, y, e), be the number of shortest paths between x and y that pass through e. Let load(e) be the sum of load(x, y, e), taken over all pairs of nodes (x, y). Example: For the graph on the left below, you saw that for example, if e = (1, 6) then load(1, 7, e) = 2, with the two paths being 1, 6, 3, 7 and 1, 6, 4, 7, and also load(1, 8, e) = 2. A BFS tree for this graph, rooted at node 1, is shown on the right, with dashed edges added, which may be useful for later parts of the problem. You also saw in Assignment 2 that we can calculate load(e) for all e by summing up the quantity load(x, y, e) for all pairs of nodes (x, y), but the time is O(n2m). Here you’ll develop a faster approach to calculating all of the quantities load(e). As usual, we let ds[v] denote the depth of node v in a BFS tree rooted at s, and we will also let ds = maxv∈V ds[v]. You can assume that these quantities have been precomputed and the algorithms that follow have access to these quantities. 1. (1 mark) Let load(s, e) be the number of shortest paths from s to any other node that goes through edge e. That is, load(s, e) = ∑ y∈V load(s, y, e). Let e = (u, v), and assume that u is closer to s than v, i.e. ds[u] < ds[v]. The paths counted in load(s, e) are comprised of an \"upper path\", from s to u, followed by v, and ﬁnally a \"lower path\", from v to some destination node. For our example graph, if e = (2, 3), then load(1, e) = 3, since there is one shortest path from 1 to 3, one from 1 to 7, and one from 1 to 8 that all go through edge (2, 3). (a) If e = (6, 4) what is load(1, e)? 0 1 2 3 4 (b) If e = (6, 5) what is load(1, e)? 0 1 2 3 4 2. (1 mark) Let lows(v) be the number of \"lower paths\" from node v in a BFS tree rooted at s. Each such path visits nodes at successively deeper levels of tree, following either tree or dashed edges that go deeper from one level to the next in the tree. Formally, lows(v) = 1 if v if a leaf, and otherwise lows(v) = 1 + ∑ x | (v, x) ∈ E, ds[x] = ds[v] + 1 lows(x). 3 Example: low1(6) = 8, since in the BFS tree rooted at 1, the nodes 6, 3, 4, and 5 can be reached by one shortest path from 6, while both nodes 7 and 8 can be reached via two shortest paths from 6. (Remember that dashed edges that go deeper are allowed on these paths.) (a) What is low1(2)? 1 2 3 4 (b) What is low1(4)? 1 2 3 4 3. (2 marks) Here is a recursive algorithm that calculates lows(v) for all nodes v, when the call Calculate-Lowers(s) is made. procedure Calculate-Lowers(u) lows(u) ← 1 ▷ there is a \"lower\" path from u to itself if ds[u] < ds then ▷ u is not a leaf of a BFS tree rooted at s for all edges (u, v) such that ds[v] == ds[u] + 1 do lows(u) ← lows(u)+ Calculate-Lowers(v) Suppose that we make the call Calculate-Lowers(s) on the example graph given above. On which nodes v is the call Calculate-Lowers(v) made more than once? List all such nodes v. No justiﬁcation needed. SOLUTION: The call is made twice on nodes 3, 7, and 8, since each of these nodes has two edges (one dashed and one tree) from nodes at the previous level of the tree. 4. (5 marks) Write a memoized (recursive) version of the Calculate-Lower algorithm, that avoids making multiple recursive calls to the same node on any input. Ideally it should run in O(n + m) time. SOLUTION: procedure Memo-Calculate-Lowers(u) Create a table lows[1..n] and initialize all entries to -1 Call Memo-Calculate-Lower-Helpers(s) procedure Memo-Calculate-Lower-Helpers(u) if lows[u] == −1 then lows[u] ← 1 if ds[u] < d then ▷ u is not a leaf for all edges (u, v) such that ds[v] == ds[u] + 1 do lows[u] ← lows[u]+ Memo-Calculate-Lower-Helpers(v) 5. (3 marks) What is the runtime of your algorithm of part 4? Justify your answer. SOLUTION: Consider the recursion tree for Memo-Calculate-Lower-Helper. Each node of the tree corresponds to a call Memo-Calculate-Lower-Helpers(v) for some node v. There is at most one internal node of the tree corresponding to each node v, so at most n internal nodes in total, each corresponding to a distinct v. The internal node of the tree corresponding to node v of the graph has degree(v) children. Summing up over all nodes, the total number of children of internal nodes is O(m), and so the number of leaves of the recursion tree is O(m). Therefore the total number of nodes in the tree is O(n + m). The work done per node, not counting recursive calls, is O(1). So the total work done by the algorithms is O(n + m). 4 6. (1 mark) Let c(s, u) be the number of shortest paths from s to u. (You developed an algorithm to compute this quantity in Assignment 2.) Consider the following expressions, where e = (u, v) and ds[u] < ds[v]. Which one is correct? Choose one. load(s, e) = c(s, u) + lows(v) load(s, e) = c(s, u) × lows(v) load(s, e) = lows(u) + c(s, v) load(s, e) = lows(v) × c(s, v) 7. (2 marks) What is load(s, e) when e = (u, v) and u and v are equidistant from s (i.e., when ds[u] = ds[v])? Brieﬂy justify your answer. SOLUTION: In this case load(s, e) = 0. This is because all shortest paths from s go deeper in the BFS tree at each step, but u and v are at the same level of the tree. So no shortest path goes from u to v or vice versa. 8. (2 marks) Putting together the Θ(nm)-time algorithm to calculate all of the quantities c(x, y) from Assignment 2, an algorithm to compute lows(x) in O(n + m) time (e.g., from part 4), as well as the expressions of parts 6 and 7, what is the overall runtime to compute all of the quantities load(s, e), for all nodes s and edges e? Choose all that apply. Θ(n + m) Θ(n(n + m)) Θ((n + m) log n) Θ((n + m)2 log n) Θ((n + m)2) Θ(nm) 9. (1 mark) To wrap things up, suppose that all of the quantities load(s, e), for all nodes s and edges e, have already been calculated. What is the remaining time needed to compute all the quantities load(e) for all edges e, using the quantities load(s, e)? Check one. Θ(n) Θ(m) Θ(mn) Θ(mn2) 5 5 Subset Sums mod m In this example of dynamic programming, the recurrence describes a set of values, rather than a single value as in earlier examples. An instance I of the problem is a set {x1, x2, . . . , xn} of nonnegative integers and a positive integer m. We say that a value v, with 0 ≤ v ≤ m − 1, is feasible with respect to instance I if for some non-empty subset R of {x1, x2, . . . , xn}, ∑ x∈R x ≡ v (mod m). Also, for each i, 0 ≤ i ≤ n, let V (i) be the set of feasible values with respect to instance ({x1, x2, . . . , xi}, m). 1. (3 marks) Explain why the following recurrence holds for V (i). V (i) = { ∅, if i = 0 V (i − 1) ∪ ∪v∈V (i−1){(v + xi) (mod m)} ∪ {xi (mod m)}, if 1 ≤ i ≤ n. SOLUTION: Each of the three sets on the right hand side, namely V (i−1), ∪v∈V (i−1){(v +xi) (mod m)}, and {xi (mod m)}, are clearly subsets of V (i), since each contains values that are sums of elements from the set {x1, . . . , xi} (mod m). So, the right hand side is a subset of the left hand side. To see that the left hand side, namely V (i), is a subset of the right hand side, note that the ﬁrst set on the right hand side, V (i − 1), accounts for all feasible values that can be obtained from any non-empty subset of {x1, . . . , xi−1}, the second set accounts for values that can be obtained from a set containing xi plus some other non-empty subset of {x1, . . . , xi−1} (whose values sum to v (mod m)), and the last set accounts for the subset of V (i) that contains just xi. So, all subsets R of {x1, . . . , xi−1} are accounted for on the right hand side, and we can conclude that it contains V (i). 2. (4 marks) Design a dynamic programming algorithm that, given an instance I = ({x1, x2, . . . , xn}, m) of Subset Sums mod m, determines whether 0 is feasible with respect to I. The algorithm outputs \"Yes\" or \"No\". Your algorithm should run in O(nm) time. Your pseudocode should create a solution array, Soln[0..n], and should store the set of values V (i) in Soln[i]. The pseudocode can use set operations such as ∪ as in the recurrence above. SOLUTION: procedure Subset-Sum-mod-m({x1, x2, . . . , xn}, m) ▷ returns \"Yes\" if for some non-empty subset R of {x1, x2, . . . , xn}, ∑ x∈R x ≡ 0 (mod m) ▷ and returns \"No\" otherwise create an array Soln[0..n] ▷ entries of this array will be sets Soln[0] ← ∅ for i from 1 to n do Soln[i] ← Soln[i − 1] + ∪v∈Soln[i−1]{v + xi (mod m)} ∪ {xi (mod m)} if 0 is in the set Soln[n] then return \"Yes\" else return \"No\" 3. (3 marks) Explain why your algorithm of part 2 runs in time O(nm). 6 SOLUTION: For each i, 1 ≤ i ≤ n, the size of the set V (i), and therefore the set Soln[i], is at most m, since it is a subset of {0, 1, . . . , m − 1}. Therefore, the time to compute Soln[i] at the ith iteration of the for loop is O(m), since it takes the union of at most m + 1 sets, one of which (namely Soln[i − 1]) has size at most m and the remaining of which have size 1. Summing up the time for the for loop over all i gives a total runtime of O(nm). 4. (5 marks) Suppose that indeed there is a subset R of S such that ∑ x∈R x ≡ 0 (mod m). Write an algorithm that ﬁnds such a subset R. You can assume that an array Soln[0..n] has already been pre-computed, where Soln[i] stores the set V (i), and your algorithm can use the array Soln. Your algorithm should run in time O(nm). SOLUTION: The subset is returned by a call to Find-R(n, 0): procedure Find-R(i, v) ▷ return non-empty R ⊆ {x1, . . . , xi} for which ∑ x∈R x ≡ v (mod m), given that R exists ▷ the algorithm has access to the array Soln[0..n] if xi (mod m) = v then return {xi} else if v ∈ Soln[i − 1] then Find-R(i − 1, v) else ﬁnd a v′ ∈ Soln[i − 1] such that v = v′ + xi (mod m) return {xi} ∪ Find-R(i − 1, v′) 5. (2 marks) Explain why your algorithm of part 4 runs in time O(nm). SOLUTION: The time for a call to Find-R(i, v), ignoring recursive calls, is O(m), and is dominated by the last case. Then there is one recursive call to Find-R(i − 1, v′). So the run time can be described by the recurrence T (i) = { c, if i = 0 T (i − 1) + cm, if i > 0 The recursion tree for this recurrence has at most n levels, with one node per level (since there is just one recursive call), and the work per level is O(m). Summing up over all the levels, the total work is O(nm). Note: Some students in the class pointed out that actually the line \"ﬁnd a v′ ∈ Soln[i − 1] such that v = v′ + xi (mod m)\" can be implemented in O(1) time, simply as \"v′ ← v − xi (mod m)\". So in fact the algorithm’s runtime is not only O(nm) but actually O(n)! 7","libVersion":"0.2.1","langs":""}