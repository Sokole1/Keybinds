{"path":".obsidian/plugins/text-extractor/cache/e7acf08f9a89c8478336438ee3050740.json","text":"source: https: / / refactoring. guru/ L ow L evel Design F or per s onal us e only , pleas e do not dis tr ibute on non-UB C domains . K athar ine K er r & Nick B radley P atter n Intro Topics CP S C 310: Introduction to S oftware E ngineer ing A tr ied and tr ue s olution to a commonly encountered problem. • Think about what it feels lik e to s olv e a problem for the v er y ﬁ r s t time… • Y ou need to think about the problem from s cratch. • Y ou hav e to tes t v er y thoroughly , and may be won’t ev en think of all pos s ible cas es to tes t! • Now think about what it’s lik e when s omeone tells y ou a pos s ible s olution. • That s olution includes a lot of knowledge, e x per imentation, and tes ting! • This s av es a *lot* of time and potential mis tak es . W hat is a d esign p at tern? CP S C 310: Introduction to S oftware E ngineer ing • Indus tr y noticed this “on y our own” v er s us “with help” phenomenon too. • A community dev eloped where people could des cr ibe their s olutions to commonly encountered problems , and other s could beneﬁ t. • They called thes e s olutions “Des ign P atter ns ”. B as ically , s mar t people, who hav e s uﬀ ered through a lot of s y s tem ev olution, hav e identiﬁ ed generaliz able s olutions to s ome common problems ! Ind ust r y not iced t his too! CP S C 310: Introduction to S oftware E ngineer ing • The or iginal us e of the ter m “Des ign P atter ns ” really comes from A rchitecture (building architecture) from Chr is topher A le x ander. • Thes e were architectural idioms , to guide architectural des ign (a hous e is compos ed of a kitchen, bathroom, bedrooms etc... to be placed in cer tain bas ic conﬁ gurations ). W here d oes t he name come from? CP S C 310: Introduction to S oftware E ngineer ing • E as y to blindly ‘force’ a patter n into a conte x t where it does not mak e s ens e. • A bs traction lay er s hav e cos ts (mainly under s tandability ) that mus t be balanced with beneﬁ ts (mainly ev olutionar y ). • The abs traction lay er required for a patter n may be more comple x than the non-patter n s olution (e.g., no common inter face). W hy not d esign p at terns?W hy d esign p at terns? L everage e x is ting des ign knowledge. E nhance ﬂe xib ilit y for future change. Increas e reusab ilit y of dev eloped code. E as e communication by us ing a s hared vocab ular y . “S cience is built up of facts as a hous e is built of s tones , but an accumulation of facts is no more a s cience than a heap of s tones is a hous e.” –Henr i P oincaré CP S C 310: Introduction to S oftware E ngineer ing This techniq ue w as t ranslated into O O S /W Dev ● S oftware engineer s adopted a s imilar approach for des cr ibing common s olutions to common problems . ○ P r o b lem : intent, motiv ation, applicability. ○ S o lu tio n : s tr ucture, par ticipants , collaborations , implementation. ○ Co n seq u en ces : war nings , known us es , related patter ns . CP S C 310: Introduction to S oftware E ngineer ing OO Des ign patter ns s peciﬁ cally help dev eloper s nav igate object or iented s olutions , and often mak e s mar t us e of poly mor phis m to s olv e s ome problems . There are actually lots of kind of s oftware des ign patter ns (A rchitectural patter ns , W eb des ign patter ns , etc) but we’re s ticking with OO ones in 310. F ocus on O O p at terns in 310 CP S C 310: Introduction to S oftware E ngineer ing S tr uctural des ign patter ns are des ign patter ns that eas e the des ign by identify ing a s imple way to r ealiz e r elatio n sh ip s b etw een en tities. Creational des ign patter ns are des ign patter ns that deal with o b ject cr eatio n m ech an ism s, tr y ing to create objects in a manner s uitable to the s ituation. B ehav ioural des ign patter ns are des ign patter ns that identify co m m o n co m m u n icatio n p att ern s b etw een o b jects and realiz e thes e patter ns . Design p at tern categories CP S C 310: Introduction to S oftware E ngineer ing There are L O T S of OO des ign patter ns ! This lis ting is jus t a few of them! CP S C 310: Introduction to S oftware E ngineer ing CO DE S ME L L S V I O L A T I NG P RI NCI P L E S RE F A C T O RI NG S P RI NCI P L E D CO DE an d o ft en P A T T E RNS Hence, patter ns ( jus t lik e generally pr incipled code) A RIS E and E ME RG E . W e will be looking at each patter n in the conte xt of which pr inciples are violated , which refactorings s olv e the v iolations , and how this res ults naturally in des ign patter n des igns . CP S C 310: Introduction to S oftware E ngineer ing E merging to d esign p at terns ● Des ign patter ns prov ide s olutions to common problems . ● OO des igns encounter thes e problems as v iolations of s oftware pr inciples in the code! ● Us ually , OO Des ign P atter ns mak e us e of two impor tant OO foundational technologies : ○ Ab str actio n : Creating a more gener ic clas s es /inter faces . ○ P o lym o rp h ism: Us ing dy namic s ubs titution to mak e for code that is more reus able and/or obliv ious to future ev olution in the s y s tem. CP S C 310: Introduction to S oftware E ngineer ing How to und erst and a d esign p at tern 1) W h at p rin cip le vio latio n s motiv ate the emergence of the des ign patter n s olution? 2) F in d th e ab str actio n: Which clas s or clas s es s hould be added at the top of the hierarchy. 3) F in d th e p o lym o rp h ism /o b livio u sn ess: Which methods are pres ent in that clas s /inter face, and how mus t they be ov er r idden in concrete s ubty pes ? 4) F ig u r e o u t w h en th e p o lym o rp h ic m eth o d ( s) is/ar e called : What is the tr igger for the behav iour in the patter n. Obs er v er source: https: / / refactoring. guru/ Topics CP S C 310: Introduction to S oftware E ngineer ing ● Identify which S OLID pr inciples are v iolated, and which code/code s mells are res pons ible for the v iolation. ● R efactor to Compos ite ﬁ x ing the v iolations . ● R efactor to Obs er v er ﬁ x ing the v iolations . ● E x plain how poly mor phis m and abs traction are us ed in Compos ite and Obs er v er, includes under s tanding the concept of obliv ious nes s . E xaminab le skills O b ser ver & Comp osite W atcher W atchee The Obs er v er P atter n E mergent S tor y W atcherA W atcheeW atcherB L o t s o f no t iﬁ cat io n co de L o t s o f w at ching co de S w it ch o n w at cher dupl icat io n D o n ’t Repeat Y o ursel f! S ing l e respo nsibil it y vio l at io n D ependency In v ersio n V io l at io n The Obs er v er P atter n E mergent S tor y W atcherA W atcheeW atcherB L o t s o f no t iﬁ cat io n co de L o t s o f w at ching co de S w it ch o n w at cher dupl icat io n D o n ’t Repeat Y o ursel f! S ing l e respo nsibil it y vio l at io n e xtr act class Subject pull up me thods intr oduce hier ar chy notify( ) D ependency In v ersio n V io l at io n The Obs er v er P atter n E mergent S tor y D ependency In v ersio n V io l at io n W atcherA W atcheeW atcherB L o t s o f w at ching co de S w it ch o n w at cher dupl icat io n S ing l e respo nsibil it y vio l at io n SubjectObserv er e xtr act class e xtr act class pull up me thod intr oduce hier ar chy notify( ) D o n ’t Repeat Y o ursel f! update( ) The Obs er v er P atter n E mergent S tor y W atcherA W atcheeW atcherB SubjectObserv er depend on abs tr action D ependency In v ersio n V io l at io n notify( )update( ) * S w it ch o n w at cher The Obs er v er P atter n E mergent S tor y W atcherA W atcheeW atcherB SubjectObserv er notify( )update( ) * The Obs er v er P atter n E mergent S tor y O b ser ver: C anonical Dep ict ion +up d a te(...) +up d a te(...) +up d a te(...) CP S C 310: Introduction to S oftware E ngineer ing O b ser ver ● E nable one-to-many relations hip between objects . ● R elations hips can be dy namically added. ● S ubjects s hould not be tightly coupled to the objects that are obs er v ing them. ● Main des ign ques tion: P us h or pull. ○ P us h: S ubjects for ward data (e.g., notify (this .te x t)). ○ P ull: Obs er v er s mus t as k S ubject for the data they care about. CP S C 310: Introduction to S oftware E ngineer ing 1. What pr inciples were v iolated and where? a. Duplicated code → Commonality between the watcher s that could be pulled up b. SRP → E x tract clas s (once on Obs . and once on S ubj) c. S witch on ty pe → Depend on concretion → Dependency inv er s ion → Introduce hierarchy and refactor s witch to hierarchy. 2. Find the abs traction (which clas s or clas s es are added at the top of the hierarchy ) a. S ubject and Obs er v er, and als o the pulled up methods to update and notify 3. Find the poly mor phis m/obliv ious nes s (which method is pres ent in that clas s , and how mus t it be ov er r idden in the s ubclas s es ?) a. update( ) 4. Figure out when the poly mor phic method(s ) is /are called (what is the tr igger ) a. S omething in the s ubject has changed → s elf.notify → obs .update O b ser ver A nalysis Compos ite source: https: / / refactoring. guru/ [https : //refactor ing.gur u/] Topics S cenario Y ou are wor king on a W iki s y s tem cons is ting of A r ticles . The W iki is organiz ed as a tree where each node is an A r ticle with children (branch) or a P age (leaf ). S cenario What if we wanted to trav er s e that tree? CP S C 310: Introduction to S oftware E ngineer ing p r iv a te a r ticles: Ar ra y<Ar ticle> ; p r iv a te p a g es: Ar ra y<P a g e> ; p ub lic tra v er se(): v oid { f or (const a of th is.a r ticles) { a .tra v er se(); } f or (const p of th is.p a g es) { p .tra v er se(); } } p ub lic tra v er se(): v oid { // d o wor k } S cenario: Init ial Imp lement at ion CP S C 310: Introduction to S oftware E ngineer ing S mells /V iolations ● Duplicate code: Multiple loops for any operation → S R P v iolation . ● “Inv er ted” s witch on ty pe: Need to loop through diﬀ erent ty pes s eparately → DIP v iolation . p r iv a te a r ticles: Ar ra y<Ar ticle> ; p r iv a te p a g es: Ar ra y<P a g e> ; p ub lic tra v er se(): v oid { f or (const a of th is.a r ticles) { a .tra v er se(); } f or (const p of th is.p a g es) { p .tra v er se(); } } S cenario: Init ial Imp lement at ion CP S C 310: Introduction to S oftware E ngineer ing p r iv a te a r ticles: Ar ra y<Ar ticle> ; p r iv a te p a g es: Ar ra y<P a g e> ; p r iv a te p osts: Ar ra y<P ost> ; p ub lic tra v er se(): v oid { f or (const a of th is.a r ticles) { a .tra v er se(); } f or (const p of th is.p a g es) { p .tra v er se(); } f or (const p o of th is.p osts) { p o.tra v er se(); } } S cenario: F eat ure Req uest CP S C 310: Introduction to S oftware E ngineer ing ● A dding new ty pes becomes S hot gun S urger y . ● Intent: “I want a hierarchical organis ation, but don’t want to wr ite s pecial code for container s and leaf nodes when walking the tree.” p r iv a te a r ticles: Ar ra y<Ar ticle> ; p r iv a te p a g es: Ar ra y<P a g e> ; p r iv a te p osts: Ar ra y<P ost> ; p ub lic tra v er se(): v oid { f or (const a of th is.a r ticles) { a .tra v er se(); } f or (const p of th is.p a g es) { p .tra v er se(); } f or (const p o of th is.p osts) { p o.tra v er se(); } } S cenario: F eat ure Req uest CP S C 310: Introduction to S oftware E ngineer ing p r iv a te tra v er sa b les: Ar ra y<T ra v er sa b le> ; p ub lic tra v er se(): v oid { f or (const t of th is.tra v er sa b les) { t.tra v er se(); } } S cenario: E nab ling Change CP S C 310: Introduction to S oftware E ngineer ing Comp osite: C anonical d ep ict ion CP S C 310: Introduction to S oftware E ngineer ing Comp osite Recap • R epres ent whole-par t hierarchies . • E nable clients to treat indiv idual and grouped objects s imilar ly. • E ncourages e x tens ion (by hav ing e x plicit e x tens ion point). • C an mak e it hard to res tr ict relations hips (e.g., if only s peciﬁ c kinds of things s hould be groupable together ). // c lien t w/o c o m p o s it e: c o n s t el = get E lem en t (); if (el.is Leaf ()) { el.han d le (); } els e { f o r (c o n s t e o f el.c hild ren ) { // what if it has a c hild ? el.han d le (); } } // c lien t w/ c o m p o s it e c o n s t el = get E lem en t (); el.han d le (); CP S C 310: Introduction to S oftware E ngineer ing 1. Find the pr inciples violat ion : a. Duplicated code acros s all thos e for loops that are doing bas ically the s ame thing. b. S witch on ty pe s pecial behav iour for diﬀ erent ty pes of nodes . c. S witch on ty pe tells us that we hav e DIP v iolation. 2.Find the ab st ract ion : a. Introduce Hierarchy and pull up methods (A LL of the methods that are in component) 3.Find the p olymorp hism/ob liviousness : a. operation() (e.g. trav er s e() for wiki e x ample) 4.Figure out w hen the poly mor phic method(s ) is /are called: a. A ny time any one wants to walk the tree. Comp osite A nalysis F actor y source: https: / / refactoring. guru/ [https : //refactor ing.gur u/] Topics CP S C 310: Introduction to S oftware E ngineer ing ● Identify the pr inciple v iolations that neces s itate the factor y patter n (s ingle res pons ibility pr inciple v iolation becaus e of e x ces s iv e cons tr uction code). ● Identify how to for m a F actor y ty pe or F actor y ty pe hierarchy to capture the cons tr uction. ● B e able to re-route cons tr uction through the F actor y ty pe(s ) in the client (the UI, main, etc). ● R efactor a clas s or clas s hierarchy where cons tr uction has bloated into the F actor y patter n. E xaminab le skills F actor y CP S C 310: Introduction to S oftware E ngineer ing Y ou are wor king on an implementation for managing C ar s . Thes e can hav e diﬀ erent categor ies and are as s ociated with par ts from diﬀ erent v endor s . Much logic is inv olv ed to cr eate y our car objects and y ou don’ t alway s k now what ty pe of car s hould be cr eated. S cenar io CP S C 310: Introduction to S oftware E ngineer ing p ub lic c las s Car { p r iv at e wheels : Ar ra y <Wheel> ; p r iv at e c has s is : Chas s is ; p r iv at e p ar t s : P ar t s ; p ub lic c o n s t r uc to r () { t his .wheels = t his .c reat eWheels (); t his .c has s is = t his .c reat eChas s is (); t his .p ar t s = t his .c reat eP ar t s (); // lo t s m o re c o d e } p r iv at e c reat eP ar t s (): P ar t s { ...} p r iv at e c reat eChas s is (): Chas s is { ...} p r iv at e c reat eWheels (): Ar ra y <Wheel> { ...} p ub lic v o id d r iv e() { ...} // lo t s m o re c o d e } P roblems (s election): ● Cons tr uctor doing wor k outs ide the s cope of the clas s . ● Making a car is complicated and dis tracts from what the car is s uppos ed to do . ● Diﬀ erent res pons ibilities : building the car v s . being a car (S R P v iolation). ● Cons tr uctor code is prone to changes (div ergent changes ). S cenario: First A p p roach CP S C 310: Introduction to S oftware E ngineer ing P roblems : ● C arF act o r y cannot retur n a Car s ince its methods are being called by Car clas s . ● Car now knows about C arF act o r y – which is outs ide its realm of res pons ibility. C ar C arF act o r y 1.E xtract C arF act o r y 2.Delegate from Car to C arF act o r y Intent 1: Cons tr uction of y our object is a little complicated, or for s ome reas on inv olv es behav iour outs ide the s cope of the res pons ibility of the clas s its elf ( i. e. , S R P v iolation)— s o jus t putting the behav iour into the cons tr uctor s is n’t eﬀ ectiv e. Clien t S cenario: S econd Tr y CP S C 310: Introduction to S oftware E ngineer ing C arC arF act o r yClien t 1. E x tract C arF act o r y. 2. C arF act o r y creates and retur ns Car . p ub lic cla ss Car { p r iv a te wh eels: Ar ra y<Wh eel> ; p r iv a te ch a ssis: C h a ssis ; p r iv a te p a r ts: P a r ts ; constr uctor (wh eels: Ar ra y<Wh eel> , ch a ssis: C h a ssis, p a r ts: P a r ts) { this .wheels = wheels ; this .c has s is = c has s is ; this .p ar ts = p ar ts ; } p ub lic d riv e( ): v oid { ...} // lots m ore cod e } p ub lic cla ss CarF ac tor y { p ub lic r eq ues tCar (): C a r { const wh eels = this .c r eateWheels ( ); const ch a ssis = this .c r eateChas s is ( ); const p a r ts = this .c r eateP ar ts ( ); retur n new C a r (wh eels, ch a ssis, p a r ts); } // lots m ore cod e } const f a ctor y = new CarF ac tor y(); const c ar = f a ctor y .r eq ues tCar (); S cenario: Third t r y ( F actor y) CP S C 310: Introduction to S oftware E ngineer ing C arC arF act o r yClien t 1. E x tract C arF act o r y. 2. C arF act o r y creates and retur ns Car . c o n s t f ac to r y = n ew Car F ac to r y(); const c ar = f ac to r y .reques t Car(); What if… y ou don’t know what car to create at any par ticular time (want obliv ious nes s ) S cenario: Third t r y ( F actor y) CP S C 310: Introduction to S oftware E ngineer ing C ar S m allC ar Big C ar 1. E x tract fact o r y clas s for each s ubty pe. 2. Introduce fact o r y hierarchy. 3. Hook up client with factor ies . Intent 2: Y ou don’t know what car to create at any par ticular time (want obliv ious nes s )... S cenario: Diﬀerent S ub t yp es CP S C 310: Introduction to S oftware E ngineer ing Intent 2: Y ou don’t know what car to create at any par ticular time (want obliv ious nes s )... C ar S m allC ar Big C ar let f a ctor y = new S mallCarF ac tor y(); if (b ig C a r S elected ()) { f a ctor y = new BigCarF ac tor y(); } const c ar = f a ctor y .r eq ues tCar (); S cenario: Diﬀerent S ub t yp es CP S C 310: Introduction to S oftware E ngineer ing C anonical E xamp le CP S C 310: Introduction to S oftware E ngineer ing 1. Find the pr inciples violat ion : a. Ty pe S witch → S ingle R es pons ibility V iolation becaus e of too much cons tr uction code (with div ergent code s mell). 2. Find the ab st ract ion : a. The factor y at the top of the factor y hierarchy. b. A ND may be the product at the top of the product hierarchy. 3. Find the p olymorp hism : a. Mak e the thing: crea teP rod uct() (in the e x ample it was requestC a r ()) 4. Figure out w hen the poly mor phic method(s ) is /are called: a. F rom the client: ins tead of calling the product cons tr uctor, call crea teP rod uct() to get product. F actor y A nalysis","libVersion":"0.2.1","langs":""}