{"path":".obsidian/plugins/text-extractor/cache/91c2704c909378117aa69e55273d83fc.json","text":"D]V e MG LV T ol g VAS e Ted [ o = 10y (5] In the first module, we examined at how a functionâ€™s memory frame should appear in memory. A typical example is included in Quiz 1, QP1.1 Consider the following code snippet: struct { uint64_t *xi@; uint32_t *il1; int16_t *i2; int64_t i3; } void func(struct po, int32_t #*pl, int64_t *p2, int8_t *p3) { uint32_t *arr([5]; } Assume: We paused a program just as it reached the comment // stop here , and we use 8-byte pointers. Below you indicate where to find various items. If the item is in a register, select that register and leave the offset blank. If it is on the stack, give the appropriate register and hexadecimal offset to find that item. If the offset needs to be negative, write it with a negative sign, e.g., -0x1. Offsets must be in the range -0x100000 to 0x100000. Hint: Start by drawing a stack diagram for each scenario! may be helpful. (C1oR g1 o10Te| g {aTEWC VLY ife] g WiaTe [\\ViTo [VEYI\\VAN i &5 e | VYA IU) R g =W 9 L=T 0 Lo VA )/ 1V - To Yo Mo [ YU RNV 1 { s BV o1 U] neighbours. This set of slides and y86-reference may help refresh your memory.","libVersion":"0.2.1","langs":"eng"}