{"path":".obsidian/plugins/text-extractor/cache/16f5baf9138cdf7ac94b4d8ad112fa7e.json","text":"CPSC 320 2023W1: Tutorial 6 Solutions 1 Exhibition guarding In the Exhibition Guarding Problem, we are given a line L that represents a long hallway in a gallery; assume that the line has a left and right end. We are also given an unordered array X of real numbers that represent the positions of precious objects in this hallway, where a position marks the distance from the left end of the line. A guard at a position p on the line can protect objects within distance d of p, that is, objects in the range [p − d, p + d]. 1. Here is a greedy algorithm that ﬁnds the minimum number of guard positions needed to protect all objects in X. The algorithm ensures that the leftmost guard protects the object at the leftmost position, while choosing the leftmost position to be as far to the right as possible, so the guard protects as many other objects as possible. Then the algorithm is called recursively with the remaining unguarded objects. The following pseudocode captures this idea. procedure Place-Guards(X[1..n], d) ▷ X contains positions of n ≥ 0 objects on a line ▷ d is the distance (both to the left and right) that a guard can protect sort X in increasing order return Place-Guards-Helper(X[1..n], d) procedure Place-Guards-Helper(X[1..n], d) if n == 0 then return the empty set ▷ there are no objects, so no guard is needed else p ← X[1] + d ▷ place a guard as far right as possible while protecting X[1] ▷ skip the other objects protected by this guard i ← 2 while i ≤ n and X[i] ≤ p + d do i ← i + 1 return {p} + Place-Guards-Helper(X[i..n], d) 2. What is the running time of your algorithm? SOLUTION: O(n log n) time is needed to sort array X. This is the dominant cost; the helper algorithm takes O(n) time in total, because each array element is examined just once, taken over all the calls to the helper algorithm. 3. Brieﬂy justify why your algorithm produces a valid solution, i.e., a set of guard positions that ensures that all objects are guarded. (Do not concern yourself yet with whether the set of positions is minimized.) SOLUTION: By strong induction on n. Consider instance (X[1..n], d). When n = 0, the algorithm returns no guards, which is a valid solution. Let n > 0 and assume that the algorithm 1 returns a valid solution when there are fewer than n objects. When n > 0, the value of i at the end of the while loop is such that all objects at positions X[1..i − 1] are in the range [p − d, p + d], where p is the guard position chosen by the algorithm. Also, by induction, the remaining objects are protected by the solution to the recursive call. So the overall solution {p} + Guard-Posns- Helper(X[i..n], d) is valid. 4. You’d also like to show that your algorithm produces a good i.e., optimal, solution that minimizes the number of guards. We can use an exchange argument (described in Chapter 4 of K&T) for this purpose: If G∗ is an optimal solution for instance (X[1..n], d) of our problem, we transform G∗ into the solution, say G, found by our greedy algorithm on the same instance, while keeping it optimal. It follows that G is also optimal. Show the ﬁrst step of the exchange argument. Depending on the details of your algorithm, this might involve the following. Let p∗ 1 and p1 be the positions of the ﬁrst (leftmost) guard in G∗ and G, respectively. Show that G∗ − {p∗ 1} + {p1} is an optimal solution for instance (X[1..n], d). SOLUTION: Clearly p∗ 1 ≤ p1, since otherwise G∗ would not protect the leftmost object at position X[1]. Consider an arbitrary object O protected by the guard placed at p∗ 1. O’s position must be in the range [X[1], ..., p∗ 1 + d], which is a subset of the range [X[1], ..., p1 + d]. Hence object O is also protected by the guard placed at p1. Therefore every object protected by a guard at position p∗ 1 is also protected by a guard at p1. This means that the solution G∗ − {p∗ 1} + {p1} protects all objects and has the same number of guards as G∗, and so is an optimal solution that contains p1. 5. Prove by induction on n, the number of objects, that your algorithm is correct. SOLUTION: Consider any instance (X[1..n], d). The base case is when n = 0, in which case the algorithm returns no guards, which is optimal. Let n ≥ 1 and suppose that the algorithm is correct on instances with at most n − 1 objects. We know from part 4 that there is an optimal solution G∗ containing the ﬁrst guard position p1 chosen by our algorithm on instance (X[1..n], d). The remaining guards at positions other than those in G∗ − {p1} must protect all objects not protected by the guard at p1. We know by induction that our algorithm ﬁnds the minimum number of guards to protect these remaining objects. Therefore overall, our algorithm ﬁnds a solution G with a number of guards that is no greater than |G∗|, and so G is optimal. 2","libVersion":"0.2.1","langs":""}