{"path":".obsidian/plugins/text-extractor/cache/c2913f5c2fd203cdd351696b2660a677.json","text":"CPSC 302, Fall 2023, Assignment 2 Released Friday, October 13, 2023 Due Monday, October 23, 2023, 11:59pm Instructions: Please show all your work. Submit your assignment PDF via Gradescope, and code (Matlab m-ﬁles) via Canvas. Ensure that you properly select the correct pages for each question. Accompanying code should be submitted to Canvas as a zipped ﬁle. Ensure that any code snip- pets/output ﬁgures from your Matlab scripts are included in your Gradescope PDF. If you have any questions about the submission procedure or the assignment that may be of general interest to all students of the course, feel free to write to Piazza. Late submissions: You may hand in your assignment up to 24 hours late, for a penalty of 10% in absolute terms. For example, if your graded assignment is 83% and you handed in one day late, your ﬁnal grade in the assignment is 73%. The penalty would be recorded only on Canvas, not on Gradescope; your Canvas grade is the one that would count. Assignments are not accepted later than Thursday, October 5, 11:59pm. Challenging questions: Some of the questions in this assignment are a bit challenging; some bonus marks may be given. 1. This is basically a pen-and-paper question, even though you may use the computer to work on it, but please show all your steps. Consider the 3 × 3 matrix A =   1 −2 1 5 −1 −5 2 −4 4   . (a) Find the LU decomposition of A when no pivoting is used. Show all intermediate steps, and express all row operations in terms of matrices. Make sure to show all the matrices that we have deﬁned in class, particularly M (1) and M (2) and the actual factors L and U . (b) Find the LU decomposition of A when partial pivoting is used. Show all your interme- diate steps, and express all row operations in terms of matrices. Similarly to part (a), show all matrices involved, and remember to show also the permutation matrices that you use. That is, show M (1), M (2), P (1), P (2), ˜M (1), ˜M (1) (in our notation) and include also the ﬁnal matrices L, U , and P such that P A = LU . Run the Matlab command [L,U,P]=lu(A) to conﬁrm that Matlab produces the same factors. 2. Suppose Gaussian elimination with partial pivoting is applied to solve an n × n tridiagonal linear system, T x = b. Suppose the matrix is too large to store it in dense form, and therefore we need to resort to using a small number of vectors that store nonzeros involved in the numerical solution process. (a) To conﬁrm the diﬃculty of storing large dense matrices, show that generating a dense tridiagonal 1, 000, 000 × 1, 000, 000 matrix using Matlab will result in an error message. Use the commands rand and diag to generate the three diagonals of a matrix of that size, and print out the error message that you get. Notice that the diag command takes a second parameter that states which diagonal should be set. You may be interested in 0 (which is the default and does not need to be explicitly stated) and ±1 as a second parameter. (b) Show that the matrix U of the LU decomposition (with pivoting) will in general have up to three nonzero diagonals: the two original ones (main diagonal and superdiagonal right above it) and a third diagonal right above those two. (c) Show that the factor L of the decomposition will have only two nonzero elements in every column, but due to pivoting, while one of the column elements is equal to 1 and is on the main diagonal, the other one may no longer be in the subdiagonal immediately below the main diagonal. (d) Write a Matlab function that solves a tridiagonal system of n equations, using partial pivoting. Your program should get as input four vectors of size n or n−1: one right hand side b (size n), the main diagonal of A (size n), and the superdiagonal and subdiagonal of A (both of size n − 1). Your function should calculate and return x = A−1b using Gaussian elimination with partial pivoting. Your program should be eﬃcient and use a minimal amount of storage; use a permutation vector p to record the permutations. Try your program on two small tridiagonal systems of your choice, one of dimensions 10 × 10 and one of dimensions 100 × 100. To show that your program works correctly, generate tridiagonal random matrices of the appropriate size and compare your output to that of Matlab with the use of backslash; that is, compute ∥x1 − x2∥, where x1 is your numerical solution and x2 is the solution using backslash, and conﬁrm that the computed norm is close to machine rounding unit. 3. Our goal in this question is to solve a linear system with one million unknowns, arising from the discretization of a diﬀerential equation. Consider the diﬀerential equation −v′′(x) + σv′(x) = g(x) on the interval (0, 1), with boundary conditions, v(0) = v(1) = 0. Here σ is a positive scalar. The function g(x) is known, and our goal is to discretize the problem and compute a numerical solution approximating the values of v(x) on a uniform grid with n gridpoints and gridsize h = 1 n+1 . We will denote the corresponding n × n matrix by A and the linear system by Av = g. (a) Use centered diﬀerences for approximating the second derivatives and the ﬁrst derivative. For the second derivative, use the approximation v′′(x) ≈ v(x + h) − 2v(x) + v(x − h) h2 . For the ﬁrst derivative, use the approximation v′(x) ≈ v(x + h) − v(x − h) 2h . There is no need to prove that these are valid (second-order) approximations. Denote β = σh 2 . 2 Show that the matrix is tridiagonal and it has one distinct value per diagonal, as follows: ‹ All entries along the main diagonal are equal to 2 h2 ‹ All entries along the superdiagonal immediately above the diagonal are −1+β h2 ‹ All entries along the subdiagonal immediately below the diagonal are −1−β h2 ‹ All other entries of the matrix are equal to zero (b) We usually do not know the exact solution of the diﬀerential equation; this is the entire purpose of computing a numerical solution! But in this question, and as is often the case when we develop a numerical solver, we are going to work on a case where we know the exact solution, and check that our numerical solver does the right thing. (We will then have more conﬁdence that for other cases for which we do not know the exact solution, our solver will perform well and compute a good approximate solution.) To that end, suppose we know that the exact solution is v(x) = e2x sin(2πx). Conﬁrm that this function satisﬁes the boundary conditions, and plot the discrete val- ues of v(x) on a grid with n = 1, 000, 000 on the interval (0, 1). Let us denote the corresponding vector by ve (‘e’ for ‘exact’). (c) Determine g(x), given v(x) as in part (b) and σ = 500, 000. (d) Construct the matrix and the right-hand side that correspond to (b) and (c) and use the solver you wrote in Question 2 to solve the problem, with n = 1, 000, 000. (e) Compute the relative residual norm ∥g − Av∥ ∥g∥ to conﬁrm that you have solved the linear system correctly. (f) Graph the numerical solution, v, and visually conﬁrm that it looks similar to ve. Then, plot the error using semilogy. The vector containing element-wise absolute values of v − ve. The elements of this vector should be small if you have solved the problem correctly. 4. Let A + δA and b + δb be perturbation of a matrix A and a vector b (b ̸= 0), respectively, and let x and δx be such that Ax = b and (A + δA)(x + δx) = b + δb, where A is a given nonsingular matrix. Note: the notation δx, δb, and δA refers here to two completely diﬀerent vectors and a matrix, respectively, not to a multiplication of the original vectors and matrix by a scalar δ. We assume that ∥δA∥ ∥A∥ ≪ 1 and ∥δb∥ ∥b∥ ≪ 1, that is, the perturbations of the matrix and the right-hand side vector are very small. We further assume that these perturbations are so small that the second-order term δA · δx, obtained upon expanding the expression on the left-hand side of the displayed equation, can be ignored. Show that under these assumptions, ||δx|| ||x|| ≤ κ(A) ( ||δA|| ||A|| + ||δb|| ||b|| ) . This shows that the relative perturbation in the solution is bounded by the condition number of the given matrix, multiplied by the sum of relative perturbations in the matrix and in the right-hand side. 3","libVersion":"0.2.1","langs":""}