{"path":".obsidian/plugins/text-extractor/cache/8fc7c434dc114630e5d1104740a059ac.json","text":"Midterm 1 Sample Solution Patrice Belleville February 9, 2018 NOTE: Throughout the exam a simple graph is an undirected, unweighted graph with no multiple edges (i.e., no exact repeats of the same edge) and no self-loops (i.e., no edges from a vertex to itself). Graphs are simple unless stated otherwise, and even where we explicitly contradict one of these, the rest remain true. So, for example, a \"directed graph\" with no other information speci˝ed would be unweighted with no multiple edges and no self-loops. 1 O'd to a Pair of Runtimes [6 marks] The pairs of functions below represent algorithm runtimes on a pair of lists of length m and n, with 1 < m < n. For each pair, ˝ll in the circle next to the best choice of: LEFT: the left function is big- O of the right, i.e., left ∈ O(right) RIGHT: the right function is big- O of the left, i.e., right ∈ O(left) SAME: the two functions are Θ of each other, i.e., left ∈ Θ(right) INCOMPARABLE: none of the previous relationships holds for all allowed values of n and m. Do not choose LEFT or RIGHT if SAME is true. The ˝rst one is ˝lled in for you. [2 marks per answer] Left Function Right Function Answer n n2 LEFT n lg m m lg n LEFT RIGHT SAME INCOMPARABLE n2+m m m lg m LEFT RIGHT SAME INCOMPARABLE n + m log m m2 LEFT RIGHT SAME INCOMPARABLE This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. 1.1 Solution 1. RIGHT : m lg n ∈ O(n lg m) but not vice versa. When we let m grow similarly to n, these are Θ of each other, but when we let n dominate m, n lg m grows much faster than m lg n. 2. RIGHT : We're really comparing n2 m to m lg m . n ∈ O( n2 m ), and n dominates m lg m . 3. INCOMPARABLE : When m grows slowly compared to n, the n term can dominate. However, when m ∈ Θ(n), then the m2 term dominates. 2 eXtreme True And/Or False [10 marks] Each of the following problems presents a scenario and a statement about that scenario. For each one, ˝ll the circle next to the correct one among the three choices: ‹ The statement is ALWAYS true, i.e., true in every instance matching the scenario. ‹ The statement is SOMETIMES true, i.e., true in some instance matching the scenario but false in another instance matching the scenario. ‹ The statement is NEVER true, i.e., true in none of the instances matching the scenario. Then, brie˛y justify your answer as follows: ‹ Justify an ALWAYS answer by giving a small instance that ˝ts the scenario for which the statement is true , and then brie˛y sketching the key points in a proof that the statement is true for all instances that ˝t the scenario. ‹ Justify a NEVER answer by giving a small instance that ˝ts the scenario for which the statement is false , and then brie˛y sketching the key points in a proof that the statement is false for all instances that ˝t the scenario. ‹ Justify a SOMETIMES answer by giving two small instances that ˝t the scenario: one for which the statement is true and one for which the statement is false . (Indicate which one is which!) Here are the problems: [5 marks per problem] 1. Scenario: A directed, weakly-connected graph with n ≥ 2 vertices, m edges and at least two vertices in the same strongly connected component. Statement: m ≥ n. ALWAYS SOMETIMES NEVER True instance (always/sometimes) or proof that statement is false in all instances (never): False instance (sometimes/never) or proof that statement is true in all instances (always): This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. 2. Scenario: An STP (SMP but allowing ties in preference lists) instance in which the preference list of w1 may contain ties but no other preference list contains ties. Statement: Gale-Shapley run with men proposing on an SMP instance produced by breaking w 1 's ties arbitrarily will produce the same result no matter how the ties are broken. ALWAYS SOMETIMES NEVER True instance (always/sometimes) or proof that statement is false in all instances (never): False instance (sometimes/never) or proof that statement is true in all instances (always): The rest of the page is intentionally blank. If you write answers below, CLEARLY indicate here what question they belong with AND on that problem's page that you have answers here. 2.1 Solution 1. ALWAYS We can use a two vertex graph like a ↔ b for our true instance. It has 2 vertices both in the same strongly connected component. It also has two edges. To prove this, we note that a weakly connected graph must have at least n − 1 edges (since when we strip the directions from the edges, it must be connected). However, a weakly connected graph with exactly n − 1 edges cannot have two vertices in the same strong component. Again, if we strip the directions, such a graph must be a tree. So, it has no undirected cycles. Every directed cycle is also an undirected cycle when we strip direction; so, with no undirected cycles, we can have no directed cycles and no non-trivial strong components. 2. SOMETIMES Let's make a true instance. Note that w1 may have ties but need not actually have any. So, we can just make a standard SMP instance: m1: w1 w2 w1: m1 m2 m2: w2 w1 w2: m2 w1 With men proposing, this always ends with (m1, w1), (m2, w2) as the matching. This is still true even if we let the preference list for w1 be m1 = m2 instead. For a false instance, we need w1 to be \"in charge\" of the ˝nal matching. We can do that by making her the top choice of all men. m1: w1 w2 w1: m1 = m2 m2: w1 w2 w2: m1 w2 Now, if we break the ties as m1, m2, then m1 marries w1, but if we break them as m2, m1, then m2 marries w1 instead. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. 3 Oh Oh Oh Oh Oh, Try Everything! [9 marks] In this problem, we'll investigate what happens when the preconditions of some algorithms are violated. 1. Consider the following colorize algorithm from Assignment #2: // G = (V, E) is an undirected graph, represented as an adjacency list function colorize(V, E)n = |V| m = |E| let Colors be a list of at least n distinct colors for i = 0 to n - 1: V[i].setvisited(False) for i = 0 to n - 1: DFS(V[i], (function(v): v.setcolor(Colors[i]))) where DFS is de˝ned as: function DFS(v, visitfunction) if not v.getvisited():visitfunction(v) v.setvisited(True) for w in neighbours(v): DFS(w, visitfunction) When called on an undirected graph, colorize colours all vertices in each connected component in the same colour unique to that component. Which of these best completes the following statement about what colorize does when called on a directed graph? Fill in the circle next to the best answer. [2 marks] When called on a directed graph, colorize colours all vertices in each. . . . . . connected component in the same colour unique to that component. . . . strongly connected component in the same colour unique to that component. . . . strongly connected component in the same color but not necessarily unique to that component. None of these. 2. Now, consider the following intersection2 algorithm from Assignment #2: function intersection2(X, Y) Z = { } i = j = 0 m = length(X) n = length(Y) while i < m and j < n: if X[i] < Y[j]: i = i + 1 elsif X[i] > Y[j]: j = j + 1 else: add X[i] to Z i = i + 1 j = j + 1 This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. With the precondition that X and Y are both sorted in increasing order, this algorithm computes the intersection of X and Y interpreted as sets. In this problem, we will instead consider the case where n > 0, m = n, X is sorted, Y is not necessarily sorted , and X and Y contain the same elements (ignoring order). (a) Give exact lower- and upper-bounds on the number of elements in the set intersection2 returns. Fill in the circle next to best answer for each bound. [2 marks] Lower-bound: 0 1 ⌈ n 2 ⌉ n Upper-bound: 0 1 ⌈ n 2 ⌉ n (b) Now, give an example with n = 3 using your choice of the values 1, 2, 3, and 4 (but no other values) that achieves your lower-bound : [3 marks] X = Y = 3. Give a good big-O bound on the runtime of intersection2 called on a sorted list X and a possibly unsorted list Y of length m and n, respectively. (We have removed the restrictions that n = m and that X and Y contain the same elements.) [2 marks] Big-O bound: 3.1 Solution 1. SOLUTION: When called on a directed graph, colorize colours all vertices in each strongly connected component in the same color but not necessarily unique to that component. Why? A \"component\" in a directed graph is ill-de˝ned, although a strongly-connected component (or strong component) is well-de˝ned. (Even if we try to give it some plausible de˝nition, it still doesn't match the statement.) All the nodes in a strongly-connected component will be in the same colour. That's because as soon as we hit any one of the nodes for the ˝rst time in a DFS, we must hit all of them with the same DFS run (b/c the DFS will hit all reachable nodes, and they're all reachable from each other). However, that same colour can \"bleed\" into and out of the strongly-connected component. Consider this little graph: a → b ↔ c → d. b and c are in the same strong component, but neither a nor d are in that strong component. If we start the ˝rst DFS at a, everything is the same colour. If we start it at b or c, all but a is the same colour. If we start it at d then next at b or c and ˝nally at a, then each of a, b + c, and d gets its own colour. 2. Note that Y need not be sorted, but it can be. intersection2 is correct if both X and Y are sorted. Alternatively, if we \"hoist\" the biggest element of Y to the front, then we can force intersection2 to go past almost everything in X before ˝nally ˝nding a match with Y . However, we have no way to force intersection2 to miss all the matches (as long as X and Y contain all the same elements). That sets us up for our answers: This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. (a) Lower-bound on number of returned elements: 1 . Upper-bound: n (b) Here's an instance that generates this: X = [1, 2, 3] and Y = [3, 1, 2] . In fact, as long as the basic constraints are followed (whether or not you duplicate elements, by the way), there's a distinct largest element, and it goes ˝rst in Y , you get only 1 value returned. 3. Whether Y (or X ) is in order has no e˙ect on the analysis of intersection2 . It still makes at least one step of progress in at least one array on each iteration of the loop. So, the maximum number of iterations is m + n and the runtime is in O(m + n) or equivalently O(max(m, n)). 4 Date-A Centre [10 marks] A cloud service matches processors with jobs to run on them. Each processor is assigned at most one job, each job is assigned to at most one processor, there are n processors p1, . . . , pn and n jobs j1, . . . , jn, but not all processors can run all jobs. m(i, k) is true if and only if processor pi can run job jk. 1 The Cloud Matching Problem (CMP) is to produce a list M such that either M [k] = X (meaning job jk is not assigned to any processor), or M [k] = i (meaning job jk is assigned to processor pi) and m(i, k) is true. Further, in a good solution, each processor is assigned at most one job, and no unused processor can run any unassigned job. 1. Complete the following reduction from CMP to STP (the Stable Marriage Problem with ties). [6 marks] Starting with a CMP instance, construct an STP instance as follows: ‹ Woman wi is processor pi. ‹ Man mi is ‹ The preference list for wi lists before ‹ The preference list for mi lists before Then, solve the STP instance to produce a solution S with no strong instabilities. Build a CMP solution by, for each pair (wi, mk) in S, setting M [k] to: 1 Perhaps because processor pi has enough memory, cores, drive space, etc. for job jk. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. 2. Complete the men's and women's preferences in the following instance to show that the reduc- tion above combined with an STP solver that produces a perfect matching with no strong instabilities (i.e., no instabilities in which mi and wj strictly prefer each other to their assigned partners) is not enough to guarantee that the largest possible number of jobs is matched to processors that can run them. [4 marks] m(i, k) is de˝ned by this table: p1 p2 j1 true true j2 true f alse m1 : w1 = w2 w1 : m2 : w2 : Now explain the counterexample : Without any strong instability in the STP solution, we can assign job j1 to p1 p2 no processor and job j2 to p1 p2 no processor which means that 0 1 2 job(s) can be completed. However a better solution would be to assign job j1 to p1 p2 no processor and job j2 to p1 p2 no processor so that 0 1 2 jobs can be completed. 4.1 Solution 1. Starting with a CMP instance, construct an STP instance as follows: ‹ Woman wi is processor pi. ‹ Man mi is job j i ‹ The preference list for wi lists jobs that processor i can run before jobs that processor i cannot run ‹ The preference list for mi lists processors that can run i before processors that cannot run i This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. Then, solve the STP instance to produce a solution S with no strong instabilities. Build a CMP solution by, for each pair (wi, mk) in S, setting M [k] to: i if m(i,k), and X otherwise This approach will guarantee us that we'll never have a processor idle and a job unassigned that could have gone together (because such a pair would have constituted a strong instability in STP). 2. We use our reduction to convert this to an STP instance: m1: w1 = w2 w1: m1 = m2 m2: w1, w2 w2: m1, m2 Note that there are two valid solutions here, and neither has strong instabilities. A strong instability requires a pair of unmarried people who mutually strictly prefer each other, but there is no pair of people that strictly prefers each other. m1 and w1 are simply indi˙erent (and so neither can pair with anyone to produce a strong instability), and m2 and w2 don't like each other. So, we just have to ˝gure out which solution is worse from a getting jobs done perspective, and that's when we put j2 onto p2. So: Without any strong instability in the STP solution, we can assign job j1 to p 1 and job j2 to no processor which means that 1 job(s) can be completed. However a better solution would be to assign job j1 to p 2 and job j2 to p 1 so that 2 jobs can be completed. 5 Not Just for Practice Anymore [5 marks] Solve these variations on ungraded problems from Assignment #1: 1. Recall that STP is the Stable Marriage problem except that ties are allowed in preference lists. Also recall that a strong instability in a perfect matching consists of a woman w and a man m such that w and m both (strictly) prefer each other to their current partners. Describe a way to create an STP instance of an arbitrary size n that has exactly (n − 1)! solutions without strong instabilities, brie˛y justifying why it has the right number of solutions. [3 marks] 2. Imagine that we have a set of n employees. Each one is required to have exactly one mentor chosen from within the same set, but employees can have any number of mentees (zero or more). We can consider any such arrangement to be a directed graph, with each employee as a vertex and an edge from each employee to their mentor. Which of these is true about any such mentorship graph that follows these rules? Fill in the box next to every true statement. [2 marks] The graph has at most one cycle. The graph has at least one cycle. Every vertex in the graph is part of a simple cycle. The graph is strongly connected. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. 5.1 Solution 1. Well, an STP instance with all ties with n − 1 people would have exactly (n − 1)! strong stable solutions. If only we could \"cut out\" one man and woman. And. . . we can do just that by saying that m1 and w1 strictly prefer each other to everyone else. (Then, pairing them with anyone but each other will generate a strong instability.) So, we generate an instance with n ≥ 1 men and women where everyone is entirely indi˙erent except that m1 ranks w1 strictly ˝rst and w1 ranks m1 strictly ˝rst. 2. We can easily generate a graph with multiple cycles. For instance, what if e1 mentors e2 who mentors e1 and e3 mentors e4 who mentors e3. We can also generate graphs where some vertices are not in simple cycles. How about e1 mentors e2 and e3. e2 mentors e1. Note that e3 is not part of any simple cycle. And neither of these sample graphs was strongly connected. That leaves having at least one cycle. A pigeonhole argument as in the assignment problem shows that yes, there must be at least one cycle. (Look back at the just-for-practice problems in Assignment #1!) 6 BONUS: From the Cutting Room Floor [2 BONUS marks] DO ANSWER the new ˝rst bonus problem below (but probably don't waste your time on the second one). Otherwise, all directions from the individual exam still apply: Bonus marks add to your exam and course bonus mark total but are not required. WARNING : These questions are too hard for their point values. We are free to mark these questions harshly. Finish the rest of the exam before attempting these questions. Do not taunt these questions. 1. ANSWER THIS ONE: What is one thing you'd like to see on a subsequent assignment in CPSC 320? To receive 1 bonus point, your answer must be at least as insightful as the response \"a picture of a cat\", which is a low bar! (Yes, literally writing \"a picture of a cat\" is worth credit.) We MAY allocate one additional course (but not exam) bonus point for especially insightful (or hilarious) responses. 2. RECALL from Assignment #2: For its Blue-and-Gold fundraising campaign, UBC has found an- chors \u0016major donors, each with a limit (maximum amount they will donate)\u0016and causes to which the anchors will donate. Each cause has a goal , the maximum money that will go to the cause. An anchor donates to at most one cause , but one cause may receive donations from many anchors , and the total amount of the donations of anchors to a cause cannot exceed that cause's goal. The Blue-and-Gold Problem, or BGP, consists in determining how much money each anchor will give to each cause, subject to the constraints stated above. A BGP instance's solution is the maximum dollar amount that can be raised. (Assume limits are distinct, as are goals.) Consider the following greedy algorithm for this problem: (a) Sort the limits in decreasing order. (b) For each limit L starting with the largest: Find the cause with the least money remaining toward its goal (where the amount currently remaining is G) such that L ≤ G. If such a cause exists, match L with that cause, and decrease that cause's remaining goal by the minimum of L and G. Otherwise, ˝nd the cause with the largest remaining goal (which may be 0), match L with that cause, and set that cause's remaining goal to 0. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia. Is this algorithm optimal for this problem? Yes No If you answered yes, give a clear, concise, and complete proof of your answer (i.e., not just a proof sketch). If you answered no, give a complete (but small) counterexample to its correctness (i.e., an instance and also the optimal solution, greedy solution, and clear explanations of each). 6.1 Solution No solution here! Bonuses are bonuses for a reason :) Here's some hints, though. No, the algorithm isn't optimal. A way to \"trap\" the greedy solution is to note that always picking a goal larger than your limit just because it exists is not the best strategy. Sometimes a smaller goal is a better choice. Oh, and there are pretty small counterexample instances! This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. cbn For license purposes, the author is the University of British Columbia.","libVersion":"0.2.1","langs":""}