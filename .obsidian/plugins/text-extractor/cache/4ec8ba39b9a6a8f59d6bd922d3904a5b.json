{"path":".obsidian/plugins/text-extractor/cache/4ec8ba39b9a6a8f59d6bd922d3904a5b.json","text":"2 Dynamic programming: Growing from the leaves The recursive technique from the previous part is called memoization. Turning it into dynamic programming requires avoiding recursion by changing the order in which we consider the subproblems. Here again is the recurrence for the smallest number of coins needed to make n cents in change, renamed to Soln: Solnli] = infinity, for i <0 Soln[0] = 0, Soln[i] = 1+ min{Soln[i — 25], Soln[i — 10], Soln[i — 1]} otherwise. 1. Which entries of the Soln array need to be filled in before we’re ready to compute the value for Soln[i]? 2. Give a simple order in which we could compute the entries of Soln so that all previous entries needed are already computed by the time we want to compute a new entry’s value. 3. Take advantage of this ordering to rewrite BRUTE-FORCE-CHANGE without using recursion: function SOLN’(3) > Note: It would be handy if Soln had 0 and negative entries. > We use this function SOLN’ to simulate this. if i < 0 then return infinity else if i = 0 then return _____ else return Solnli] function DP-CHANGE(n) if n < 0 then return SOLN’(n) else > Assumes n > 0; otherwise, just run SOLN’ create a new array Soln[1..n| for ~__do Soln[i] ¢~ the return Soln[n|","libVersion":"0.2.1","langs":"eng"}