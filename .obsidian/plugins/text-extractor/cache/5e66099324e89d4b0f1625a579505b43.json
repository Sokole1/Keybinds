{"path":".obsidian/plugins/text-extractor/cache/5e66099324e89d4b0f1625a579505b43.json","text":"6. Modify the QuickSort algorithm so that it finds the element of rank k. Just cross out or change parts of the code below as you see fit. Change the function’s name! Add a parameter! Feel the power! function QUICKSORT(A[1..n]) // returns the sorted array A of n distinct numbers if n > 1 then Choose pivot element p = A[1] Let Lesser be an array of all elements from A less than p Let Greater be an array of all elements from A greater than p Let LesserSorted = QuickSort(Lesser) Let GreaterSorted = QuickSort(Greater) return the concatenation of LesserSorted, [p], and GreaterSorted else return A 7. Once again, suppose that the rank of the pivot in your median-finding algorithm on a problem of size n is always in the range between [%] and I_%\"J Draw the recursion tree that corresponds to the worst-case running time of the algorithm, and give a tight big-O bound in the algorithm’s running time. Also, provide an asymptotic lower bound on the algorithm’s running time.","libVersion":"0.2.1","langs":"eng"}