{"path":".obsidian/plugins/text-extractor/cache/3a1ea7f98e589698c55a141e59121905.json","text":"Decode (pre-ALU)  Execute  Memory  Writeback PC Update    srcA  srcB valA, valB  ALU A  ALU B  valE (ALU B op ALU A)  addr data/M   dst  dstM PC  Halt, nop      valA=R[srcA] valB=R[srcB ]                valP  Rrmvxx ra, rb  rA  F  valA  0  0 + valA      rB*    Irmovq valC, rb   F  valC  0  0 + valC      rB    Rmmovq ra, valC(rb)  rA  rB  valC  valB valB + valC  valE  valA      Mrmovq valC(rb), ra  valC  valB valB + valC  valE  READ   rA  OPq, ra, rb  valA  valB valB op valA, setCC     rB    jXX, valC                    Cond ? valC : valP  Call, valC    Rsp  -8  valB valB – 8  valE  valP  Rsp    valC  Ret  Rsp  8  valB valB + 8  valA  READ    valM  Pushq, ra  rA  -8  valB valB - 8  valE  valA    valP Popq, ra  Rsp  8  valB valB + 8  valA  READ  rA    F e t c h   D e c o d e   E x e c u t e ( A L U )   M e m o r y   W r i t e b a c k ( E / M )   P C U p d a t e   I n p u t   M [ P C ]   R [ r A ] , R [ r B ] , R [ r s p ]   A L U A ( v a lA ( ± 8 ) , v a lC ) , A L U B ( v a lB )  I f u n , c o n d , C C   R e a d : M [ v a lE ]   W r i t e : v a lA , v a lE ( a d d r e s s ) , v a lP   C n d , v a lE , v a lM   C n d , v a lC , v a lM , v a lP   O u t p u t   I c o d e , i f u n , r A , r B , v a lC , v a lP   v a lA , v a lB ( r B , r s p o r F )   v a lE  f la g s   R e a d : v a lM   W r i t e : M [ v a lE ]   v a lE : r B , R s p  v a lM : r A  P C   ... L a s t a r g u m e n t f r o m B t o C ( i f a r g o n s t a c k ) % r b p - 0 x 1 6 S e c o n d - t o - la s t lo c a l v a r i a b le o f B % r b p – 0 x 8   L a s t lo c a l v a r i a b le s o f B   % r b p   A ’s B a s e p o i n t e r A d d r e s s ( i f e x i s t s )   % r b p + 0 x 8 , % r s p   N e x t R e t u r n A d d r e s s   % r b p + 0 x 1 0   F i r s t A r g f r o m A t o B ( i f a r g u m e n t o n s t a c k )   A c a lls B , w h i c h c a lls C P U S H : d e c r e a s e s t a c k p o i n t e r - > a d d d a t a i n ; P O P : r e a d f r o m s t a c k p o i n t e r - > i n c r e a s e s t a c k p o i n t e r Unit 1: y86, sequential S t a llin g : # in s t r u c t io n + # s t a ll + 4 N o f o r w a r d / b r a n c h : a lw a y s 3 – o p s b e t w e e n R E T : 3 C o n d it io n a l/ p r e d ic t io n f a ilu r e : 2 D a t a f o r w a r d in g : D a t a n e e d e d in d e c o d e s t a g e ; if w r it e t o r e g is t e r ( f e t c h ) t h e n 1 o t h e r o p n e e d e d 0 o p : e _ v a lE ( A L U ) , D N E f o r m e m o r y 1 o p : M _ v a lE , m _ v a lM 2 o p : W _ v a lE , W _ v a lM 3 o p : n o t n e e d e d Unit 3: Caching Unit 2: y86, pipelined Average access time = average seek time + 1/2 rotation + sector transfer time = (60 * 1000/RPM)(1/2 + 1/[sectors per track]) Unit 4: File System Disk blocks can be used to either include data, directory, or inodes. Assume we want to find entry with name n. For all files f in some directory dir: If f.name = n and f.ino != 0: return f.ino; Examples of Read / Write int copy (const char * infile, const char * outfile) { int fd_in = open(infile, O_RDONLY, 0644); // Permission bits if (fd_in < 0) return 0; // Error int fd_out = open(outfile, O_WRONLY | O_CREAT, 0644); int buf[1]; // Can be any type provided that it’s a pointer int read_byte = read(fd_in, buf, 1); // Read to void * buffer while (read_byte > 0) { // Not at EOF write(fd_out, buf, 1); // Write from void * buffer read_byte = read(fd_in, buf, 1); } return 1; } open permission bits: read/write/execute user/group/other Disks and file systems bandwidth=(RPM/60)*(#sectors)*(sector size) : (2^10) (MB/s)? File System Behaviour 2 users should share file data 2 processes on same file don’t use same offset 1 process opens a file twice, has 2 fd’s and they don’t share an offset 2 threads using the same fd should use same file offset Child process created from parent process should inherit parent’s fd with same offset, separate process so separate fd table. Same number, diff tables H a r d lin k in c r e a s e t h e lin k c o u n t ; s o f t lin k s in c r e a s e t h e in o d e n u m b e r C a n ’t h a r d lin k o n d ir e c t o r ie s , u n c r e a t e d f ile s , f ile s o n o t h e r f s The Memory Management Unit (MMU) is a hardware component that handles the translation of virtual addresses to physical addresses. It uses the page table set up by the operating system to perform this translation on-the-fly as instructions are executed. If a process tries to access a memory address that is not yet mapped in its address space, the hardware (specifically the MMU) will detect this and raise an exception. The operating system will then handle this exception, sometimes by terminating the process. Virtual memory inserts a mapping stage between addresses used by processes and those used in physical memory (RAM). As a result, we can maintain isolated addresses spaces for the two processes. This means that each process operates as if it has exclusive use of the main memory, unaware of other processes running on the same system. This contributes to process isolation as it prevents one process from accessing the memory space of another process. The operating system is responsible for managing memory access. It keeps track of which parts of memory are currently in use and by which process. It also manages the allocation and deallocation of memory for all processes. Process isolation is a key operating system concept that prevents one process from accessing the memory space of another. This is achieved through the use of virtual memory, where each process is given its own virtual address space P r o c e s s is o la t io n a n d m e m o r y m a n a g e m e n t in c o n c u r r e n t s y s t e m s A d d i t i o n a l l y , i n x 8 6 - 6 4 : V i r t u a l p r o c e s s i s 6 4 b i t s i n t o t a l , b u t t h e t o p 1 6 b i t s a r e u n u s e d A P T E i s 8 b y t e ( 6 4 b i t s ) l o n g , b u t t h e t o p 1 2 b i t s a r e u n u s e d A p a g e t a b l e i s 4 0 9 6 b y t e s , r e s u l t i n g i n 5 1 2 P T E i n a p a g e , n e e d s 9 b i t s a s o f f s e t Unit 5: Virtual Memory Trap handling:","libVersion":"0.2.1","langs":""}